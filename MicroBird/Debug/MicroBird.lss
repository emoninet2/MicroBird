
MicroBird.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000018  00800100  00001a18  00001aac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001a18  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000003bb  00800118  00800118  00001ac4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001ac4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001af4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000520  00000000  00000000  00001b34  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006649  00000000  00000000  00002054  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001537  00000000  00000000  0000869d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000034ce  00000000  00000000  00009bd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001110  00000000  00000000  0000d0a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002608  00000000  00000000  0000e1b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004686  00000000  00000000  000107bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006d8  00000000  00000000  00014e42  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 56 00 	jmp	0xac	; 0xac <__ctors_end>
       4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
       8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
       c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      10:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      14:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      18:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      1c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      20:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      24:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      28:	0c 94 52 06 	jmp	0xca4	; 0xca4 <__vector_10>
      2c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      30:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      34:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      38:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      3c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      40:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      44:	0c 94 d0 01 	jmp	0x3a0	; 0x3a0 <__vector_17>
      48:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      4c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      50:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      54:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      58:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      5c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      60:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      64:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      68:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      6c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      70:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      74:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      78:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      7c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      80:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      84:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      88:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      8c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      90:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      94:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      98:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      9c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      a0:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      a4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      a8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>

000000ac <__ctors_end>:
      ac:	11 24       	eor	r1, r1
      ae:	1f be       	out	0x3f, r1	; 63
      b0:	cf ef       	ldi	r28, 0xFF	; 255
      b2:	da e0       	ldi	r29, 0x0A	; 10
      b4:	de bf       	out	0x3e, r29	; 62
      b6:	cd bf       	out	0x3d, r28	; 61

000000b8 <__do_copy_data>:
      b8:	11 e0       	ldi	r17, 0x01	; 1
      ba:	a0 e0       	ldi	r26, 0x00	; 0
      bc:	b1 e0       	ldi	r27, 0x01	; 1
      be:	e8 e1       	ldi	r30, 0x18	; 24
      c0:	fa e1       	ldi	r31, 0x1A	; 26
      c2:	02 c0       	rjmp	.+4      	; 0xc8 <__do_copy_data+0x10>
      c4:	05 90       	lpm	r0, Z+
      c6:	0d 92       	st	X+, r0
      c8:	a8 31       	cpi	r26, 0x18	; 24
      ca:	b1 07       	cpc	r27, r17
      cc:	d9 f7       	brne	.-10     	; 0xc4 <__do_copy_data+0xc>

000000ce <__do_clear_bss>:
      ce:	24 e0       	ldi	r18, 0x04	; 4
      d0:	a8 e1       	ldi	r26, 0x18	; 24
      d2:	b1 e0       	ldi	r27, 0x01	; 1
      d4:	01 c0       	rjmp	.+2      	; 0xd8 <.do_clear_bss_start>

000000d6 <.do_clear_bss_loop>:
      d6:	1d 92       	st	X+, r1

000000d8 <.do_clear_bss_start>:
      d8:	a3 3d       	cpi	r26, 0xD3	; 211
      da:	b2 07       	cpc	r27, r18
      dc:	e1 f7       	brne	.-8      	; 0xd6 <.do_clear_bss_loop>
      de:	0e 94 1c 09 	call	0x1238	; 0x1238 <main>
      e2:	0c 94 0a 0d 	jmp	0x1a14	; 0x1a14 <_exit>

000000e6 <__bad_interrupt>:
      e6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ea <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
      ea:	31 e1       	ldi	r19, 0x11	; 17
      ec:	fc 01       	movw	r30, r24
      ee:	30 83       	st	Z, r19
      f0:	31 97       	sbiw	r30, 0x01	; 1
      f2:	22 e2       	ldi	r18, 0x22	; 34
      f4:	20 83       	st	Z, r18
      f6:	31 97       	sbiw	r30, 0x01	; 1
      f8:	a3 e3       	ldi	r26, 0x33	; 51
      fa:	a0 83       	st	Z, r26
      fc:	31 97       	sbiw	r30, 0x01	; 1
      fe:	60 83       	st	Z, r22
     100:	31 97       	sbiw	r30, 0x01	; 1
     102:	70 83       	st	Z, r23
     104:	31 97       	sbiw	r30, 0x01	; 1
     106:	10 82       	st	Z, r1
     108:	31 97       	sbiw	r30, 0x01	; 1
     10a:	60 e8       	ldi	r22, 0x80	; 128
     10c:	60 83       	st	Z, r22
     10e:	31 97       	sbiw	r30, 0x01	; 1
     110:	10 82       	st	Z, r1
     112:	31 97       	sbiw	r30, 0x01	; 1
     114:	62 e0       	ldi	r22, 0x02	; 2
     116:	60 83       	st	Z, r22
     118:	31 97       	sbiw	r30, 0x01	; 1
     11a:	63 e0       	ldi	r22, 0x03	; 3
     11c:	60 83       	st	Z, r22
     11e:	31 97       	sbiw	r30, 0x01	; 1
     120:	64 e0       	ldi	r22, 0x04	; 4
     122:	60 83       	st	Z, r22
     124:	31 97       	sbiw	r30, 0x01	; 1
     126:	65 e0       	ldi	r22, 0x05	; 5
     128:	60 83       	st	Z, r22
     12a:	31 97       	sbiw	r30, 0x01	; 1
     12c:	66 e0       	ldi	r22, 0x06	; 6
     12e:	60 83       	st	Z, r22
     130:	31 97       	sbiw	r30, 0x01	; 1
     132:	67 e0       	ldi	r22, 0x07	; 7
     134:	60 83       	st	Z, r22
     136:	31 97       	sbiw	r30, 0x01	; 1
     138:	68 e0       	ldi	r22, 0x08	; 8
     13a:	60 83       	st	Z, r22
     13c:	31 97       	sbiw	r30, 0x01	; 1
     13e:	69 e0       	ldi	r22, 0x09	; 9
     140:	60 83       	st	Z, r22
     142:	31 97       	sbiw	r30, 0x01	; 1
     144:	60 e1       	ldi	r22, 0x10	; 16
     146:	60 83       	st	Z, r22
     148:	31 97       	sbiw	r30, 0x01	; 1
     14a:	30 83       	st	Z, r19
     14c:	31 97       	sbiw	r30, 0x01	; 1
     14e:	32 e1       	ldi	r19, 0x12	; 18
     150:	30 83       	st	Z, r19
     152:	31 97       	sbiw	r30, 0x01	; 1
     154:	33 e1       	ldi	r19, 0x13	; 19
     156:	30 83       	st	Z, r19
     158:	31 97       	sbiw	r30, 0x01	; 1
     15a:	34 e1       	ldi	r19, 0x14	; 20
     15c:	30 83       	st	Z, r19
     15e:	31 97       	sbiw	r30, 0x01	; 1
     160:	35 e1       	ldi	r19, 0x15	; 21
     162:	30 83       	st	Z, r19
     164:	31 97       	sbiw	r30, 0x01	; 1
     166:	36 e1       	ldi	r19, 0x16	; 22
     168:	30 83       	st	Z, r19
     16a:	31 97       	sbiw	r30, 0x01	; 1
     16c:	37 e1       	ldi	r19, 0x17	; 23
     16e:	30 83       	st	Z, r19
     170:	31 97       	sbiw	r30, 0x01	; 1
     172:	38 e1       	ldi	r19, 0x18	; 24
     174:	30 83       	st	Z, r19
     176:	31 97       	sbiw	r30, 0x01	; 1
     178:	39 e1       	ldi	r19, 0x19	; 25
     17a:	30 83       	st	Z, r19
     17c:	31 97       	sbiw	r30, 0x01	; 1
     17e:	30 e2       	ldi	r19, 0x20	; 32
     180:	30 83       	st	Z, r19
     182:	31 97       	sbiw	r30, 0x01	; 1
     184:	31 e2       	ldi	r19, 0x21	; 33
     186:	30 83       	st	Z, r19
     188:	31 97       	sbiw	r30, 0x01	; 1
     18a:	20 83       	st	Z, r18
     18c:	31 97       	sbiw	r30, 0x01	; 1
     18e:	23 e2       	ldi	r18, 0x23	; 35
     190:	20 83       	st	Z, r18
     192:	31 97       	sbiw	r30, 0x01	; 1
     194:	40 83       	st	Z, r20
     196:	31 97       	sbiw	r30, 0x01	; 1
     198:	50 83       	st	Z, r21
     19a:	31 97       	sbiw	r30, 0x01	; 1
     19c:	26 e2       	ldi	r18, 0x26	; 38
     19e:	20 83       	st	Z, r18
     1a0:	31 97       	sbiw	r30, 0x01	; 1
     1a2:	27 e2       	ldi	r18, 0x27	; 39
     1a4:	20 83       	st	Z, r18
     1a6:	31 97       	sbiw	r30, 0x01	; 1
     1a8:	28 e2       	ldi	r18, 0x28	; 40
     1aa:	20 83       	st	Z, r18
     1ac:	31 97       	sbiw	r30, 0x01	; 1
     1ae:	29 e2       	ldi	r18, 0x29	; 41
     1b0:	20 83       	st	Z, r18
     1b2:	31 97       	sbiw	r30, 0x01	; 1
     1b4:	20 e3       	ldi	r18, 0x30	; 48
     1b6:	20 83       	st	Z, r18
     1b8:	31 97       	sbiw	r30, 0x01	; 1
     1ba:	21 e3       	ldi	r18, 0x31	; 49
     1bc:	20 83       	st	Z, r18
     1be:	86 97       	sbiw	r24, 0x26	; 38
     1c0:	08 95       	ret

000001c2 <xPortStartScheduler>:
     1c2:	10 92 89 00 	sts	0x0089, r1
     1c6:	89 ef       	ldi	r24, 0xF9	; 249
     1c8:	80 93 88 00 	sts	0x0088, r24
     1cc:	8b e0       	ldi	r24, 0x0B	; 11
     1ce:	80 93 81 00 	sts	0x0081, r24
     1d2:	ef e6       	ldi	r30, 0x6F	; 111
     1d4:	f0 e0       	ldi	r31, 0x00	; 0
     1d6:	80 81       	ld	r24, Z
     1d8:	82 60       	ori	r24, 0x02	; 2
     1da:	80 83       	st	Z, r24
     1dc:	a0 91 bd 04 	lds	r26, 0x04BD
     1e0:	b0 91 be 04 	lds	r27, 0x04BE
     1e4:	cd 91       	ld	r28, X+
     1e6:	cd bf       	out	0x3d, r28	; 61
     1e8:	dd 91       	ld	r29, X+
     1ea:	de bf       	out	0x3e, r29	; 62
     1ec:	ff 91       	pop	r31
     1ee:	ef 91       	pop	r30
     1f0:	df 91       	pop	r29
     1f2:	cf 91       	pop	r28
     1f4:	bf 91       	pop	r27
     1f6:	af 91       	pop	r26
     1f8:	9f 91       	pop	r25
     1fa:	8f 91       	pop	r24
     1fc:	7f 91       	pop	r23
     1fe:	6f 91       	pop	r22
     200:	5f 91       	pop	r21
     202:	4f 91       	pop	r20
     204:	3f 91       	pop	r19
     206:	2f 91       	pop	r18
     208:	1f 91       	pop	r17
     20a:	0f 91       	pop	r16
     20c:	ff 90       	pop	r15
     20e:	ef 90       	pop	r14
     210:	df 90       	pop	r13
     212:	cf 90       	pop	r12
     214:	bf 90       	pop	r11
     216:	af 90       	pop	r10
     218:	9f 90       	pop	r9
     21a:	8f 90       	pop	r8
     21c:	7f 90       	pop	r7
     21e:	6f 90       	pop	r6
     220:	5f 90       	pop	r5
     222:	4f 90       	pop	r4
     224:	3f 90       	pop	r3
     226:	2f 90       	pop	r2
     228:	1f 90       	pop	r1
     22a:	0f 90       	pop	r0
     22c:	0f be       	out	0x3f, r0	; 63
     22e:	0f 90       	pop	r0
     230:	08 95       	ret
     232:	81 e0       	ldi	r24, 0x01	; 1
     234:	08 95       	ret

00000236 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     236:	0f 92       	push	r0
     238:	0f b6       	in	r0, 0x3f	; 63
     23a:	f8 94       	cli
     23c:	0f 92       	push	r0
     23e:	1f 92       	push	r1
     240:	11 24       	eor	r1, r1
     242:	2f 92       	push	r2
     244:	3f 92       	push	r3
     246:	4f 92       	push	r4
     248:	5f 92       	push	r5
     24a:	6f 92       	push	r6
     24c:	7f 92       	push	r7
     24e:	8f 92       	push	r8
     250:	9f 92       	push	r9
     252:	af 92       	push	r10
     254:	bf 92       	push	r11
     256:	cf 92       	push	r12
     258:	df 92       	push	r13
     25a:	ef 92       	push	r14
     25c:	ff 92       	push	r15
     25e:	0f 93       	push	r16
     260:	1f 93       	push	r17
     262:	2f 93       	push	r18
     264:	3f 93       	push	r19
     266:	4f 93       	push	r20
     268:	5f 93       	push	r21
     26a:	6f 93       	push	r22
     26c:	7f 93       	push	r23
     26e:	8f 93       	push	r24
     270:	9f 93       	push	r25
     272:	af 93       	push	r26
     274:	bf 93       	push	r27
     276:	cf 93       	push	r28
     278:	df 93       	push	r29
     27a:	ef 93       	push	r30
     27c:	ff 93       	push	r31
     27e:	a0 91 bd 04 	lds	r26, 0x04BD
     282:	b0 91 be 04 	lds	r27, 0x04BE
     286:	0d b6       	in	r0, 0x3d	; 61
     288:	0d 92       	st	X+, r0
     28a:	0e b6       	in	r0, 0x3e	; 62
     28c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     28e:	0e 94 7f 05 	call	0xafe	; 0xafe <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     292:	a0 91 bd 04 	lds	r26, 0x04BD
     296:	b0 91 be 04 	lds	r27, 0x04BE
     29a:	cd 91       	ld	r28, X+
     29c:	cd bf       	out	0x3d, r28	; 61
     29e:	dd 91       	ld	r29, X+
     2a0:	de bf       	out	0x3e, r29	; 62
     2a2:	ff 91       	pop	r31
     2a4:	ef 91       	pop	r30
     2a6:	df 91       	pop	r29
     2a8:	cf 91       	pop	r28
     2aa:	bf 91       	pop	r27
     2ac:	af 91       	pop	r26
     2ae:	9f 91       	pop	r25
     2b0:	8f 91       	pop	r24
     2b2:	7f 91       	pop	r23
     2b4:	6f 91       	pop	r22
     2b6:	5f 91       	pop	r21
     2b8:	4f 91       	pop	r20
     2ba:	3f 91       	pop	r19
     2bc:	2f 91       	pop	r18
     2be:	1f 91       	pop	r17
     2c0:	0f 91       	pop	r16
     2c2:	ff 90       	pop	r15
     2c4:	ef 90       	pop	r14
     2c6:	df 90       	pop	r13
     2c8:	cf 90       	pop	r12
     2ca:	bf 90       	pop	r11
     2cc:	af 90       	pop	r10
     2ce:	9f 90       	pop	r9
     2d0:	8f 90       	pop	r8
     2d2:	7f 90       	pop	r7
     2d4:	6f 90       	pop	r6
     2d6:	5f 90       	pop	r5
     2d8:	4f 90       	pop	r4
     2da:	3f 90       	pop	r3
     2dc:	2f 90       	pop	r2
     2de:	1f 90       	pop	r1
     2e0:	0f 90       	pop	r0
     2e2:	0f be       	out	0x3f, r0	; 63
     2e4:	0f 90       	pop	r0

	asm volatile ( "ret" );
     2e6:	08 95       	ret

000002e8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     2e8:	0f 92       	push	r0
     2ea:	0f b6       	in	r0, 0x3f	; 63
     2ec:	f8 94       	cli
     2ee:	0f 92       	push	r0
     2f0:	1f 92       	push	r1
     2f2:	11 24       	eor	r1, r1
     2f4:	2f 92       	push	r2
     2f6:	3f 92       	push	r3
     2f8:	4f 92       	push	r4
     2fa:	5f 92       	push	r5
     2fc:	6f 92       	push	r6
     2fe:	7f 92       	push	r7
     300:	8f 92       	push	r8
     302:	9f 92       	push	r9
     304:	af 92       	push	r10
     306:	bf 92       	push	r11
     308:	cf 92       	push	r12
     30a:	df 92       	push	r13
     30c:	ef 92       	push	r14
     30e:	ff 92       	push	r15
     310:	0f 93       	push	r16
     312:	1f 93       	push	r17
     314:	2f 93       	push	r18
     316:	3f 93       	push	r19
     318:	4f 93       	push	r20
     31a:	5f 93       	push	r21
     31c:	6f 93       	push	r22
     31e:	7f 93       	push	r23
     320:	8f 93       	push	r24
     322:	9f 93       	push	r25
     324:	af 93       	push	r26
     326:	bf 93       	push	r27
     328:	cf 93       	push	r28
     32a:	df 93       	push	r29
     32c:	ef 93       	push	r30
     32e:	ff 93       	push	r31
     330:	a0 91 bd 04 	lds	r26, 0x04BD
     334:	b0 91 be 04 	lds	r27, 0x04BE
     338:	0d b6       	in	r0, 0x3d	; 61
     33a:	0d 92       	st	X+, r0
     33c:	0e b6       	in	r0, 0x3e	; 62
     33e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     340:	0e 94 04 04 	call	0x808	; 0x808 <xTaskIncrementTick>
     344:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     346:	0e 94 7f 05 	call	0xafe	; 0xafe <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     34a:	a0 91 bd 04 	lds	r26, 0x04BD
     34e:	b0 91 be 04 	lds	r27, 0x04BE
     352:	cd 91       	ld	r28, X+
     354:	cd bf       	out	0x3d, r28	; 61
     356:	dd 91       	ld	r29, X+
     358:	de bf       	out	0x3e, r29	; 62
     35a:	ff 91       	pop	r31
     35c:	ef 91       	pop	r30
     35e:	df 91       	pop	r29
     360:	cf 91       	pop	r28
     362:	bf 91       	pop	r27
     364:	af 91       	pop	r26
     366:	9f 91       	pop	r25
     368:	8f 91       	pop	r24
     36a:	7f 91       	pop	r23
     36c:	6f 91       	pop	r22
     36e:	5f 91       	pop	r21
     370:	4f 91       	pop	r20
     372:	3f 91       	pop	r19
     374:	2f 91       	pop	r18
     376:	1f 91       	pop	r17
     378:	0f 91       	pop	r16
     37a:	ff 90       	pop	r15
     37c:	ef 90       	pop	r14
     37e:	df 90       	pop	r13
     380:	cf 90       	pop	r12
     382:	bf 90       	pop	r11
     384:	af 90       	pop	r10
     386:	9f 90       	pop	r9
     388:	8f 90       	pop	r8
     38a:	7f 90       	pop	r7
     38c:	6f 90       	pop	r6
     38e:	5f 90       	pop	r5
     390:	4f 90       	pop	r4
     392:	3f 90       	pop	r3
     394:	2f 90       	pop	r2
     396:	1f 90       	pop	r1
     398:	0f 90       	pop	r0
     39a:	0f be       	out	0x3f, r0	; 63
     39c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     39e:	08 95       	ret

000003a0 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     3a0:	0e 94 74 01 	call	0x2e8	; 0x2e8 <vPortYieldFromTick>
		asm volatile ( "reti" );
     3a4:	18 95       	reti

000003a6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     3a6:	cf 93       	push	r28
     3a8:	df 93       	push	r29
     3aa:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     3ac:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     3b0:	80 91 1a 01 	lds	r24, 0x011A
     3b4:	90 91 1b 01 	lds	r25, 0x011B
     3b8:	89 2b       	or	r24, r25
     3ba:	31 f4       	brne	.+12     	; 0x3c8 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     3bc:	8f e1       	ldi	r24, 0x1F	; 31
     3be:	91 e0       	ldi	r25, 0x01	; 1
     3c0:	90 93 1b 01 	sts	0x011B, r25
     3c4:	80 93 1a 01 	sts	0x011A, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     3c8:	20 91 1c 01 	lds	r18, 0x011C
     3cc:	30 91 1d 01 	lds	r19, 0x011D
     3d0:	ce 01       	movw	r24, r28
     3d2:	82 0f       	add	r24, r18
     3d4:	93 1f       	adc	r25, r19
     3d6:	81 35       	cpi	r24, 0x51	; 81
     3d8:	43 e0       	ldi	r20, 0x03	; 3
     3da:	94 07       	cpc	r25, r20
     3dc:	70 f4       	brcc	.+28     	; 0x3fa <pvPortMalloc+0x54>
     3de:	28 17       	cp	r18, r24
     3e0:	39 07       	cpc	r19, r25
     3e2:	70 f4       	brcc	.+28     	; 0x400 <__FUSE_REGION_LENGTH__>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     3e4:	c0 91 1a 01 	lds	r28, 0x011A
     3e8:	d0 91 1b 01 	lds	r29, 0x011B
     3ec:	c2 0f       	add	r28, r18
     3ee:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     3f0:	90 93 1d 01 	sts	0x011D, r25
     3f4:	80 93 1c 01 	sts	0x011C, r24
     3f8:	05 c0       	rjmp	.+10     	; 0x404 <__FUSE_REGION_LENGTH__+0x4>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     3fa:	c0 e0       	ldi	r28, 0x00	; 0
     3fc:	d0 e0       	ldi	r29, 0x00	; 0
     3fe:	02 c0       	rjmp	.+4      	; 0x404 <__FUSE_REGION_LENGTH__+0x4>
     400:	c0 e0       	ldi	r28, 0x00	; 0
     402:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     404:	0e 94 dd 04 	call	0x9ba	; 0x9ba <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     408:	ce 01       	movw	r24, r28
     40a:	df 91       	pop	r29
     40c:	cf 91       	pop	r28
     40e:	08 95       	ret

00000410 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     410:	08 95       	ret

00000412 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     412:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     414:	03 96       	adiw	r24, 0x03	; 3
     416:	92 83       	std	Z+2, r25	; 0x02
     418:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     41a:	2f ef       	ldi	r18, 0xFF	; 255
     41c:	3f ef       	ldi	r19, 0xFF	; 255
     41e:	34 83       	std	Z+4, r19	; 0x04
     420:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     422:	96 83       	std	Z+6, r25	; 0x06
     424:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     426:	90 87       	std	Z+8, r25	; 0x08
     428:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     42a:	10 82       	st	Z, r1
     42c:	08 95       	ret

0000042e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     42e:	fc 01       	movw	r30, r24
     430:	11 86       	std	Z+9, r1	; 0x09
     432:	10 86       	std	Z+8, r1	; 0x08
     434:	08 95       	ret

00000436 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     436:	cf 93       	push	r28
     438:	df 93       	push	r29
     43a:	9c 01       	movw	r18, r24
     43c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     43e:	dc 01       	movw	r26, r24
     440:	11 96       	adiw	r26, 0x01	; 1
     442:	cd 91       	ld	r28, X+
     444:	dc 91       	ld	r29, X
     446:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     448:	d3 83       	std	Z+3, r29	; 0x03
     44a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     44c:	8c 81       	ldd	r24, Y+4	; 0x04
     44e:	9d 81       	ldd	r25, Y+5	; 0x05
     450:	95 83       	std	Z+5, r25	; 0x05
     452:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     454:	8c 81       	ldd	r24, Y+4	; 0x04
     456:	9d 81       	ldd	r25, Y+5	; 0x05
     458:	dc 01       	movw	r26, r24
     45a:	13 96       	adiw	r26, 0x03	; 3
     45c:	7c 93       	st	X, r23
     45e:	6e 93       	st	-X, r22
     460:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     462:	7d 83       	std	Y+5, r23	; 0x05
     464:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     466:	31 87       	std	Z+9, r19	; 0x09
     468:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     46a:	f9 01       	movw	r30, r18
     46c:	80 81       	ld	r24, Z
     46e:	8f 5f       	subi	r24, 0xFF	; 255
     470:	80 83       	st	Z, r24
}
     472:	df 91       	pop	r29
     474:	cf 91       	pop	r28
     476:	08 95       	ret

00000478 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     478:	cf 93       	push	r28
     47a:	df 93       	push	r29
     47c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     47e:	48 81       	ld	r20, Y
     480:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     482:	4f 3f       	cpi	r20, 0xFF	; 255
     484:	2f ef       	ldi	r18, 0xFF	; 255
     486:	52 07       	cpc	r21, r18
     488:	21 f4       	brne	.+8      	; 0x492 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     48a:	fc 01       	movw	r30, r24
     48c:	a7 81       	ldd	r26, Z+7	; 0x07
     48e:	b0 85       	ldd	r27, Z+8	; 0x08
     490:	0d c0       	rjmp	.+26     	; 0x4ac <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     492:	dc 01       	movw	r26, r24
     494:	13 96       	adiw	r26, 0x03	; 3
     496:	01 c0       	rjmp	.+2      	; 0x49a <vListInsert+0x22>
     498:	df 01       	movw	r26, r30
     49a:	12 96       	adiw	r26, 0x02	; 2
     49c:	ed 91       	ld	r30, X+
     49e:	fc 91       	ld	r31, X
     4a0:	13 97       	sbiw	r26, 0x03	; 3
     4a2:	20 81       	ld	r18, Z
     4a4:	31 81       	ldd	r19, Z+1	; 0x01
     4a6:	42 17       	cp	r20, r18
     4a8:	53 07       	cpc	r21, r19
     4aa:	b0 f7       	brcc	.-20     	; 0x498 <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     4ac:	12 96       	adiw	r26, 0x02	; 2
     4ae:	ed 91       	ld	r30, X+
     4b0:	fc 91       	ld	r31, X
     4b2:	13 97       	sbiw	r26, 0x03	; 3
     4b4:	fb 83       	std	Y+3, r31	; 0x03
     4b6:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     4b8:	d5 83       	std	Z+5, r29	; 0x05
     4ba:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     4bc:	bd 83       	std	Y+5, r27	; 0x05
     4be:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     4c0:	13 96       	adiw	r26, 0x03	; 3
     4c2:	dc 93       	st	X, r29
     4c4:	ce 93       	st	-X, r28
     4c6:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     4c8:	99 87       	std	Y+9, r25	; 0x09
     4ca:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     4cc:	fc 01       	movw	r30, r24
     4ce:	20 81       	ld	r18, Z
     4d0:	2f 5f       	subi	r18, 0xFF	; 255
     4d2:	20 83       	st	Z, r18
}
     4d4:	df 91       	pop	r29
     4d6:	cf 91       	pop	r28
     4d8:	08 95       	ret

000004da <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     4da:	cf 93       	push	r28
     4dc:	df 93       	push	r29
     4de:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     4e0:	a0 85       	ldd	r26, Z+8	; 0x08
     4e2:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     4e4:	c2 81       	ldd	r28, Z+2	; 0x02
     4e6:	d3 81       	ldd	r29, Z+3	; 0x03
     4e8:	84 81       	ldd	r24, Z+4	; 0x04
     4ea:	95 81       	ldd	r25, Z+5	; 0x05
     4ec:	9d 83       	std	Y+5, r25	; 0x05
     4ee:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     4f0:	c4 81       	ldd	r28, Z+4	; 0x04
     4f2:	d5 81       	ldd	r29, Z+5	; 0x05
     4f4:	82 81       	ldd	r24, Z+2	; 0x02
     4f6:	93 81       	ldd	r25, Z+3	; 0x03
     4f8:	9b 83       	std	Y+3, r25	; 0x03
     4fa:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     4fc:	11 96       	adiw	r26, 0x01	; 1
     4fe:	cd 91       	ld	r28, X+
     500:	dc 91       	ld	r29, X
     502:	12 97       	sbiw	r26, 0x02	; 2
     504:	ce 17       	cp	r28, r30
     506:	df 07       	cpc	r29, r31
     508:	31 f4       	brne	.+12     	; 0x516 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     50a:	8c 81       	ldd	r24, Y+4	; 0x04
     50c:	9d 81       	ldd	r25, Y+5	; 0x05
     50e:	12 96       	adiw	r26, 0x02	; 2
     510:	9c 93       	st	X, r25
     512:	8e 93       	st	-X, r24
     514:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     516:	11 86       	std	Z+9, r1	; 0x09
     518:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     51a:	8c 91       	ld	r24, X
     51c:	81 50       	subi	r24, 0x01	; 1
     51e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     520:	df 91       	pop	r29
     522:	cf 91       	pop	r28
     524:	08 95       	ret

00000526 <prvIdleTask>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     526:	ff cf       	rjmp	.-2      	; 0x526 <prvIdleTask>

00000528 <prvAddCurrentTaskToDelayedList>:
     528:	cf 93       	push	r28
     52a:	df 93       	push	r29
     52c:	ec 01       	movw	r28, r24
     52e:	e0 91 bd 04 	lds	r30, 0x04BD
     532:	f0 91 be 04 	lds	r31, 0x04BE
     536:	93 83       	std	Z+3, r25	; 0x03
     538:	82 83       	std	Z+2, r24	; 0x02
     53a:	80 91 77 04 	lds	r24, 0x0477
     53e:	90 91 78 04 	lds	r25, 0x0478
     542:	c8 17       	cp	r28, r24
     544:	d9 07       	cpc	r29, r25
     546:	68 f4       	brcc	.+26     	; 0x562 <prvAddCurrentTaskToDelayedList+0x3a>
     548:	60 91 bd 04 	lds	r22, 0x04BD
     54c:	70 91 be 04 	lds	r23, 0x04BE
     550:	80 91 83 04 	lds	r24, 0x0483
     554:	90 91 84 04 	lds	r25, 0x0484
     558:	6e 5f       	subi	r22, 0xFE	; 254
     55a:	7f 4f       	sbci	r23, 0xFF	; 255
     55c:	0e 94 3c 02 	call	0x478	; 0x478 <vListInsert>
     560:	17 c0       	rjmp	.+46     	; 0x590 <prvAddCurrentTaskToDelayedList+0x68>
     562:	60 91 bd 04 	lds	r22, 0x04BD
     566:	70 91 be 04 	lds	r23, 0x04BE
     56a:	80 91 85 04 	lds	r24, 0x0485
     56e:	90 91 86 04 	lds	r25, 0x0486
     572:	6e 5f       	subi	r22, 0xFE	; 254
     574:	7f 4f       	sbci	r23, 0xFF	; 255
     576:	0e 94 3c 02 	call	0x478	; 0x478 <vListInsert>
     57a:	80 91 00 01 	lds	r24, 0x0100
     57e:	90 91 01 01 	lds	r25, 0x0101
     582:	c8 17       	cp	r28, r24
     584:	d9 07       	cpc	r29, r25
     586:	20 f4       	brcc	.+8      	; 0x590 <prvAddCurrentTaskToDelayedList+0x68>
     588:	d0 93 01 01 	sts	0x0101, r29
     58c:	c0 93 00 01 	sts	0x0100, r28
     590:	df 91       	pop	r29
     592:	cf 91       	pop	r28
     594:	08 95       	ret

00000596 <xTaskGenericCreate>:
     596:	4f 92       	push	r4
     598:	5f 92       	push	r5
     59a:	6f 92       	push	r6
     59c:	7f 92       	push	r7
     59e:	8f 92       	push	r8
     5a0:	9f 92       	push	r9
     5a2:	af 92       	push	r10
     5a4:	bf 92       	push	r11
     5a6:	cf 92       	push	r12
     5a8:	df 92       	push	r13
     5aa:	ef 92       	push	r14
     5ac:	ff 92       	push	r15
     5ae:	0f 93       	push	r16
     5b0:	1f 93       	push	r17
     5b2:	cf 93       	push	r28
     5b4:	df 93       	push	r29
     5b6:	4c 01       	movw	r8, r24
     5b8:	eb 01       	movw	r28, r22
     5ba:	5a 01       	movw	r10, r20
     5bc:	29 01       	movw	r4, r18
     5be:	81 e2       	ldi	r24, 0x21	; 33
     5c0:	90 e0       	ldi	r25, 0x00	; 0
     5c2:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <pvPortMalloc>
     5c6:	3c 01       	movw	r6, r24
     5c8:	00 97       	sbiw	r24, 0x00	; 0
     5ca:	09 f4       	brne	.+2      	; 0x5ce <xTaskGenericCreate+0x38>
     5cc:	da c0       	rjmp	.+436    	; 0x782 <xTaskGenericCreate+0x1ec>
     5ce:	c1 14       	cp	r12, r1
     5d0:	d1 04       	cpc	r13, r1
     5d2:	09 f0       	breq	.+2      	; 0x5d6 <xTaskGenericCreate+0x40>
     5d4:	d2 c0       	rjmp	.+420    	; 0x77a <xTaskGenericCreate+0x1e4>
     5d6:	c5 01       	movw	r24, r10
     5d8:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <pvPortMalloc>
     5dc:	f3 01       	movw	r30, r6
     5de:	90 8f       	std	Z+24, r25	; 0x18
     5e0:	87 8b       	std	Z+23, r24	; 0x17
     5e2:	89 2b       	or	r24, r25
     5e4:	21 f4       	brne	.+8      	; 0x5ee <xTaskGenericCreate+0x58>
     5e6:	c3 01       	movw	r24, r6
     5e8:	0e 94 08 02 	call	0x410	; 0x410 <vPortFree>
     5ec:	ca c0       	rjmp	.+404    	; 0x782 <xTaskGenericCreate+0x1ec>
     5ee:	f1 e0       	ldi	r31, 0x01	; 1
     5f0:	af 1a       	sub	r10, r31
     5f2:	b1 08       	sbc	r11, r1
     5f4:	f3 01       	movw	r30, r6
     5f6:	87 89       	ldd	r24, Z+23	; 0x17
     5f8:	90 8d       	ldd	r25, Z+24	; 0x18
     5fa:	a8 0e       	add	r10, r24
     5fc:	b9 1e       	adc	r11, r25
     5fe:	88 81       	ld	r24, Y
     600:	81 8f       	std	Z+25, r24	; 0x19
     602:	88 81       	ld	r24, Y
     604:	88 23       	and	r24, r24
     606:	81 f0       	breq	.+32     	; 0x628 <xTaskGenericCreate+0x92>
     608:	d3 01       	movw	r26, r6
     60a:	5a 96       	adiw	r26, 0x1a	; 26
     60c:	fe 01       	movw	r30, r28
     60e:	31 96       	adiw	r30, 0x01	; 1
     610:	9e 01       	movw	r18, r28
     612:	28 5f       	subi	r18, 0xF8	; 248
     614:	3f 4f       	sbci	r19, 0xFF	; 255
     616:	ef 01       	movw	r28, r30
     618:	81 91       	ld	r24, Z+
     61a:	8d 93       	st	X+, r24
     61c:	88 81       	ld	r24, Y
     61e:	88 23       	and	r24, r24
     620:	19 f0       	breq	.+6      	; 0x628 <xTaskGenericCreate+0x92>
     622:	e2 17       	cp	r30, r18
     624:	f3 07       	cpc	r31, r19
     626:	b9 f7       	brne	.-18     	; 0x616 <xTaskGenericCreate+0x80>
     628:	f3 01       	movw	r30, r6
     62a:	10 a2       	std	Z+32, r1	; 0x20
     62c:	10 2f       	mov	r17, r16
     62e:	04 30       	cpi	r16, 0x04	; 4
     630:	08 f0       	brcs	.+2      	; 0x634 <xTaskGenericCreate+0x9e>
     632:	13 e0       	ldi	r17, 0x03	; 3
     634:	f3 01       	movw	r30, r6
     636:	16 8b       	std	Z+22, r17	; 0x16
     638:	e3 01       	movw	r28, r6
     63a:	22 96       	adiw	r28, 0x02	; 2
     63c:	ce 01       	movw	r24, r28
     63e:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialiseItem>
     642:	c3 01       	movw	r24, r6
     644:	0c 96       	adiw	r24, 0x0c	; 12
     646:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialiseItem>
     64a:	f3 01       	movw	r30, r6
     64c:	71 86       	std	Z+9, r7	; 0x09
     64e:	60 86       	std	Z+8, r6	; 0x08
     650:	84 e0       	ldi	r24, 0x04	; 4
     652:	90 e0       	ldi	r25, 0x00	; 0
     654:	81 1b       	sub	r24, r17
     656:	91 09       	sbc	r25, r1
     658:	95 87       	std	Z+13, r25	; 0x0d
     65a:	84 87       	std	Z+12, r24	; 0x0c
     65c:	73 8a       	std	Z+19, r7	; 0x13
     65e:	62 8a       	std	Z+18, r6	; 0x12
     660:	a2 01       	movw	r20, r4
     662:	b4 01       	movw	r22, r8
     664:	c5 01       	movw	r24, r10
     666:	0e 94 75 00 	call	0xea	; 0xea <pxPortInitialiseStack>
     66a:	f3 01       	movw	r30, r6
     66c:	91 83       	std	Z+1, r25	; 0x01
     66e:	80 83       	st	Z, r24
     670:	e1 14       	cp	r14, r1
     672:	f1 04       	cpc	r15, r1
     674:	19 f0       	breq	.+6      	; 0x67c <xTaskGenericCreate+0xe6>
     676:	f7 01       	movw	r30, r14
     678:	71 82       	std	Z+1, r7	; 0x01
     67a:	60 82       	st	Z, r6
     67c:	0f b6       	in	r0, 0x3f	; 63
     67e:	f8 94       	cli
     680:	0f 92       	push	r0
     682:	80 91 79 04 	lds	r24, 0x0479
     686:	8f 5f       	subi	r24, 0xFF	; 255
     688:	80 93 79 04 	sts	0x0479, r24
     68c:	80 91 bd 04 	lds	r24, 0x04BD
     690:	90 91 be 04 	lds	r25, 0x04BE
     694:	89 2b       	or	r24, r25
     696:	89 f5       	brne	.+98     	; 0x6fa <xTaskGenericCreate+0x164>
     698:	70 92 be 04 	sts	0x04BE, r7
     69c:	60 92 bd 04 	sts	0x04BD, r6
     6a0:	80 91 79 04 	lds	r24, 0x0479
     6a4:	81 30       	cpi	r24, 0x01	; 1
     6a6:	c1 f5       	brne	.+112    	; 0x718 <xTaskGenericCreate+0x182>
     6a8:	89 e9       	ldi	r24, 0x99	; 153
     6aa:	94 e0       	ldi	r25, 0x04	; 4
     6ac:	0e 94 09 02 	call	0x412	; 0x412 <vListInitialise>
     6b0:	82 ea       	ldi	r24, 0xA2	; 162
     6b2:	94 e0       	ldi	r25, 0x04	; 4
     6b4:	0e 94 09 02 	call	0x412	; 0x412 <vListInitialise>
     6b8:	8b ea       	ldi	r24, 0xAB	; 171
     6ba:	94 e0       	ldi	r25, 0x04	; 4
     6bc:	0e 94 09 02 	call	0x412	; 0x412 <vListInitialise>
     6c0:	84 eb       	ldi	r24, 0xB4	; 180
     6c2:	94 e0       	ldi	r25, 0x04	; 4
     6c4:	0e 94 09 02 	call	0x412	; 0x412 <vListInitialise>
     6c8:	80 e9       	ldi	r24, 0x90	; 144
     6ca:	94 e0       	ldi	r25, 0x04	; 4
     6cc:	0e 94 09 02 	call	0x412	; 0x412 <vListInitialise>
     6d0:	87 e8       	ldi	r24, 0x87	; 135
     6d2:	94 e0       	ldi	r25, 0x04	; 4
     6d4:	0e 94 09 02 	call	0x412	; 0x412 <vListInitialise>
     6d8:	8a e7       	ldi	r24, 0x7A	; 122
     6da:	94 e0       	ldi	r25, 0x04	; 4
     6dc:	0e 94 09 02 	call	0x412	; 0x412 <vListInitialise>
     6e0:	80 e9       	ldi	r24, 0x90	; 144
     6e2:	94 e0       	ldi	r25, 0x04	; 4
     6e4:	90 93 86 04 	sts	0x0486, r25
     6e8:	80 93 85 04 	sts	0x0485, r24
     6ec:	87 e8       	ldi	r24, 0x87	; 135
     6ee:	94 e0       	ldi	r25, 0x04	; 4
     6f0:	90 93 84 04 	sts	0x0484, r25
     6f4:	80 93 83 04 	sts	0x0483, r24
     6f8:	0f c0       	rjmp	.+30     	; 0x718 <xTaskGenericCreate+0x182>
     6fa:	80 91 75 04 	lds	r24, 0x0475
     6fe:	81 11       	cpse	r24, r1
     700:	0b c0       	rjmp	.+22     	; 0x718 <xTaskGenericCreate+0x182>
     702:	e0 91 bd 04 	lds	r30, 0x04BD
     706:	f0 91 be 04 	lds	r31, 0x04BE
     70a:	86 89       	ldd	r24, Z+22	; 0x16
     70c:	08 17       	cp	r16, r24
     70e:	20 f0       	brcs	.+8      	; 0x718 <xTaskGenericCreate+0x182>
     710:	70 92 be 04 	sts	0x04BE, r7
     714:	60 92 bd 04 	sts	0x04BD, r6
     718:	80 91 71 04 	lds	r24, 0x0471
     71c:	8f 5f       	subi	r24, 0xFF	; 255
     71e:	80 93 71 04 	sts	0x0471, r24
     722:	f3 01       	movw	r30, r6
     724:	86 89       	ldd	r24, Z+22	; 0x16
     726:	90 91 76 04 	lds	r25, 0x0476
     72a:	98 17       	cp	r25, r24
     72c:	10 f4       	brcc	.+4      	; 0x732 <xTaskGenericCreate+0x19c>
     72e:	80 93 76 04 	sts	0x0476, r24
     732:	90 e0       	ldi	r25, 0x00	; 0
     734:	9c 01       	movw	r18, r24
     736:	22 0f       	add	r18, r18
     738:	33 1f       	adc	r19, r19
     73a:	22 0f       	add	r18, r18
     73c:	33 1f       	adc	r19, r19
     73e:	22 0f       	add	r18, r18
     740:	33 1f       	adc	r19, r19
     742:	82 0f       	add	r24, r18
     744:	93 1f       	adc	r25, r19
     746:	be 01       	movw	r22, r28
     748:	87 56       	subi	r24, 0x67	; 103
     74a:	9b 4f       	sbci	r25, 0xFB	; 251
     74c:	0e 94 1b 02 	call	0x436	; 0x436 <vListInsertEnd>
     750:	0f 90       	pop	r0
     752:	0f be       	out	0x3f, r0	; 63
     754:	80 91 75 04 	lds	r24, 0x0475
     758:	88 23       	and	r24, r24
     75a:	59 f0       	breq	.+22     	; 0x772 <xTaskGenericCreate+0x1dc>
     75c:	e0 91 bd 04 	lds	r30, 0x04BD
     760:	f0 91 be 04 	lds	r31, 0x04BE
     764:	86 89       	ldd	r24, Z+22	; 0x16
     766:	80 17       	cp	r24, r16
     768:	30 f4       	brcc	.+12     	; 0x776 <xTaskGenericCreate+0x1e0>
     76a:	0e 94 1b 01 	call	0x236	; 0x236 <vPortYield>
     76e:	81 e0       	ldi	r24, 0x01	; 1
     770:	09 c0       	rjmp	.+18     	; 0x784 <xTaskGenericCreate+0x1ee>
     772:	81 e0       	ldi	r24, 0x01	; 1
     774:	07 c0       	rjmp	.+14     	; 0x784 <xTaskGenericCreate+0x1ee>
     776:	81 e0       	ldi	r24, 0x01	; 1
     778:	05 c0       	rjmp	.+10     	; 0x784 <xTaskGenericCreate+0x1ee>
     77a:	fc 01       	movw	r30, r24
     77c:	d0 8e       	std	Z+24, r13	; 0x18
     77e:	c7 8a       	std	Z+23, r12	; 0x17
     780:	36 cf       	rjmp	.-404    	; 0x5ee <xTaskGenericCreate+0x58>
     782:	8f ef       	ldi	r24, 0xFF	; 255
     784:	df 91       	pop	r29
     786:	cf 91       	pop	r28
     788:	1f 91       	pop	r17
     78a:	0f 91       	pop	r16
     78c:	ff 90       	pop	r15
     78e:	ef 90       	pop	r14
     790:	df 90       	pop	r13
     792:	cf 90       	pop	r12
     794:	bf 90       	pop	r11
     796:	af 90       	pop	r10
     798:	9f 90       	pop	r9
     79a:	8f 90       	pop	r8
     79c:	7f 90       	pop	r7
     79e:	6f 90       	pop	r6
     7a0:	5f 90       	pop	r5
     7a2:	4f 90       	pop	r4
     7a4:	08 95       	ret

000007a6 <vTaskStartScheduler>:
     7a6:	af 92       	push	r10
     7a8:	bf 92       	push	r11
     7aa:	cf 92       	push	r12
     7ac:	df 92       	push	r13
     7ae:	ef 92       	push	r14
     7b0:	ff 92       	push	r15
     7b2:	0f 93       	push	r16
     7b4:	a1 2c       	mov	r10, r1
     7b6:	b1 2c       	mov	r11, r1
     7b8:	c1 2c       	mov	r12, r1
     7ba:	d1 2c       	mov	r13, r1
     7bc:	e1 2c       	mov	r14, r1
     7be:	f1 2c       	mov	r15, r1
     7c0:	00 e0       	ldi	r16, 0x00	; 0
     7c2:	20 e0       	ldi	r18, 0x00	; 0
     7c4:	30 e0       	ldi	r19, 0x00	; 0
     7c6:	45 e5       	ldi	r20, 0x55	; 85
     7c8:	50 e0       	ldi	r21, 0x00	; 0
     7ca:	62 e0       	ldi	r22, 0x02	; 2
     7cc:	71 e0       	ldi	r23, 0x01	; 1
     7ce:	83 e9       	ldi	r24, 0x93	; 147
     7d0:	92 e0       	ldi	r25, 0x02	; 2
     7d2:	0e 94 cb 02 	call	0x596	; 0x596 <xTaskGenericCreate>
     7d6:	81 30       	cpi	r24, 0x01	; 1
     7d8:	49 f4       	brne	.+18     	; 0x7ec <vTaskStartScheduler+0x46>
     7da:	f8 94       	cli
     7dc:	80 93 75 04 	sts	0x0475, r24
     7e0:	10 92 78 04 	sts	0x0478, r1
     7e4:	10 92 77 04 	sts	0x0477, r1
     7e8:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <xPortStartScheduler>
     7ec:	0f 91       	pop	r16
     7ee:	ff 90       	pop	r15
     7f0:	ef 90       	pop	r14
     7f2:	df 90       	pop	r13
     7f4:	cf 90       	pop	r12
     7f6:	bf 90       	pop	r11
     7f8:	af 90       	pop	r10
     7fa:	08 95       	ret

000007fc <vTaskSuspendAll>:
     7fc:	80 91 70 04 	lds	r24, 0x0470
     800:	8f 5f       	subi	r24, 0xFF	; 255
     802:	80 93 70 04 	sts	0x0470, r24
     806:	08 95       	ret

00000808 <xTaskIncrementTick>:
     808:	cf 92       	push	r12
     80a:	df 92       	push	r13
     80c:	ef 92       	push	r14
     80e:	ff 92       	push	r15
     810:	0f 93       	push	r16
     812:	1f 93       	push	r17
     814:	cf 93       	push	r28
     816:	df 93       	push	r29
     818:	80 91 70 04 	lds	r24, 0x0470
     81c:	81 11       	cpse	r24, r1
     81e:	b7 c0       	rjmp	.+366    	; 0x98e <xTaskIncrementTick+0x186>
     820:	80 91 77 04 	lds	r24, 0x0477
     824:	90 91 78 04 	lds	r25, 0x0478
     828:	01 96       	adiw	r24, 0x01	; 1
     82a:	90 93 78 04 	sts	0x0478, r25
     82e:	80 93 77 04 	sts	0x0477, r24
     832:	e0 90 77 04 	lds	r14, 0x0477
     836:	f0 90 78 04 	lds	r15, 0x0478
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	99 f5       	brne	.+102    	; 0x8a6 <xTaskIncrementTick+0x9e>
     840:	80 91 85 04 	lds	r24, 0x0485
     844:	90 91 86 04 	lds	r25, 0x0486
     848:	20 91 83 04 	lds	r18, 0x0483
     84c:	30 91 84 04 	lds	r19, 0x0484
     850:	30 93 86 04 	sts	0x0486, r19
     854:	20 93 85 04 	sts	0x0485, r18
     858:	90 93 84 04 	sts	0x0484, r25
     85c:	80 93 83 04 	sts	0x0483, r24
     860:	80 91 72 04 	lds	r24, 0x0472
     864:	8f 5f       	subi	r24, 0xFF	; 255
     866:	80 93 72 04 	sts	0x0472, r24
     86a:	e0 91 85 04 	lds	r30, 0x0485
     86e:	f0 91 86 04 	lds	r31, 0x0486
     872:	80 81       	ld	r24, Z
     874:	81 11       	cpse	r24, r1
     876:	07 c0       	rjmp	.+14     	; 0x886 <xTaskIncrementTick+0x7e>
     878:	8f ef       	ldi	r24, 0xFF	; 255
     87a:	9f ef       	ldi	r25, 0xFF	; 255
     87c:	90 93 01 01 	sts	0x0101, r25
     880:	80 93 00 01 	sts	0x0100, r24
     884:	10 c0       	rjmp	.+32     	; 0x8a6 <xTaskIncrementTick+0x9e>
     886:	e0 91 85 04 	lds	r30, 0x0485
     88a:	f0 91 86 04 	lds	r31, 0x0486
     88e:	05 80       	ldd	r0, Z+5	; 0x05
     890:	f6 81       	ldd	r31, Z+6	; 0x06
     892:	e0 2d       	mov	r30, r0
     894:	06 80       	ldd	r0, Z+6	; 0x06
     896:	f7 81       	ldd	r31, Z+7	; 0x07
     898:	e0 2d       	mov	r30, r0
     89a:	82 81       	ldd	r24, Z+2	; 0x02
     89c:	93 81       	ldd	r25, Z+3	; 0x03
     89e:	90 93 01 01 	sts	0x0101, r25
     8a2:	80 93 00 01 	sts	0x0100, r24
     8a6:	80 91 00 01 	lds	r24, 0x0100
     8aa:	90 91 01 01 	lds	r25, 0x0101
     8ae:	e8 16       	cp	r14, r24
     8b0:	f9 06       	cpc	r15, r25
     8b2:	10 f4       	brcc	.+4      	; 0x8b8 <xTaskIncrementTick+0xb0>
     8b4:	d1 2c       	mov	r13, r1
     8b6:	53 c0       	rjmp	.+166    	; 0x95e <xTaskIncrementTick+0x156>
     8b8:	d1 2c       	mov	r13, r1
     8ba:	cc 24       	eor	r12, r12
     8bc:	c3 94       	inc	r12
     8be:	e0 91 85 04 	lds	r30, 0x0485
     8c2:	f0 91 86 04 	lds	r31, 0x0486
     8c6:	90 81       	ld	r25, Z
     8c8:	91 11       	cpse	r25, r1
     8ca:	07 c0       	rjmp	.+14     	; 0x8da <xTaskIncrementTick+0xd2>
     8cc:	8f ef       	ldi	r24, 0xFF	; 255
     8ce:	9f ef       	ldi	r25, 0xFF	; 255
     8d0:	90 93 01 01 	sts	0x0101, r25
     8d4:	80 93 00 01 	sts	0x0100, r24
     8d8:	42 c0       	rjmp	.+132    	; 0x95e <xTaskIncrementTick+0x156>
     8da:	e0 91 85 04 	lds	r30, 0x0485
     8de:	f0 91 86 04 	lds	r31, 0x0486
     8e2:	05 80       	ldd	r0, Z+5	; 0x05
     8e4:	f6 81       	ldd	r31, Z+6	; 0x06
     8e6:	e0 2d       	mov	r30, r0
     8e8:	c6 81       	ldd	r28, Z+6	; 0x06
     8ea:	d7 81       	ldd	r29, Z+7	; 0x07
     8ec:	2a 81       	ldd	r18, Y+2	; 0x02
     8ee:	3b 81       	ldd	r19, Y+3	; 0x03
     8f0:	e2 16       	cp	r14, r18
     8f2:	f3 06       	cpc	r15, r19
     8f4:	28 f4       	brcc	.+10     	; 0x900 <xTaskIncrementTick+0xf8>
     8f6:	30 93 01 01 	sts	0x0101, r19
     8fa:	20 93 00 01 	sts	0x0100, r18
     8fe:	2f c0       	rjmp	.+94     	; 0x95e <xTaskIncrementTick+0x156>
     900:	8e 01       	movw	r16, r28
     902:	0e 5f       	subi	r16, 0xFE	; 254
     904:	1f 4f       	sbci	r17, 0xFF	; 255
     906:	c8 01       	movw	r24, r16
     908:	0e 94 6d 02 	call	0x4da	; 0x4da <uxListRemove>
     90c:	8c 89       	ldd	r24, Y+20	; 0x14
     90e:	9d 89       	ldd	r25, Y+21	; 0x15
     910:	89 2b       	or	r24, r25
     912:	21 f0       	breq	.+8      	; 0x91c <xTaskIncrementTick+0x114>
     914:	ce 01       	movw	r24, r28
     916:	0c 96       	adiw	r24, 0x0c	; 12
     918:	0e 94 6d 02 	call	0x4da	; 0x4da <uxListRemove>
     91c:	2e 89       	ldd	r18, Y+22	; 0x16
     91e:	80 91 76 04 	lds	r24, 0x0476
     922:	82 17       	cp	r24, r18
     924:	10 f4       	brcc	.+4      	; 0x92a <xTaskIncrementTick+0x122>
     926:	20 93 76 04 	sts	0x0476, r18
     92a:	30 e0       	ldi	r19, 0x00	; 0
     92c:	c9 01       	movw	r24, r18
     92e:	88 0f       	add	r24, r24
     930:	99 1f       	adc	r25, r25
     932:	88 0f       	add	r24, r24
     934:	99 1f       	adc	r25, r25
     936:	88 0f       	add	r24, r24
     938:	99 1f       	adc	r25, r25
     93a:	82 0f       	add	r24, r18
     93c:	93 1f       	adc	r25, r19
     93e:	b8 01       	movw	r22, r16
     940:	87 56       	subi	r24, 0x67	; 103
     942:	9b 4f       	sbci	r25, 0xFB	; 251
     944:	0e 94 1b 02 	call	0x436	; 0x436 <vListInsertEnd>
     948:	e0 91 bd 04 	lds	r30, 0x04BD
     94c:	f0 91 be 04 	lds	r31, 0x04BE
     950:	9e 89       	ldd	r25, Y+22	; 0x16
     952:	86 89       	ldd	r24, Z+22	; 0x16
     954:	98 17       	cp	r25, r24
     956:	08 f4       	brcc	.+2      	; 0x95a <xTaskIncrementTick+0x152>
     958:	b2 cf       	rjmp	.-156    	; 0x8be <xTaskIncrementTick+0xb6>
     95a:	dc 2c       	mov	r13, r12
     95c:	b0 cf       	rjmp	.-160    	; 0x8be <xTaskIncrementTick+0xb6>
     95e:	e0 91 bd 04 	lds	r30, 0x04BD
     962:	f0 91 be 04 	lds	r31, 0x04BE
     966:	86 89       	ldd	r24, Z+22	; 0x16
     968:	90 e0       	ldi	r25, 0x00	; 0
     96a:	fc 01       	movw	r30, r24
     96c:	ee 0f       	add	r30, r30
     96e:	ff 1f       	adc	r31, r31
     970:	ee 0f       	add	r30, r30
     972:	ff 1f       	adc	r31, r31
     974:	ee 0f       	add	r30, r30
     976:	ff 1f       	adc	r31, r31
     978:	8e 0f       	add	r24, r30
     97a:	9f 1f       	adc	r25, r31
     97c:	fc 01       	movw	r30, r24
     97e:	e7 56       	subi	r30, 0x67	; 103
     980:	fb 4f       	sbci	r31, 0xFB	; 251
     982:	80 81       	ld	r24, Z
     984:	82 30       	cpi	r24, 0x02	; 2
     986:	48 f0       	brcs	.+18     	; 0x99a <xTaskIncrementTick+0x192>
     988:	dd 24       	eor	r13, r13
     98a:	d3 94       	inc	r13
     98c:	06 c0       	rjmp	.+12     	; 0x99a <xTaskIncrementTick+0x192>
     98e:	80 91 74 04 	lds	r24, 0x0474
     992:	8f 5f       	subi	r24, 0xFF	; 255
     994:	80 93 74 04 	sts	0x0474, r24
     998:	d1 2c       	mov	r13, r1
     99a:	80 91 73 04 	lds	r24, 0x0473
     99e:	88 23       	and	r24, r24
     9a0:	11 f0       	breq	.+4      	; 0x9a6 <xTaskIncrementTick+0x19e>
     9a2:	dd 24       	eor	r13, r13
     9a4:	d3 94       	inc	r13
     9a6:	8d 2d       	mov	r24, r13
     9a8:	df 91       	pop	r29
     9aa:	cf 91       	pop	r28
     9ac:	1f 91       	pop	r17
     9ae:	0f 91       	pop	r16
     9b0:	ff 90       	pop	r15
     9b2:	ef 90       	pop	r14
     9b4:	df 90       	pop	r13
     9b6:	cf 90       	pop	r12
     9b8:	08 95       	ret

000009ba <xTaskResumeAll>:
     9ba:	df 92       	push	r13
     9bc:	ef 92       	push	r14
     9be:	ff 92       	push	r15
     9c0:	0f 93       	push	r16
     9c2:	1f 93       	push	r17
     9c4:	cf 93       	push	r28
     9c6:	df 93       	push	r29
     9c8:	0f b6       	in	r0, 0x3f	; 63
     9ca:	f8 94       	cli
     9cc:	0f 92       	push	r0
     9ce:	80 91 70 04 	lds	r24, 0x0470
     9d2:	81 50       	subi	r24, 0x01	; 1
     9d4:	80 93 70 04 	sts	0x0470, r24
     9d8:	80 91 70 04 	lds	r24, 0x0470
     9dc:	81 11       	cpse	r24, r1
     9de:	62 c0       	rjmp	.+196    	; 0xaa4 <xTaskResumeAll+0xea>
     9e0:	80 91 79 04 	lds	r24, 0x0479
     9e4:	81 11       	cpse	r24, r1
     9e6:	33 c0       	rjmp	.+102    	; 0xa4e <xTaskResumeAll+0x94>
     9e8:	60 c0       	rjmp	.+192    	; 0xaaa <xTaskResumeAll+0xf0>
     9ea:	d7 01       	movw	r26, r14
     9ec:	15 96       	adiw	r26, 0x05	; 5
     9ee:	ed 91       	ld	r30, X+
     9f0:	fc 91       	ld	r31, X
     9f2:	16 97       	sbiw	r26, 0x06	; 6
     9f4:	c6 81       	ldd	r28, Z+6	; 0x06
     9f6:	d7 81       	ldd	r29, Z+7	; 0x07
     9f8:	ce 01       	movw	r24, r28
     9fa:	0c 96       	adiw	r24, 0x0c	; 12
     9fc:	0e 94 6d 02 	call	0x4da	; 0x4da <uxListRemove>
     a00:	8e 01       	movw	r16, r28
     a02:	0e 5f       	subi	r16, 0xFE	; 254
     a04:	1f 4f       	sbci	r17, 0xFF	; 255
     a06:	c8 01       	movw	r24, r16
     a08:	0e 94 6d 02 	call	0x4da	; 0x4da <uxListRemove>
     a0c:	2e 89       	ldd	r18, Y+22	; 0x16
     a0e:	80 91 76 04 	lds	r24, 0x0476
     a12:	82 17       	cp	r24, r18
     a14:	10 f4       	brcc	.+4      	; 0xa1a <xTaskResumeAll+0x60>
     a16:	20 93 76 04 	sts	0x0476, r18
     a1a:	30 e0       	ldi	r19, 0x00	; 0
     a1c:	c9 01       	movw	r24, r18
     a1e:	88 0f       	add	r24, r24
     a20:	99 1f       	adc	r25, r25
     a22:	88 0f       	add	r24, r24
     a24:	99 1f       	adc	r25, r25
     a26:	88 0f       	add	r24, r24
     a28:	99 1f       	adc	r25, r25
     a2a:	82 0f       	add	r24, r18
     a2c:	93 1f       	adc	r25, r19
     a2e:	b8 01       	movw	r22, r16
     a30:	87 56       	subi	r24, 0x67	; 103
     a32:	9b 4f       	sbci	r25, 0xFB	; 251
     a34:	0e 94 1b 02 	call	0x436	; 0x436 <vListInsertEnd>
     a38:	e0 91 bd 04 	lds	r30, 0x04BD
     a3c:	f0 91 be 04 	lds	r31, 0x04BE
     a40:	9e 89       	ldd	r25, Y+22	; 0x16
     a42:	86 89       	ldd	r24, Z+22	; 0x16
     a44:	98 17       	cp	r25, r24
     a46:	58 f0       	brcs	.+22     	; 0xa5e <xTaskResumeAll+0xa4>
     a48:	d0 92 73 04 	sts	0x0473, r13
     a4c:	08 c0       	rjmp	.+16     	; 0xa5e <xTaskResumeAll+0xa4>
     a4e:	0f 2e       	mov	r0, r31
     a50:	fa e7       	ldi	r31, 0x7A	; 122
     a52:	ef 2e       	mov	r14, r31
     a54:	f4 e0       	ldi	r31, 0x04	; 4
     a56:	ff 2e       	mov	r15, r31
     a58:	f0 2d       	mov	r31, r0
     a5a:	dd 24       	eor	r13, r13
     a5c:	d3 94       	inc	r13
     a5e:	f7 01       	movw	r30, r14
     a60:	80 81       	ld	r24, Z
     a62:	81 11       	cpse	r24, r1
     a64:	c2 cf       	rjmp	.-124    	; 0x9ea <xTaskResumeAll+0x30>
     a66:	80 91 74 04 	lds	r24, 0x0474
     a6a:	88 23       	and	r24, r24
     a6c:	99 f0       	breq	.+38     	; 0xa94 <xTaskResumeAll+0xda>
     a6e:	80 91 74 04 	lds	r24, 0x0474
     a72:	88 23       	and	r24, r24
     a74:	79 f0       	breq	.+30     	; 0xa94 <xTaskResumeAll+0xda>
     a76:	c1 e0       	ldi	r28, 0x01	; 1
     a78:	0e 94 04 04 	call	0x808	; 0x808 <xTaskIncrementTick>
     a7c:	81 11       	cpse	r24, r1
     a7e:	c0 93 73 04 	sts	0x0473, r28
     a82:	80 91 74 04 	lds	r24, 0x0474
     a86:	81 50       	subi	r24, 0x01	; 1
     a88:	80 93 74 04 	sts	0x0474, r24
     a8c:	80 91 74 04 	lds	r24, 0x0474
     a90:	81 11       	cpse	r24, r1
     a92:	f2 cf       	rjmp	.-28     	; 0xa78 <xTaskResumeAll+0xbe>
     a94:	80 91 73 04 	lds	r24, 0x0473
     a98:	81 30       	cpi	r24, 0x01	; 1
     a9a:	31 f4       	brne	.+12     	; 0xaa8 <xTaskResumeAll+0xee>
     a9c:	0e 94 1b 01 	call	0x236	; 0x236 <vPortYield>
     aa0:	81 e0       	ldi	r24, 0x01	; 1
     aa2:	03 c0       	rjmp	.+6      	; 0xaaa <xTaskResumeAll+0xf0>
     aa4:	80 e0       	ldi	r24, 0x00	; 0
     aa6:	01 c0       	rjmp	.+2      	; 0xaaa <xTaskResumeAll+0xf0>
     aa8:	80 e0       	ldi	r24, 0x00	; 0
     aaa:	0f 90       	pop	r0
     aac:	0f be       	out	0x3f, r0	; 63
     aae:	df 91       	pop	r29
     ab0:	cf 91       	pop	r28
     ab2:	1f 91       	pop	r17
     ab4:	0f 91       	pop	r16
     ab6:	ff 90       	pop	r15
     ab8:	ef 90       	pop	r14
     aba:	df 90       	pop	r13
     abc:	08 95       	ret

00000abe <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     abe:	cf 93       	push	r28
     ac0:	df 93       	push	r29
     ac2:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     ac4:	89 2b       	or	r24, r25
     ac6:	b1 f0       	breq	.+44     	; 0xaf4 <vTaskDelay+0x36>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     ac8:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     acc:	80 91 77 04 	lds	r24, 0x0477
     ad0:	90 91 78 04 	lds	r25, 0x0478
     ad4:	c8 0f       	add	r28, r24
     ad6:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     ad8:	80 91 bd 04 	lds	r24, 0x04BD
     adc:	90 91 be 04 	lds	r25, 0x04BE
     ae0:	02 96       	adiw	r24, 0x02	; 2
     ae2:	0e 94 6d 02 	call	0x4da	; 0x4da <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     ae6:	ce 01       	movw	r24, r28
     ae8:	0e 94 94 02 	call	0x528	; 0x528 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     aec:	0e 94 dd 04 	call	0x9ba	; 0x9ba <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     af0:	81 11       	cpse	r24, r1
     af2:	02 c0       	rjmp	.+4      	; 0xaf8 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
     af4:	0e 94 1b 01 	call	0x236	; 0x236 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     af8:	df 91       	pop	r29
     afa:	cf 91       	pop	r28
     afc:	08 95       	ret

00000afe <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     afe:	80 91 70 04 	lds	r24, 0x0470
     b02:	88 23       	and	r24, r24
     b04:	21 f0       	breq	.+8      	; 0xb0e <__stack+0xf>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     b06:	81 e0       	ldi	r24, 0x01	; 1
     b08:	80 93 73 04 	sts	0x0473, r24
     b0c:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     b0e:	10 92 73 04 	sts	0x0473, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     b12:	80 91 76 04 	lds	r24, 0x0476
     b16:	90 e0       	ldi	r25, 0x00	; 0
     b18:	fc 01       	movw	r30, r24
     b1a:	ee 0f       	add	r30, r30
     b1c:	ff 1f       	adc	r31, r31
     b1e:	ee 0f       	add	r30, r30
     b20:	ff 1f       	adc	r31, r31
     b22:	ee 0f       	add	r30, r30
     b24:	ff 1f       	adc	r31, r31
     b26:	8e 0f       	add	r24, r30
     b28:	9f 1f       	adc	r25, r31
     b2a:	fc 01       	movw	r30, r24
     b2c:	e7 56       	subi	r30, 0x67	; 103
     b2e:	fb 4f       	sbci	r31, 0xFB	; 251
     b30:	80 81       	ld	r24, Z
     b32:	81 11       	cpse	r24, r1
     b34:	17 c0       	rjmp	.+46     	; 0xb64 <__stack+0x65>
     b36:	80 91 76 04 	lds	r24, 0x0476
     b3a:	81 50       	subi	r24, 0x01	; 1
     b3c:	80 93 76 04 	sts	0x0476, r24
     b40:	80 91 76 04 	lds	r24, 0x0476
     b44:	90 e0       	ldi	r25, 0x00	; 0
     b46:	fc 01       	movw	r30, r24
     b48:	ee 0f       	add	r30, r30
     b4a:	ff 1f       	adc	r31, r31
     b4c:	ee 0f       	add	r30, r30
     b4e:	ff 1f       	adc	r31, r31
     b50:	ee 0f       	add	r30, r30
     b52:	ff 1f       	adc	r31, r31
     b54:	8e 0f       	add	r24, r30
     b56:	9f 1f       	adc	r25, r31
     b58:	fc 01       	movw	r30, r24
     b5a:	e7 56       	subi	r30, 0x67	; 103
     b5c:	fb 4f       	sbci	r31, 0xFB	; 251
     b5e:	80 81       	ld	r24, Z
     b60:	88 23       	and	r24, r24
     b62:	49 f3       	breq	.-46     	; 0xb36 <__stack+0x37>
     b64:	80 91 76 04 	lds	r24, 0x0476
     b68:	90 e0       	ldi	r25, 0x00	; 0
     b6a:	9c 01       	movw	r18, r24
     b6c:	22 0f       	add	r18, r18
     b6e:	33 1f       	adc	r19, r19
     b70:	22 0f       	add	r18, r18
     b72:	33 1f       	adc	r19, r19
     b74:	22 0f       	add	r18, r18
     b76:	33 1f       	adc	r19, r19
     b78:	28 0f       	add	r18, r24
     b7a:	39 1f       	adc	r19, r25
     b7c:	d9 01       	movw	r26, r18
     b7e:	a7 56       	subi	r26, 0x67	; 103
     b80:	bb 4f       	sbci	r27, 0xFB	; 251
     b82:	11 96       	adiw	r26, 0x01	; 1
     b84:	ed 91       	ld	r30, X+
     b86:	fc 91       	ld	r31, X
     b88:	12 97       	sbiw	r26, 0x02	; 2
     b8a:	02 80       	ldd	r0, Z+2	; 0x02
     b8c:	f3 81       	ldd	r31, Z+3	; 0x03
     b8e:	e0 2d       	mov	r30, r0
     b90:	12 96       	adiw	r26, 0x02	; 2
     b92:	fc 93       	st	X, r31
     b94:	ee 93       	st	-X, r30
     b96:	11 97       	sbiw	r26, 0x01	; 1
     b98:	24 56       	subi	r18, 0x64	; 100
     b9a:	3b 4f       	sbci	r19, 0xFB	; 251
     b9c:	e2 17       	cp	r30, r18
     b9e:	f3 07       	cpc	r31, r19
     ba0:	29 f4       	brne	.+10     	; 0xbac <__stack+0xad>
     ba2:	22 81       	ldd	r18, Z+2	; 0x02
     ba4:	33 81       	ldd	r19, Z+3	; 0x03
     ba6:	fd 01       	movw	r30, r26
     ba8:	32 83       	std	Z+2, r19	; 0x02
     baa:	21 83       	std	Z+1, r18	; 0x01
     bac:	fc 01       	movw	r30, r24
     bae:	ee 0f       	add	r30, r30
     bb0:	ff 1f       	adc	r31, r31
     bb2:	ee 0f       	add	r30, r30
     bb4:	ff 1f       	adc	r31, r31
     bb6:	ee 0f       	add	r30, r30
     bb8:	ff 1f       	adc	r31, r31
     bba:	8e 0f       	add	r24, r30
     bbc:	9f 1f       	adc	r25, r31
     bbe:	fc 01       	movw	r30, r24
     bc0:	e7 56       	subi	r30, 0x67	; 103
     bc2:	fb 4f       	sbci	r31, 0xFB	; 251
     bc4:	01 80       	ldd	r0, Z+1	; 0x01
     bc6:	f2 81       	ldd	r31, Z+2	; 0x02
     bc8:	e0 2d       	mov	r30, r0
     bca:	86 81       	ldd	r24, Z+6	; 0x06
     bcc:	97 81       	ldd	r25, Z+7	; 0x07
     bce:	90 93 be 04 	sts	0x04BE, r25
     bd2:	80 93 bd 04 	sts	0x04BD, r24
     bd6:	08 95       	ret

00000bd8 <Endpoint_ConfigureEndpoint_Prv>:
}

bool Endpoint_ConfigureEndpoint_Prv(const uint8_t Number,
                                    const uint8_t UECFG0XData,
                                    const uint8_t UECFG1XData)
{
     bd8:	8f 92       	push	r8
     bda:	9f 92       	push	r9
     bdc:	bf 92       	push	r11
     bde:	cf 92       	push	r12
     be0:	df 92       	push	r13
     be2:	ef 92       	push	r14
     be4:	ff 92       	push	r15
     be6:	0f 93       	push	r16
     be8:	1f 93       	push	r17
     bea:	cf 93       	push	r28
     bec:	df 93       	push	r29
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
     bee:	87 30       	cpi	r24, 0x07	; 7
     bf0:	70 f1       	brcs	.+92     	; 0xc4e <Endpoint_ConfigureEndpoint_Prv+0x76>
     bf2:	26 c0       	rjmp	.+76     	; 0xc40 <Endpoint_ConfigureEndpoint_Prv+0x68>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
     bf4:	29 2f       	mov	r18, r25
     bf6:	2f 70       	andi	r18, 0x0F	; 15
     bf8:	e7 01       	movw	r28, r14
     bfa:	28 83       	st	Y, r18
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
     bfc:	89 17       	cp	r24, r25
     bfe:	31 f0       	breq	.+12     	; 0xc0c <Endpoint_ConfigureEndpoint_Prv+0x34>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
     c00:	e8 01       	movw	r28, r16
     c02:	78 81       	ld	r23, Y
			UECFG1XTemp = UECFG1X;
     c04:	20 81       	ld	r18, Z
			UEIENXTemp  = UEIENX;
     c06:	e4 01       	movw	r28, r8
     c08:	58 81       	ld	r21, Y
     c0a:	03 c0       	rjmp	.+6      	; 0xc12 <Endpoint_ConfigureEndpoint_Prv+0x3a>
		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
     c0c:	24 2f       	mov	r18, r20

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
     c0e:	76 2f       	mov	r23, r22
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
     c10:	5b 2d       	mov	r21, r11
			UECFG0XTemp = UECFG0X;
			UECFG1XTemp = UECFG1X;
			UEIENXTemp  = UEIENX;
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
     c12:	21 ff       	sbrs	r18, 1
     c14:	12 c0       	rjmp	.+36     	; 0xc3a <Endpoint_ConfigureEndpoint_Prv+0x62>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
     c16:	3c 91       	ld	r19, X
     c18:	3e 7f       	andi	r19, 0xFE	; 254
     c1a:	3c 93       	st	X, r19
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
     c1c:	30 81       	ld	r19, Z
     c1e:	3d 7f       	andi	r19, 0xFD	; 253
     c20:	30 83       	st	Z, r19
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
     c22:	3c 91       	ld	r19, X
     c24:	31 60       	ori	r19, 0x01	; 1
     c26:	3c 93       	st	X, r19

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
     c28:	e8 01       	movw	r28, r16
     c2a:	78 83       	st	Y, r23
		UECFG1X = UECFG1XTemp;
     c2c:	20 83       	st	Z, r18
		UEIENX  = UEIENXTemp;
     c2e:	e4 01       	movw	r28, r8
     c30:	58 83       	st	Y, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
     c32:	e6 01       	movw	r28, r12
     c34:	28 81       	ld	r18, Y

		if (!(Endpoint_IsConfigured()))
     c36:	22 23       	and	r18, r18
     c38:	44 f4       	brge	.+16     	; 0xc4a <Endpoint_ConfigureEndpoint_Prv+0x72>
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
     c3a:	9f 5f       	subi	r25, 0xFF	; 255
     c3c:	97 30       	cpi	r25, 0x07	; 7
     c3e:	d1 f6       	brne	.-76     	; 0xbf4 <Endpoint_ConfigureEndpoint_Prv+0x1c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
     c40:	8f 70       	andi	r24, 0x0F	; 15
     c42:	80 93 e9 00 	sts	0x00E9, r24
		if (!(Endpoint_IsConfigured()))
		  return false;
	}

	Endpoint_SelectEndpoint(Number);
	return true;
     c46:	81 e0       	ldi	r24, 0x01	; 1
     c48:	21 c0       	rjmp	.+66     	; 0xc8c <Endpoint_ConfigureEndpoint_Prv+0xb4>
		UECFG0X = UECFG0XTemp;
		UECFG1X = UECFG1XTemp;
		UEIENX  = UEIENXTemp;

		if (!(Endpoint_IsConfigured()))
		  return false;
     c4a:	80 e0       	ldi	r24, 0x00	; 0
     c4c:	1f c0       	rjmp	.+62     	; 0xc8c <Endpoint_ConfigureEndpoint_Prv+0xb4>
     c4e:	98 2f       	mov	r25, r24
     c50:	9f 70       	andi	r25, 0x0F	; 15
     c52:	90 93 e9 00 	sts	0x00E9, r25
     c56:	98 2f       	mov	r25, r24
		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
     c58:	24 2f       	mov	r18, r20

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
     c5a:	76 2f       	mov	r23, r22
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
     c5c:	50 e0       	ldi	r21, 0x00	; 0
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
     c5e:	ab ee       	ldi	r26, 0xEB	; 235
     c60:	b0 e0       	ldi	r27, 0x00	; 0

		if (!(UECFG1XTemp & (1 << ALLOC)))
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
     c62:	ed ee       	ldi	r30, 0xED	; 237
     c64:	f0 e0       	ldi	r31, 0x00	; 0

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
     c66:	0c ee       	ldi	r16, 0xEC	; 236
     c68:	10 e0       	ldi	r17, 0x00	; 0
		UECFG1X = UECFG1XTemp;
		UEIENX  = UEIENXTemp;
     c6a:	0f 2e       	mov	r0, r31
     c6c:	f0 ef       	ldi	r31, 0xF0	; 240
     c6e:	8f 2e       	mov	r8, r31
     c70:	91 2c       	mov	r9, r1
     c72:	f0 2d       	mov	r31, r0
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
     c74:	0f 2e       	mov	r0, r31
     c76:	fe ee       	ldi	r31, 0xEE	; 238
     c78:	cf 2e       	mov	r12, r31
     c7a:	d1 2c       	mov	r13, r1
     c7c:	f0 2d       	mov	r31, r0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
     c7e:	0f 2e       	mov	r0, r31
     c80:	f9 ee       	ldi	r31, 0xE9	; 233
     c82:	ef 2e       	mov	r14, r31
     c84:	f1 2c       	mov	r15, r1
     c86:	f0 2d       	mov	r31, r0

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
     c88:	b1 2c       	mov	r11, r1
     c8a:	c3 cf       	rjmp	.-122    	; 0xc12 <Endpoint_ConfigureEndpoint_Prv+0x3a>
	}

	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
     c8c:	df 91       	pop	r29
     c8e:	cf 91       	pop	r28
     c90:	1f 91       	pop	r17
     c92:	0f 91       	pop	r16
     c94:	ff 90       	pop	r15
     c96:	ef 90       	pop	r14
     c98:	df 90       	pop	r13
     c9a:	cf 90       	pop	r12
     c9c:	bf 90       	pop	r11
     c9e:	9f 90       	pop	r9
     ca0:	8f 90       	pop	r8
     ca2:	08 95       	ret

00000ca4 <__vector_10>:
	UDINT  = 0;
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
     ca4:	1f 92       	push	r1
     ca6:	0f 92       	push	r0
     ca8:	0f b6       	in	r0, 0x3f	; 63
     caa:	0f 92       	push	r0
     cac:	11 24       	eor	r1, r1
     cae:	2f 93       	push	r18
     cb0:	3f 93       	push	r19
     cb2:	4f 93       	push	r20
     cb4:	5f 93       	push	r21
     cb6:	6f 93       	push	r22
     cb8:	7f 93       	push	r23
     cba:	8f 93       	push	r24
     cbc:	9f 93       	push	r25
     cbe:	af 93       	push	r26
     cc0:	bf 93       	push	r27
     cc2:	ef 93       	push	r30
     cc4:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
     cc6:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
     cca:	82 ff       	sbrs	r24, 2
     ccc:	0b c0       	rjmp	.+22     	; 0xce4 <__vector_10+0x40>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
     cce:	80 91 e2 00 	lds	r24, 0x00E2
     cd2:	82 ff       	sbrs	r24, 2
     cd4:	07 c0       	rjmp	.+14     	; 0xce4 <__vector_10+0x40>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
     cd6:	e1 ee       	ldi	r30, 0xE1	; 225
     cd8:	f0 e0       	ldi	r31, 0x00	; 0
     cda:	80 81       	ld	r24, Z
     cdc:	8b 7f       	andi	r24, 0xFB	; 251
     cde:	80 83       	st	Z, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
     ce0:	0e 94 19 07 	call	0xe32	; 0xe32 <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
     ce4:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
     ce8:	80 ff       	sbrs	r24, 0
     cea:	1f c0       	rjmp	.+62     	; 0xd2a <__vector_10+0x86>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
     cec:	80 91 d8 00 	lds	r24, 0x00D8
     cf0:	80 ff       	sbrs	r24, 0
     cf2:	1b c0       	rjmp	.+54     	; 0xd2a <__vector_10+0x86>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
     cf4:	ea ed       	ldi	r30, 0xDA	; 218
     cf6:	f0 e0       	ldi	r31, 0x00	; 0
     cf8:	80 81       	ld	r24, Z
     cfa:	8e 7f       	andi	r24, 0xFE	; 254
     cfc:	80 83       	st	Z, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
     cfe:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
     d02:	80 ff       	sbrs	r24, 0
     d04:	0d c0       	rjmp	.+26     	; 0xd20 <__vector_10+0x7c>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
     d06:	80 e1       	ldi	r24, 0x10	; 16
     d08:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
     d0a:	82 e1       	ldi	r24, 0x12	; 18
     d0c:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
     d0e:	09 b4       	in	r0, 0x29	; 41
     d10:	00 fe       	sbrs	r0, 0
     d12:	fd cf       	rjmp	.-6      	; 0xd0e <__vector_10+0x6a>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
     d14:	81 e0       	ldi	r24, 0x01	; 1
     d16:	80 93 c7 04 	sts	0x04C7, r24
			EVENT_USB_Device_Connect();
     d1a:	0e 94 19 07 	call	0xe32	; 0xe32 <USB_Event_Stub>
     d1e:	05 c0       	rjmp	.+10     	; 0xd2a <__vector_10+0x86>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
     d20:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
     d22:	10 92 c7 04 	sts	0x04C7, r1
			EVENT_USB_Device_Disconnect();
     d26:	0e 94 19 07 	call	0xe32	; 0xe32 <USB_Event_Stub>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
     d2a:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
     d2e:	80 ff       	sbrs	r24, 0
     d30:	17 c0       	rjmp	.+46     	; 0xd60 <__vector_10+0xbc>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
     d32:	80 91 e2 00 	lds	r24, 0x00E2
     d36:	80 ff       	sbrs	r24, 0
     d38:	13 c0       	rjmp	.+38     	; 0xd60 <__vector_10+0xbc>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
     d3a:	e2 ee       	ldi	r30, 0xE2	; 226
     d3c:	f0 e0       	ldi	r31, 0x00	; 0
     d3e:	80 81       	ld	r24, Z
     d40:	8e 7f       	andi	r24, 0xFE	; 254
     d42:	80 83       	st	Z, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
     d44:	80 81       	ld	r24, Z
     d46:	80 61       	ori	r24, 0x10	; 16
     d48:	80 83       	st	Z, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
     d4a:	e8 ed       	ldi	r30, 0xD8	; 216
     d4c:	f0 e0       	ldi	r31, 0x00	; 0
     d4e:	80 81       	ld	r24, Z
     d50:	80 62       	ori	r24, 0x20	; 32
     d52:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
     d54:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
     d56:	85 e0       	ldi	r24, 0x05	; 5
     d58:	80 93 c7 04 	sts	0x04C7, r24
		EVENT_USB_Device_Suspend();
     d5c:	0e 94 19 07 	call	0xe32	; 0xe32 <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
     d60:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
     d64:	84 ff       	sbrs	r24, 4
     d66:	30 c0       	rjmp	.+96     	; 0xdc8 <__vector_10+0x124>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
     d68:	80 91 e2 00 	lds	r24, 0x00E2
     d6c:	84 ff       	sbrs	r24, 4
     d6e:	2c c0       	rjmp	.+88     	; 0xdc8 <__vector_10+0x124>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
     d70:	80 e1       	ldi	r24, 0x10	; 16
     d72:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
     d74:	82 e1       	ldi	r24, 0x12	; 18
     d76:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
     d78:	09 b4       	in	r0, 0x29	; 41
     d7a:	00 fe       	sbrs	r0, 0
     d7c:	fd cf       	rjmp	.-6      	; 0xd78 <__vector_10+0xd4>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
     d7e:	e8 ed       	ldi	r30, 0xD8	; 216
     d80:	f0 e0       	ldi	r31, 0x00	; 0
     d82:	80 81       	ld	r24, Z
     d84:	8f 7d       	andi	r24, 0xDF	; 223
     d86:	80 83       	st	Z, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
     d88:	e1 ee       	ldi	r30, 0xE1	; 225
     d8a:	f0 e0       	ldi	r31, 0x00	; 0
     d8c:	80 81       	ld	r24, Z
     d8e:	8f 7e       	andi	r24, 0xEF	; 239
     d90:	80 83       	st	Z, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
     d92:	e2 ee       	ldi	r30, 0xE2	; 226
     d94:	f0 e0       	ldi	r31, 0x00	; 0
     d96:	80 81       	ld	r24, Z
     d98:	8f 7e       	andi	r24, 0xEF	; 239
     d9a:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
     d9c:	80 81       	ld	r24, Z
     d9e:	81 60       	ori	r24, 0x01	; 1
     da0:	80 83       	st	Z, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
     da2:	80 91 c3 04 	lds	r24, 0x04C3
     da6:	88 23       	and	r24, r24
     da8:	21 f0       	breq	.+8      	; 0xdb2 <__vector_10+0x10e>
		  USB_DeviceState = DEVICE_STATE_Configured;
     daa:	84 e0       	ldi	r24, 0x04	; 4
     dac:	80 93 c7 04 	sts	0x04C7, r24
     db0:	09 c0       	rjmp	.+18     	; 0xdc4 <__vector_10+0x120>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
     db2:	80 91 e3 00 	lds	r24, 0x00E3
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
     db6:	88 23       	and	r24, r24
     db8:	14 f0       	brlt	.+4      	; 0xdbe <__vector_10+0x11a>
     dba:	81 e0       	ldi	r24, 0x01	; 1
     dbc:	01 c0       	rjmp	.+2      	; 0xdc0 <__vector_10+0x11c>
     dbe:	83 e0       	ldi	r24, 0x03	; 3
     dc0:	80 93 c7 04 	sts	0x04C7, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
     dc4:	0e 94 19 07 	call	0xe32	; 0xe32 <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
     dc8:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
     dcc:	83 ff       	sbrs	r24, 3
     dce:	20 c0       	rjmp	.+64     	; 0xe10 <__vector_10+0x16c>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
     dd0:	80 91 e2 00 	lds	r24, 0x00E2
     dd4:	83 ff       	sbrs	r24, 3
     dd6:	1c c0       	rjmp	.+56     	; 0xe10 <__vector_10+0x16c>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
     dd8:	e1 ee       	ldi	r30, 0xE1	; 225
     dda:	f0 e0       	ldi	r31, 0x00	; 0
     ddc:	80 81       	ld	r24, Z
     dde:	87 7f       	andi	r24, 0xF7	; 247
     de0:	80 83       	st	Z, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
     de2:	82 e0       	ldi	r24, 0x02	; 2
     de4:	80 93 c7 04 	sts	0x04C7, r24
		USB_Device_ConfigurationNumber = 0;
     de8:	10 92 c3 04 	sts	0x04C3, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
     dec:	80 81       	ld	r24, Z
     dee:	8e 7f       	andi	r24, 0xFE	; 254
     df0:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
     df2:	e2 ee       	ldi	r30, 0xE2	; 226
     df4:	f0 e0       	ldi	r31, 0x00	; 0
     df6:	80 81       	ld	r24, Z
     df8:	8e 7f       	andi	r24, 0xFE	; 254
     dfa:	80 83       	st	Z, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
     dfc:	80 81       	ld	r24, Z
     dfe:	80 61       	ori	r24, 0x10	; 16
     e00:	80 83       	st	Z, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
     e02:	42 e0       	ldi	r20, 0x02	; 2
     e04:	60 e0       	ldi	r22, 0x00	; 0
     e06:	80 e0       	ldi	r24, 0x00	; 0
     e08:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
     e0c:	0e 94 19 07 	call	0xe32	; 0xe32 <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
     e10:	ff 91       	pop	r31
     e12:	ef 91       	pop	r30
     e14:	bf 91       	pop	r27
     e16:	af 91       	pop	r26
     e18:	9f 91       	pop	r25
     e1a:	8f 91       	pop	r24
     e1c:	7f 91       	pop	r23
     e1e:	6f 91       	pop	r22
     e20:	5f 91       	pop	r21
     e22:	4f 91       	pop	r20
     e24:	3f 91       	pop	r19
     e26:	2f 91       	pop	r18
     e28:	0f 90       	pop	r0
     e2a:	0f be       	out	0x3f, r0	; 63
     e2c:	0f 90       	pop	r0
     e2e:	1f 90       	pop	r1
     e30:	18 95       	reti

00000e32 <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
     e32:	08 95       	ret

00000e34 <relay_control>:
			vTaskDelay(2000);
			
			relay_control(0,0);
			vTaskDelay(2000);
			relay_control(0,1);
			vTaskDelay(2000);
     e34:	81 30       	cpi	r24, 0x01	; 1
     e36:	91 05       	cpc	r25, r1
     e38:	89 f0       	breq	.+34     	; 0xe5c <relay_control+0x28>
     e3a:	1c f4       	brge	.+6      	; 0xe42 <relay_control+0xe>
     e3c:	89 2b       	or	r24, r25
     e3e:	39 f0       	breq	.+14     	; 0xe4e <relay_control+0x1a>
     e40:	08 95       	ret
     e42:	82 30       	cpi	r24, 0x02	; 2
     e44:	91 05       	cpc	r25, r1
     e46:	99 f0       	breq	.+38     	; 0xe6e <relay_control+0x3a>
     e48:	03 97       	sbiw	r24, 0x03	; 3
     e4a:	e1 f0       	breq	.+56     	; 0xe84 <relay_control+0x50>
     e4c:	08 95       	ret
     e4e:	58 98       	cbi	0x0b, 0	; 11
     e50:	8b b1       	in	r24, 0x0b	; 11
     e52:	86 2b       	or	r24, r22
     e54:	8b b9       	out	0x0b, r24	; 11
     e56:	60 93 c2 04 	sts	0x04C2, r22
     e5a:	08 95       	ret
     e5c:	59 98       	cbi	0x0b, 1	; 11
     e5e:	8b b1       	in	r24, 0x0b	; 11
     e60:	96 2f       	mov	r25, r22
     e62:	99 0f       	add	r25, r25
     e64:	89 2b       	or	r24, r25
     e66:	8b b9       	out	0x0b, r24	; 11
     e68:	60 93 c1 04 	sts	0x04C1, r22
     e6c:	08 95       	ret
     e6e:	5c 98       	cbi	0x0b, 4	; 11
     e70:	2b b1       	in	r18, 0x0b	; 11
     e72:	30 e1       	ldi	r19, 0x10	; 16
     e74:	63 9f       	mul	r22, r19
     e76:	c0 01       	movw	r24, r0
     e78:	11 24       	eor	r1, r1
     e7a:	82 2b       	or	r24, r18
     e7c:	8b b9       	out	0x0b, r24	; 11
     e7e:	60 93 c0 04 	sts	0x04C0, r22
     e82:	08 95       	ret
     e84:	46 98       	cbi	0x08, 6	; 8
     e86:	28 b1       	in	r18, 0x08	; 8
     e88:	30 e4       	ldi	r19, 0x40	; 64
     e8a:	63 9f       	mul	r22, r19
     e8c:	c0 01       	movw	r24, r0
     e8e:	11 24       	eor	r1, r1
     e90:	82 2b       	or	r24, r18
     e92:	88 b9       	out	0x08, r24	; 8
     e94:	60 93 bf 04 	sts	0x04BF, r22
     e98:	08 95       	ret

00000e9a <command_handler>:
}




char *command_handler(char **args,int arg_count){
     e9a:	0f 93       	push	r16
     e9c:	1f 93       	push	r17
     e9e:	cf 93       	push	r28
     ea0:	df 93       	push	r29
     ea2:	ec 01       	movw	r28, r24

	if(!strcmp(args[0], "light") ) {
     ea4:	08 81       	ld	r16, Y
     ea6:	19 81       	ldd	r17, Y+1	; 0x01
     ea8:	67 e0       	ldi	r22, 0x07	; 7
     eaa:	71 e0       	ldi	r23, 0x01	; 1
     eac:	c8 01       	movw	r24, r16
     eae:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <strcmp>
     eb2:	89 2b       	or	r24, r25
     eb4:	09 f0       	breq	.+2      	; 0xeb8 <command_handler+0x1e>
     eb6:	4c c0       	rjmp	.+152    	; 0xf50 <command_handler+0xb6>
		if(!strcmp(args[1], "0")) {
     eb8:	0a 81       	ldd	r16, Y+2	; 0x02
     eba:	1b 81       	ldd	r17, Y+3	; 0x03
     ebc:	6d e0       	ldi	r22, 0x0D	; 13
     ebe:	71 e0       	ldi	r23, 0x01	; 1
     ec0:	c8 01       	movw	r24, r16
     ec2:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <strcmp>
     ec6:	89 2b       	or	r24, r25
     ec8:	f1 f4       	brne	.+60     	; 0xf06 <command_handler+0x6c>
			if(!strcmp(args[2], "0")) {
     eca:	0c 80       	ldd	r0, Y+4	; 0x04
     ecc:	dd 81       	ldd	r29, Y+5	; 0x05
     ece:	c0 2d       	mov	r28, r0
     ed0:	6d e0       	ldi	r22, 0x0D	; 13
     ed2:	71 e0       	ldi	r23, 0x01	; 1
     ed4:	ce 01       	movw	r24, r28
     ed6:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <strcmp>
     eda:	89 2b       	or	r24, r25
     edc:	31 f4       	brne	.+12     	; 0xeea <command_handler+0x50>
				relay_control(1,1);
     ede:	61 e0       	ldi	r22, 0x01	; 1
     ee0:	81 e0       	ldi	r24, 0x01	; 1
     ee2:	90 e0       	ldi	r25, 0x00	; 0
     ee4:	0e 94 1a 07 	call	0xe34	; 0xe34 <relay_control>
     ee8:	56 c0       	rjmp	.+172    	; 0xf96 <command_handler+0xfc>
			}
			else if(!strcmp(args[2], "1")) {
     eea:	66 e1       	ldi	r22, 0x16	; 22
     eec:	71 e0       	ldi	r23, 0x01	; 1
     eee:	ce 01       	movw	r24, r28
     ef0:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <strcmp>
     ef4:	89 2b       	or	r24, r25
     ef6:	09 f0       	breq	.+2      	; 0xefa <command_handler+0x60>
     ef8:	4e c0       	rjmp	.+156    	; 0xf96 <command_handler+0xfc>
				relay_control(1,0);
     efa:	60 e0       	ldi	r22, 0x00	; 0
     efc:	81 e0       	ldi	r24, 0x01	; 1
     efe:	90 e0       	ldi	r25, 0x00	; 0
     f00:	0e 94 1a 07 	call	0xe34	; 0xe34 <relay_control>
     f04:	48 c0       	rjmp	.+144    	; 0xf96 <command_handler+0xfc>
			}
		}
		else if(!strcmp(args[1], "1")) {
     f06:	66 e1       	ldi	r22, 0x16	; 22
     f08:	71 e0       	ldi	r23, 0x01	; 1
     f0a:	c8 01       	movw	r24, r16
     f0c:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <strcmp>
     f10:	89 2b       	or	r24, r25
     f12:	09 f0       	breq	.+2      	; 0xf16 <command_handler+0x7c>
     f14:	40 c0       	rjmp	.+128    	; 0xf96 <command_handler+0xfc>
			if(!strcmp(args[2], "0")) {
     f16:	0c 80       	ldd	r0, Y+4	; 0x04
     f18:	dd 81       	ldd	r29, Y+5	; 0x05
     f1a:	c0 2d       	mov	r28, r0
     f1c:	6d e0       	ldi	r22, 0x0D	; 13
     f1e:	71 e0       	ldi	r23, 0x01	; 1
     f20:	ce 01       	movw	r24, r28
     f22:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <strcmp>
     f26:	89 2b       	or	r24, r25
     f28:	31 f4       	brne	.+12     	; 0xf36 <command_handler+0x9c>
				relay_control(3,1);			
     f2a:	61 e0       	ldi	r22, 0x01	; 1
     f2c:	83 e0       	ldi	r24, 0x03	; 3
     f2e:	90 e0       	ldi	r25, 0x00	; 0
     f30:	0e 94 1a 07 	call	0xe34	; 0xe34 <relay_control>
     f34:	30 c0       	rjmp	.+96     	; 0xf96 <command_handler+0xfc>
			}
			else if(!strcmp(args[2], "1")) {
     f36:	66 e1       	ldi	r22, 0x16	; 22
     f38:	71 e0       	ldi	r23, 0x01	; 1
     f3a:	ce 01       	movw	r24, r28
     f3c:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <strcmp>
     f40:	89 2b       	or	r24, r25
     f42:	49 f5       	brne	.+82     	; 0xf96 <command_handler+0xfc>
				relay_control(3,0);			
     f44:	60 e0       	ldi	r22, 0x00	; 0
     f46:	83 e0       	ldi	r24, 0x03	; 3
     f48:	90 e0       	ldi	r25, 0x00	; 0
     f4a:	0e 94 1a 07 	call	0xe34	; 0xe34 <relay_control>
     f4e:	23 c0       	rjmp	.+70     	; 0xf96 <command_handler+0xfc>
			}
		}
	}
	else if(!strcmp(args[0], "fan") ) {
     f50:	6f e0       	ldi	r22, 0x0F	; 15
     f52:	71 e0       	ldi	r23, 0x01	; 1
     f54:	c8 01       	movw	r24, r16
     f56:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <strcmp>
     f5a:	89 2b       	or	r24, r25
     f5c:	e1 f4       	brne	.+56     	; 0xf96 <command_handler+0xfc>
		if(!strcmp(args[1], "0")) {
     f5e:	0a 80       	ldd	r0, Y+2	; 0x02
     f60:	db 81       	ldd	r29, Y+3	; 0x03
     f62:	c0 2d       	mov	r28, r0
     f64:	6d e0       	ldi	r22, 0x0D	; 13
     f66:	71 e0       	ldi	r23, 0x01	; 1
     f68:	ce 01       	movw	r24, r28
     f6a:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <strcmp>
     f6e:	89 2b       	or	r24, r25
     f70:	31 f4       	brne	.+12     	; 0xf7e <command_handler+0xe4>
			relay_control(0,1);
     f72:	61 e0       	ldi	r22, 0x01	; 1
     f74:	80 e0       	ldi	r24, 0x00	; 0
     f76:	90 e0       	ldi	r25, 0x00	; 0
     f78:	0e 94 1a 07 	call	0xe34	; 0xe34 <relay_control>
     f7c:	0c c0       	rjmp	.+24     	; 0xf96 <command_handler+0xfc>
		}
		else if(!strcmp(args[1], "1")) {
     f7e:	66 e1       	ldi	r22, 0x16	; 22
     f80:	71 e0       	ldi	r23, 0x01	; 1
     f82:	ce 01       	movw	r24, r28
     f84:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <strcmp>
     f88:	89 2b       	or	r24, r25
     f8a:	29 f4       	brne	.+10     	; 0xf96 <command_handler+0xfc>
			relay_control(0,0);
     f8c:	60 e0       	ldi	r22, 0x00	; 0
     f8e:	80 e0       	ldi	r24, 0x00	; 0
     f90:	90 e0       	ldi	r25, 0x00	; 0
     f92:	0e 94 1a 07 	call	0xe34	; 0xe34 <relay_control>
		//char message[50] = "unknown command\r\n";
		//remotch_client->send_all("unknown command\r\n", sizeof("unknown command\r\n")-1);
	}

	return 0;
}
     f96:	80 e0       	ldi	r24, 0x00	; 0
     f98:	90 e0       	ldi	r25, 0x00	; 0
     f9a:	df 91       	pop	r29
     f9c:	cf 91       	pop	r28
     f9e:	1f 91       	pop	r17
     fa0:	0f 91       	pop	r16
     fa2:	08 95       	ret

00000fa4 <command_parse_execute>:

void command_parse_execute(char *command){
     fa4:	ef 92       	push	r14
     fa6:	ff 92       	push	r15
     fa8:	0f 93       	push	r16
     faa:	1f 93       	push	r17
     fac:	cf 93       	push	r28
     fae:	df 93       	push	r29
     fb0:	cd b7       	in	r28, 0x3d	; 61
     fb2:	de b7       	in	r29, 0x3e	; 62
     fb4:	64 97       	sbiw	r28, 0x14	; 20
     fb6:	0f b6       	in	r0, 0x3f	; 63
     fb8:	f8 94       	cli
     fba:	de bf       	out	0x3e, r29	; 62
     fbc:	0f be       	out	0x3f, r0	; 63
     fbe:	cd bf       	out	0x3d, r28	; 61

	int arg_index = 0;
	char *pch;
	char *remotch_args[ 10];
	pch = strtok(command, " ");
     fc0:	63 e1       	ldi	r22, 0x13	; 19
     fc2:	71 e0       	ldi	r23, 0x01	; 1
     fc4:	0e 94 d5 0c 	call	0x19aa	; 0x19aa <strtok>
	while(pch != NULL) {
     fc8:	00 97       	sbiw	r24, 0x00	; 0
     fca:	d9 f0       	breq	.+54     	; 0x1002 <command_parse_execute+0x5e>
		remotch_args[arg_index] = pch;
     fcc:	9a 83       	std	Y+2, r25	; 0x02
     fce:	89 83       	std	Y+1, r24	; 0x01
     fd0:	7e 01       	movw	r14, r28
     fd2:	83 e0       	ldi	r24, 0x03	; 3
     fd4:	e8 0e       	add	r14, r24
     fd6:	f1 1c       	adc	r15, r1
     fd8:	01 e0       	ldi	r16, 0x01	; 1
     fda:	10 e0       	ldi	r17, 0x00	; 0
     fdc:	09 c0       	rjmp	.+18     	; 0xff0 <command_parse_execute+0x4c>
     fde:	f7 01       	movw	r30, r14
     fe0:	81 93       	st	Z+, r24
     fe2:	91 93       	st	Z+, r25
     fe4:	7f 01       	movw	r14, r30
		arg_index++;
     fe6:	0f 5f       	subi	r16, 0xFF	; 255
     fe8:	1f 4f       	sbci	r17, 0xFF	; 255
		if(arg_index >=10) break;
     fea:	0a 30       	cpi	r16, 0x0A	; 10
     fec:	11 05       	cpc	r17, r1
     fee:	59 f0       	breq	.+22     	; 0x1006 <command_parse_execute+0x62>
		pch = strtok (NULL, " ");
     ff0:	63 e1       	ldi	r22, 0x13	; 19
     ff2:	71 e0       	ldi	r23, 0x01	; 1
     ff4:	80 e0       	ldi	r24, 0x00	; 0
     ff6:	90 e0       	ldi	r25, 0x00	; 0
     ff8:	0e 94 d5 0c 	call	0x19aa	; 0x19aa <strtok>

	int arg_index = 0;
	char *pch;
	char *remotch_args[ 10];
	pch = strtok(command, " ");
	while(pch != NULL) {
     ffc:	00 97       	sbiw	r24, 0x00	; 0
     ffe:	79 f7       	brne	.-34     	; 0xfde <command_parse_execute+0x3a>
    1000:	02 c0       	rjmp	.+4      	; 0x1006 <command_parse_execute+0x62>
	return 0;
}

void command_parse_execute(char *command){

	int arg_index = 0;
    1002:	00 e0       	ldi	r16, 0x00	; 0
    1004:	10 e0       	ldi	r17, 0x00	; 0
		remotch_args[arg_index] = pch;
		arg_index++;
		if(arg_index >=10) break;
		pch = strtok (NULL, " ");
	}
	command_handler(remotch_args,arg_index);
    1006:	b8 01       	movw	r22, r16
    1008:	ce 01       	movw	r24, r28
    100a:	01 96       	adiw	r24, 0x01	; 1
    100c:	0e 94 4d 07 	call	0xe9a	; 0xe9a <command_handler>
}
    1010:	64 96       	adiw	r28, 0x14	; 20
    1012:	0f b6       	in	r0, 0x3f	; 63
    1014:	f8 94       	cli
    1016:	de bf       	out	0x3e, r29	; 62
    1018:	0f be       	out	0x3f, r0	; 63
    101a:	cd bf       	out	0x3d, r28	; 61
    101c:	df 91       	pop	r29
    101e:	cf 91       	pop	r28
    1020:	1f 91       	pop	r17
    1022:	0f 91       	pop	r16
    1024:	ff 90       	pop	r15
    1026:	ef 90       	pop	r14
    1028:	08 95       	ret

0000102a <thread_1>:




int thread_1(void)
{
    102a:	cf 93       	push	r28
    102c:	df 93       	push	r29
    102e:	cd b7       	in	r28, 0x3d	; 61
    1030:	de b7       	in	r29, 0x3e	; 62
    1032:	a3 97       	sbiw	r28, 0x23	; 35
    1034:	0f b6       	in	r0, 0x3f	; 63
    1036:	f8 94       	cli
    1038:	de bf       	out	0x3e, r29	; 62
    103a:	0f be       	out	0x3f, r0	; 63
    103c:	cd bf       	out	0x3d, r28	; 61
	DDRC|= (1<<7);
    103e:	3f 9a       	sbi	0x07, 7	; 7
	
	DDRD|=(1<<0);
    1040:	50 9a       	sbi	0x0a, 0	; 10
	DDRD|=(1<<1);
    1042:	51 9a       	sbi	0x0a, 1	; 10
	DDRD|=(1<<4);
    1044:	54 9a       	sbi	0x0a, 4	; 10
	DDRC|=(1<<6);
    1046:	3e 9a       	sbi	0x07, 6	; 7
	
	DDRD &= ~(1<<6);
    1048:	56 98       	cbi	0x0a, 6	; 10
	DDRB &= ~(1<<7);
    104a:	27 98       	cbi	0x04, 7	; 4
	DDRB &= ~(1<<6);
    104c:	26 98       	cbi	0x04, 6	; 4
	DDRB &= ~(1<<5);
    104e:	25 98       	cbi	0x04, 5	; 4
	
	DDRD&= ~(1<<6);
    1050:	56 98       	cbi	0x0a, 6	; 10
	
	
	_nrf24l01p_init();
    1052:	0e 94 33 0c 	call	0x1866	; 0x1866 <_nrf24l01p_init>
	_nrf24l01p_enable_dynamic_payload();
    1056:	0e 94 c8 0b 	call	0x1790	; 0x1790 <_nrf24l01p_enable_dynamic_payload>
	_nrf24l01p_enable_payload_with_ack();
    105a:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <_nrf24l01p_enable_payload_with_ack>

	_nrf24l01p_enable_auto_ack(_NRF24L01P_PIPE_P0);
    105e:	80 e0       	ldi	r24, 0x00	; 0
    1060:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <_nrf24l01p_enable_auto_ack>
	_nrf24l01p_enable_auto_ack(_NRF24L01P_PIPE_P1);
    1064:	81 e0       	ldi	r24, 0x01	; 1
    1066:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <_nrf24l01p_enable_auto_ack>
	_nrf24l01p_enable_auto_ack(_NRF24L01P_PIPE_P2);
    106a:	82 e0       	ldi	r24, 0x02	; 2
    106c:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <_nrf24l01p_enable_auto_ack>
	_nrf24l01p_enable_auto_ack(_NRF24L01P_PIPE_P3);
    1070:	83 e0       	ldi	r24, 0x03	; 3
    1072:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <_nrf24l01p_enable_auto_ack>
	_nrf24l01p_enable_auto_ack(_NRF24L01P_PIPE_P4);
    1076:	84 e0       	ldi	r24, 0x04	; 4
    1078:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <_nrf24l01p_enable_auto_ack>
	_nrf24l01p_enable_auto_ack(_NRF24L01P_PIPE_P5);
    107c:	85 e0       	ldi	r24, 0x05	; 5
    107e:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <_nrf24l01p_enable_auto_ack>

	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P0);
    1082:	80 e0       	ldi	r24, 0x00	; 0
    1084:	0e 94 8f 0b 	call	0x171e	; 0x171e <_nrf24l01p_enable_dynamic_payload_pipe>
	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P1);
    1088:	81 e0       	ldi	r24, 0x01	; 1
    108a:	0e 94 8f 0b 	call	0x171e	; 0x171e <_nrf24l01p_enable_dynamic_payload_pipe>
	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P2);
    108e:	82 e0       	ldi	r24, 0x02	; 2
    1090:	0e 94 8f 0b 	call	0x171e	; 0x171e <_nrf24l01p_enable_dynamic_payload_pipe>
	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P3);
    1094:	83 e0       	ldi	r24, 0x03	; 3
    1096:	0e 94 8f 0b 	call	0x171e	; 0x171e <_nrf24l01p_enable_dynamic_payload_pipe>
	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P4);
    109a:	84 e0       	ldi	r24, 0x04	; 4
    109c:	0e 94 8f 0b 	call	0x171e	; 0x171e <_nrf24l01p_enable_dynamic_payload_pipe>
	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P5);
    10a0:	85 e0       	ldi	r24, 0x05	; 5
    10a2:	0e 94 8f 0b 	call	0x171e	; 0x171e <_nrf24l01p_enable_dynamic_payload_pipe>

	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P0);
    10a6:	80 e0       	ldi	r24, 0x00	; 0
    10a8:	0e 94 8b 0a 	call	0x1516	; 0x1516 <_nrf24l01p_enable_rx_on_pipe>
	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P1);
    10ac:	81 e0       	ldi	r24, 0x01	; 1
    10ae:	0e 94 8b 0a 	call	0x1516	; 0x1516 <_nrf24l01p_enable_rx_on_pipe>
	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P2);
    10b2:	82 e0       	ldi	r24, 0x02	; 2
    10b4:	0e 94 8b 0a 	call	0x1516	; 0x1516 <_nrf24l01p_enable_rx_on_pipe>
	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P3);
    10b8:	83 e0       	ldi	r24, 0x03	; 3
    10ba:	0e 94 8b 0a 	call	0x1516	; 0x1516 <_nrf24l01p_enable_rx_on_pipe>
	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P4);
    10be:	84 e0       	ldi	r24, 0x04	; 4
    10c0:	0e 94 8b 0a 	call	0x1516	; 0x1516 <_nrf24l01p_enable_rx_on_pipe>
	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P5);
    10c4:	85 e0       	ldi	r24, 0x05	; 5
    10c6:	0e 94 8b 0a 	call	0x1516	; 0x1516 <_nrf24l01p_enable_rx_on_pipe>

	_nrf24l01p_set_auto_retransmission_delay(15);
    10ca:	8f e0       	ldi	r24, 0x0F	; 15
    10cc:	0e 94 b2 0a 	call	0x1564	; 0x1564 <_nrf24l01p_set_auto_retransmission_delay>
	_nrf24l01p_set_DataRate(_NRF24L01P_RF_SETUP_RF_DR_250KBPS);
    10d0:	80 e2       	ldi	r24, 0x20	; 32
    10d2:	0e 94 d6 0a 	call	0x15ac	; 0x15ac <_nrf24l01p_set_DataRate>
	_nrf24l01p_flush_rx();
    10d6:	0e 94 c4 09 	call	0x1388	; 0x1388 <_nrf24l01p_flush_rx>
	//LEFT
	_nrf24l01p_set_RX_pipe_address(_NRF24L01P_PIPE_P1, 0x4C4C4C4C31);
    10da:	01 e3       	ldi	r16, 0x31	; 49
    10dc:	1c e4       	ldi	r17, 0x4C	; 76
    10de:	2c e4       	ldi	r18, 0x4C	; 76
    10e0:	3c e4       	ldi	r19, 0x4C	; 76
    10e2:	4c e4       	ldi	r20, 0x4C	; 76
    10e4:	50 e0       	ldi	r21, 0x00	; 0
    10e6:	60 e0       	ldi	r22, 0x00	; 0
    10e8:	70 e0       	ldi	r23, 0x00	; 0
    10ea:	81 e0       	ldi	r24, 0x01	; 1
    10ec:	0e 94 0c 0b 	call	0x1618	; 0x1618 <_nrf24l01p_set_RX_pipe_address>
	_nrf24l01p_set_RX_pipe_address(_NRF24L01P_PIPE_P2, 0x4C4C4C4C32);
    10f0:	02 e3       	ldi	r16, 0x32	; 50
    10f2:	2c e4       	ldi	r18, 0x4C	; 76
    10f4:	3c e4       	ldi	r19, 0x4C	; 76
    10f6:	4c e4       	ldi	r20, 0x4C	; 76
    10f8:	50 e0       	ldi	r21, 0x00	; 0
    10fa:	60 e0       	ldi	r22, 0x00	; 0
    10fc:	70 e0       	ldi	r23, 0x00	; 0
    10fe:	82 e0       	ldi	r24, 0x02	; 2
    1100:	0e 94 0c 0b 	call	0x1618	; 0x1618 <_nrf24l01p_set_RX_pipe_address>
	_nrf24l01p_set_RX_pipe_address(_NRF24L01P_PIPE_P3, 0x4C4C4C4C33);
    1104:	03 e3       	ldi	r16, 0x33	; 51
    1106:	2c e4       	ldi	r18, 0x4C	; 76
    1108:	3c e4       	ldi	r19, 0x4C	; 76
    110a:	4c e4       	ldi	r20, 0x4C	; 76
    110c:	50 e0       	ldi	r21, 0x00	; 0
    110e:	60 e0       	ldi	r22, 0x00	; 0
    1110:	70 e0       	ldi	r23, 0x00	; 0
    1112:	83 e0       	ldi	r24, 0x03	; 3
    1114:	0e 94 0c 0b 	call	0x1618	; 0x1618 <_nrf24l01p_set_RX_pipe_address>
	_nrf24l01p_set_RX_pipe_address(_NRF24L01P_PIPE_P4, 0x4C4C4C4C34);
    1118:	04 e3       	ldi	r16, 0x34	; 52
    111a:	2c e4       	ldi	r18, 0x4C	; 76
    111c:	3c e4       	ldi	r19, 0x4C	; 76
    111e:	4c e4       	ldi	r20, 0x4C	; 76
    1120:	50 e0       	ldi	r21, 0x00	; 0
    1122:	60 e0       	ldi	r22, 0x00	; 0
    1124:	70 e0       	ldi	r23, 0x00	; 0
    1126:	84 e0       	ldi	r24, 0x04	; 4
    1128:	0e 94 0c 0b 	call	0x1618	; 0x1618 <_nrf24l01p_set_RX_pipe_address>
	_nrf24l01p_set_RX_pipe_address(_NRF24L01P_PIPE_P5, 0x4C4C4C4C35);
    112c:	05 e3       	ldi	r16, 0x35	; 53
    112e:	2c e4       	ldi	r18, 0x4C	; 76
    1130:	3c e4       	ldi	r19, 0x4C	; 76
    1132:	4c e4       	ldi	r20, 0x4C	; 76
    1134:	50 e0       	ldi	r21, 0x00	; 0
    1136:	60 e0       	ldi	r22, 0x00	; 0
    1138:	70 e0       	ldi	r23, 0x00	; 0
    113a:	85 e0       	ldi	r24, 0x05	; 5
    113c:	0e 94 0c 0b 	call	0x1618	; 0x1618 <_nrf24l01p_set_RX_pipe_address>
	
	
	char rxData[35];
	
	
	relay_control(0,1);
    1140:	61 e0       	ldi	r22, 0x01	; 1
    1142:	80 e0       	ldi	r24, 0x00	; 0
    1144:	90 e0       	ldi	r25, 0x00	; 0
    1146:	0e 94 1a 07 	call	0xe34	; 0xe34 <relay_control>
	relay_control(1,1);
    114a:	61 e0       	ldi	r22, 0x01	; 1
    114c:	81 e0       	ldi	r24, 0x01	; 1
    114e:	90 e0       	ldi	r25, 0x00	; 0
    1150:	0e 94 1a 07 	call	0xe34	; 0xe34 <relay_control>
	relay_control(2,1);
    1154:	61 e0       	ldi	r22, 0x01	; 1
    1156:	82 e0       	ldi	r24, 0x02	; 2
    1158:	90 e0       	ldi	r25, 0x00	; 0
    115a:	0e 94 1a 07 	call	0xe34	; 0xe34 <relay_control>
	relay_control(3,1);
    115e:	61 e0       	ldi	r22, 0x01	; 1
    1160:	83 e0       	ldi	r24, 0x03	; 3
    1162:	90 e0       	ldi	r25, 0x00	; 0
    1164:	0e 94 1a 07 	call	0xe34	; 0xe34 <relay_control>
	bool cow = 0;
	while(1){

		
		if((_nrf24l01p_readable(_NRF24L01P_PIPE_P1))){
			int width = _nrf24l01p_read_dyn_pld(_NRF24L01P_PIPE_P1, (uint8_t*) rxData);
    1168:	8e 01       	movw	r16, r28
    116a:	0f 5f       	subi	r16, 0xFF	; 255
    116c:	1f 4f       	sbci	r17, 0xFF	; 255
    116e:	e0 2e       	mov	r14, r16
    1170:	f1 2e       	mov	r15, r17
	
	bool cow = 0;
	while(1){

		
		if((_nrf24l01p_readable(_NRF24L01P_PIPE_P1))){
    1172:	81 e0       	ldi	r24, 0x01	; 1
    1174:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <_nrf24l01p_readable>
    1178:	88 23       	and	r24, r24
    117a:	69 f0       	breq	.+26     	; 0x1196 <thread_1+0x16c>
			int width = _nrf24l01p_read_dyn_pld(_NRF24L01P_PIPE_P1, (uint8_t*) rxData);
    117c:	6e 2d       	mov	r22, r14
    117e:	7f 2d       	mov	r23, r15
    1180:	81 e0       	ldi	r24, 0x01	; 1
    1182:	0e 94 86 0c 	call	0x190c	; 0x190c <_nrf24l01p_read_dyn_pld>
			rxData[width] = '\0';
    1186:	80 0f       	add	r24, r16
    1188:	91 1f       	adc	r25, r17
    118a:	fc 01       	movw	r30, r24
    118c:	10 82       	st	Z, r1
			command_parse_execute(rxData);
    118e:	8e 2d       	mov	r24, r14
    1190:	9f 2d       	mov	r25, r15
    1192:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <command_parse_execute>

		}
		
		
		
		if((switchPINPORT_0&(1<<switchPIN_0))){
    1196:	4e 9b       	sbis	0x09, 6	; 9
    1198:	12 c0       	rjmp	.+36     	; 0x11be <thread_1+0x194>
			relayState_0 = !relayState_0;
    119a:	30 91 c2 04 	lds	r19, 0x04C2
    119e:	21 e0       	ldi	r18, 0x01	; 1
    11a0:	23 27       	eor	r18, r19
    11a2:	20 93 c2 04 	sts	0x04C2, r18
			relay_control(0,relayState_0);
    11a6:	60 91 c2 04 	lds	r22, 0x04C2
    11aa:	80 e0       	ldi	r24, 0x00	; 0
    11ac:	90 e0       	ldi	r25, 0x00	; 0
    11ae:	0e 94 1a 07 	call	0xe34	; 0xe34 <relay_control>
			//PORTC^=(1<<7);
			while((switchPINPORT_0&(1<<switchPIN_0)));
    11b2:	4e 99       	sbic	0x09, 6	; 9
    11b4:	fe cf       	rjmp	.-4      	; 0x11b2 <thread_1+0x188>
			vTaskDelay(50);
    11b6:	82 e3       	ldi	r24, 0x32	; 50
    11b8:	90 e0       	ldi	r25, 0x00	; 0
    11ba:	0e 94 5f 05 	call	0xabe	; 0xabe <vTaskDelay>
		}
		if((switchPINPORT_1&(1<<switchPIN_1))){
    11be:	1f 9b       	sbis	0x03, 7	; 3
    11c0:	12 c0       	rjmp	.+36     	; 0x11e6 <thread_1+0x1bc>
			relayState_1 = !relayState_1;
    11c2:	90 91 c1 04 	lds	r25, 0x04C1
    11c6:	81 e0       	ldi	r24, 0x01	; 1
    11c8:	89 27       	eor	r24, r25
    11ca:	80 93 c1 04 	sts	0x04C1, r24
			relay_control(1,relayState_1);
    11ce:	60 91 c1 04 	lds	r22, 0x04C1
    11d2:	81 e0       	ldi	r24, 0x01	; 1
    11d4:	90 e0       	ldi	r25, 0x00	; 0
    11d6:	0e 94 1a 07 	call	0xe34	; 0xe34 <relay_control>
			//PORTC^=(1<<7);
			while((switchPINPORT_1&(1<<switchPIN_1)));
    11da:	1f 99       	sbic	0x03, 7	; 3
    11dc:	fe cf       	rjmp	.-4      	; 0x11da <thread_1+0x1b0>
			vTaskDelay(50);
    11de:	82 e3       	ldi	r24, 0x32	; 50
    11e0:	90 e0       	ldi	r25, 0x00	; 0
    11e2:	0e 94 5f 05 	call	0xabe	; 0xabe <vTaskDelay>
		}

		if((switchPINPORT_2&(1<<switchPIN_2))){
    11e6:	1e 9b       	sbis	0x03, 6	; 3
    11e8:	12 c0       	rjmp	.+36     	; 0x120e <thread_1+0x1e4>
			relayState_2 = !relayState_2;
    11ea:	80 91 c0 04 	lds	r24, 0x04C0
    11ee:	21 e0       	ldi	r18, 0x01	; 1
    11f0:	28 27       	eor	r18, r24
    11f2:	20 93 c0 04 	sts	0x04C0, r18
			relay_control(2,relayState_2);
    11f6:	60 91 c0 04 	lds	r22, 0x04C0
    11fa:	82 e0       	ldi	r24, 0x02	; 2
    11fc:	90 e0       	ldi	r25, 0x00	; 0
    11fe:	0e 94 1a 07 	call	0xe34	; 0xe34 <relay_control>
			//PORTC^=(1<<7);
			while((switchPINPORT_2&(1<<switchPIN_2)));
    1202:	1e 99       	sbic	0x03, 6	; 3
    1204:	fe cf       	rjmp	.-4      	; 0x1202 <thread_1+0x1d8>
			vTaskDelay(50);
    1206:	82 e3       	ldi	r24, 0x32	; 50
    1208:	90 e0       	ldi	r25, 0x00	; 0
    120a:	0e 94 5f 05 	call	0xabe	; 0xabe <vTaskDelay>
		}
		
		if((switchPINPORT_3&(1<<switchPIN_3))){
    120e:	1d 9b       	sbis	0x03, 5	; 3
    1210:	b0 cf       	rjmp	.-160    	; 0x1172 <thread_1+0x148>
			relayState_3 = !relayState_3;
    1212:	90 91 bf 04 	lds	r25, 0x04BF
    1216:	81 e0       	ldi	r24, 0x01	; 1
    1218:	89 27       	eor	r24, r25
    121a:	80 93 bf 04 	sts	0x04BF, r24
			relay_control(3,relayState_3);
    121e:	60 91 bf 04 	lds	r22, 0x04BF
    1222:	83 e0       	ldi	r24, 0x03	; 3
    1224:	90 e0       	ldi	r25, 0x00	; 0
    1226:	0e 94 1a 07 	call	0xe34	; 0xe34 <relay_control>
			//PORTC^=(1<<7);
			while((switchPINPORT_3&(1<<switchPIN_3)));
    122a:	1d 99       	sbic	0x03, 5	; 3
    122c:	fe cf       	rjmp	.-4      	; 0x122a <thread_1+0x200>
			vTaskDelay(50);
    122e:	82 e3       	ldi	r24, 0x32	; 50
    1230:	90 e0       	ldi	r25, 0x00	; 0
    1232:	0e 94 5f 05 	call	0xabe	; 0xabe <vTaskDelay>
    1236:	9d cf       	rjmp	.-198    	; 0x1172 <thread_1+0x148>

00001238 <main>:
 *  setup of all components and the main program loop.
 */
int main(void)
{

	xTaskCreate(thread_1,(const char *) "t1", 500, NULL, tskIDLE_PRIORITY, NULL );
    1238:	a1 2c       	mov	r10, r1
    123a:	b1 2c       	mov	r11, r1
    123c:	c1 2c       	mov	r12, r1
    123e:	d1 2c       	mov	r13, r1
    1240:	e1 2c       	mov	r14, r1
    1242:	f1 2c       	mov	r15, r1
    1244:	00 e0       	ldi	r16, 0x00	; 0
    1246:	20 e0       	ldi	r18, 0x00	; 0
    1248:	30 e0       	ldi	r19, 0x00	; 0
    124a:	44 ef       	ldi	r20, 0xF4	; 244
    124c:	51 e0       	ldi	r21, 0x01	; 1
    124e:	65 e1       	ldi	r22, 0x15	; 21
    1250:	71 e0       	ldi	r23, 0x01	; 1
    1252:	85 e1       	ldi	r24, 0x15	; 21
    1254:	98 e0       	ldi	r25, 0x08	; 8
    1256:	0e 94 cb 02 	call	0x596	; 0x596 <xTaskGenericCreate>
	
	//starting the scheduler
	vTaskStartScheduler();
    125a:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <vTaskStartScheduler>
	
	while(1){
		
	}
    125e:	ff cf       	rjmp	.-2      	; 0x125e <main+0x26>

00001260 <arch_spi_master_transmit_byte_val>:

	else {//if pipe not readable
		return 0;
	}
	return 0;	
}
    1260:	8e bd       	out	0x2e, r24	; 46
    1262:	0d b4       	in	r0, 0x2d	; 45
    1264:	07 fe       	sbrs	r0, 7
    1266:	fd cf       	rjmp	.-6      	; 0x1262 <arch_spi_master_transmit_byte_val+0x2>
    1268:	8e b5       	in	r24, 0x2e	; 46
    126a:	08 95       	ret

0000126c <arch_spi_master_transmit_byte_ref>:
    126c:	fc 01       	movw	r30, r24
    126e:	80 81       	ld	r24, Z
    1270:	8e bd       	out	0x2e, r24	; 46
    1272:	0d b4       	in	r0, 0x2d	; 45
    1274:	07 fe       	sbrs	r0, 7
    1276:	fd cf       	rjmp	.-6      	; 0x1272 <arch_spi_master_transmit_byte_ref+0x6>
    1278:	8e b5       	in	r24, 0x2e	; 46
    127a:	08 95       	ret

0000127c <_nrf24l01p_ce_pin>:
    127c:	88 23       	and	r24, r24
    127e:	11 f0       	breq	.+4      	; 0x1284 <_nrf24l01p_ce_pin+0x8>
    1280:	2c 9a       	sbi	0x05, 4	; 5
    1282:	01 c0       	rjmp	.+2      	; 0x1286 <_nrf24l01p_ce_pin+0xa>
    1284:	2c 98       	cbi	0x05, 4	; 5
    1286:	80 93 d1 04 	sts	0x04D1, r24
    128a:	08 95       	ret

0000128c <_nrf24l01p_csn_pin>:
    128c:	88 23       	and	r24, r24
    128e:	11 f0       	breq	.+4      	; 0x1294 <_nrf24l01p_csn_pin+0x8>
    1290:	5f 9a       	sbi	0x0b, 7	; 11
    1292:	01 c0       	rjmp	.+2      	; 0x1296 <_nrf24l01p_csn_pin+0xa>
    1294:	5f 98       	cbi	0x0b, 7	; 11
    1296:	80 93 d0 04 	sts	0x04D0, r24
    129a:	08 95       	ret

0000129c <_nrf24l01p_read_register>:
    129c:	ff 92       	push	r15
    129e:	0f 93       	push	r16
    12a0:	1f 93       	push	r17
    12a2:	cf 93       	push	r28
    12a4:	df 93       	push	r29
    12a6:	f8 2e       	mov	r15, r24
    12a8:	8b 01       	movw	r16, r22
    12aa:	ea 01       	movw	r28, r20
    12ac:	80 e0       	ldi	r24, 0x00	; 0
    12ae:	0e 94 46 09 	call	0x128c	; 0x128c <_nrf24l01p_csn_pin>
    12b2:	8f 2d       	mov	r24, r15
    12b4:	8f 71       	andi	r24, 0x1F	; 31
    12b6:	0e 94 30 09 	call	0x1260	; 0x1260 <arch_spi_master_transmit_byte_val>
    12ba:	1c 16       	cp	r1, r28
    12bc:	1d 06       	cpc	r1, r29
    12be:	74 f4       	brge	.+28     	; 0x12dc <_nrf24l01p_read_register+0x40>
    12c0:	f8 01       	movw	r30, r16
    12c2:	a8 01       	movw	r20, r16
    12c4:	4c 0f       	add	r20, r28
    12c6:	5d 1f       	adc	r21, r29
    12c8:	9f ef       	ldi	r25, 0xFF	; 255
    12ca:	9e bd       	out	0x2e, r25	; 46
    12cc:	0d b4       	in	r0, 0x2d	; 45
    12ce:	07 fe       	sbrs	r0, 7
    12d0:	fd cf       	rjmp	.-6      	; 0x12cc <_nrf24l01p_read_register+0x30>
    12d2:	8e b5       	in	r24, 0x2e	; 46
    12d4:	81 93       	st	Z+, r24
    12d6:	e4 17       	cp	r30, r20
    12d8:	f5 07       	cpc	r31, r21
    12da:	b9 f7       	brne	.-18     	; 0x12ca <_nrf24l01p_read_register+0x2e>
    12dc:	81 e0       	ldi	r24, 0x01	; 1
    12de:	0e 94 46 09 	call	0x128c	; 0x128c <_nrf24l01p_csn_pin>
    12e2:	df 91       	pop	r29
    12e4:	cf 91       	pop	r28
    12e6:	1f 91       	pop	r17
    12e8:	0f 91       	pop	r16
    12ea:	ff 90       	pop	r15
    12ec:	08 95       	ret

000012ee <_nrf24l01p_write_register>:
    12ee:	ef 92       	push	r14
    12f0:	ff 92       	push	r15
    12f2:	0f 93       	push	r16
    12f4:	1f 93       	push	r17
    12f6:	cf 93       	push	r28
    12f8:	df 93       	push	r29
    12fa:	c8 2f       	mov	r28, r24
    12fc:	7b 01       	movw	r14, r22
    12fe:	8a 01       	movw	r16, r20
    1300:	80 e0       	ldi	r24, 0x00	; 0
    1302:	0e 94 46 09 	call	0x128c	; 0x128c <_nrf24l01p_csn_pin>
    1306:	8c 2f       	mov	r24, r28
    1308:	8f 71       	andi	r24, 0x1F	; 31
    130a:	80 62       	ori	r24, 0x20	; 32
    130c:	0e 94 30 09 	call	0x1260	; 0x1260 <arch_spi_master_transmit_byte_val>
    1310:	10 16       	cp	r1, r16
    1312:	11 06       	cpc	r1, r17
    1314:	54 f4       	brge	.+20     	; 0x132a <_nrf24l01p_write_register+0x3c>
    1316:	e7 01       	movw	r28, r14
    1318:	0e 0d       	add	r16, r14
    131a:	1f 1d       	adc	r17, r15
    131c:	ce 01       	movw	r24, r28
    131e:	0e 94 36 09 	call	0x126c	; 0x126c <arch_spi_master_transmit_byte_ref>
    1322:	21 96       	adiw	r28, 0x01	; 1
    1324:	c0 17       	cp	r28, r16
    1326:	d1 07       	cpc	r29, r17
    1328:	c9 f7       	brne	.-14     	; 0x131c <_nrf24l01p_write_register+0x2e>
    132a:	81 e0       	ldi	r24, 0x01	; 1
    132c:	0e 94 46 09 	call	0x128c	; 0x128c <_nrf24l01p_csn_pin>
    1330:	df 91       	pop	r29
    1332:	cf 91       	pop	r28
    1334:	1f 91       	pop	r17
    1336:	0f 91       	pop	r16
    1338:	ff 90       	pop	r15
    133a:	ef 90       	pop	r14
    133c:	08 95       	ret

0000133e <_nrf24l01p_read_rx_payload>:
    133e:	0f 93       	push	r16
    1340:	1f 93       	push	r17
    1342:	cf 93       	push	r28
    1344:	df 93       	push	r29
    1346:	8c 01       	movw	r16, r24
    1348:	eb 01       	movw	r28, r22
    134a:	80 e0       	ldi	r24, 0x00	; 0
    134c:	0e 94 46 09 	call	0x128c	; 0x128c <_nrf24l01p_csn_pin>
    1350:	81 e6       	ldi	r24, 0x61	; 97
    1352:	0e 94 30 09 	call	0x1260	; 0x1260 <arch_spi_master_transmit_byte_val>
    1356:	1c 16       	cp	r1, r28
    1358:	1d 06       	cpc	r1, r29
    135a:	74 f4       	brge	.+28     	; 0x1378 <_nrf24l01p_read_rx_payload+0x3a>
    135c:	f8 01       	movw	r30, r16
    135e:	b8 01       	movw	r22, r16
    1360:	6c 0f       	add	r22, r28
    1362:	7d 1f       	adc	r23, r29
    1364:	8f ef       	ldi	r24, 0xFF	; 255
    1366:	8e bd       	out	0x2e, r24	; 46
    1368:	0d b4       	in	r0, 0x2d	; 45
    136a:	07 fe       	sbrs	r0, 7
    136c:	fd cf       	rjmp	.-6      	; 0x1368 <_nrf24l01p_read_rx_payload+0x2a>
    136e:	9e b5       	in	r25, 0x2e	; 46
    1370:	91 93       	st	Z+, r25
    1372:	e6 17       	cp	r30, r22
    1374:	f7 07       	cpc	r31, r23
    1376:	b9 f7       	brne	.-18     	; 0x1366 <_nrf24l01p_read_rx_payload+0x28>
    1378:	81 e0       	ldi	r24, 0x01	; 1
    137a:	0e 94 46 09 	call	0x128c	; 0x128c <_nrf24l01p_csn_pin>
    137e:	df 91       	pop	r29
    1380:	cf 91       	pop	r28
    1382:	1f 91       	pop	r17
    1384:	0f 91       	pop	r16
    1386:	08 95       	ret

00001388 <_nrf24l01p_flush_rx>:
    1388:	80 e0       	ldi	r24, 0x00	; 0
    138a:	0e 94 46 09 	call	0x128c	; 0x128c <_nrf24l01p_csn_pin>
    138e:	82 ee       	ldi	r24, 0xE2	; 226
    1390:	0e 94 30 09 	call	0x1260	; 0x1260 <arch_spi_master_transmit_byte_val>
    1394:	81 e0       	ldi	r24, 0x01	; 1
    1396:	0e 94 46 09 	call	0x128c	; 0x128c <_nrf24l01p_csn_pin>
    139a:	08 95       	ret

0000139c <_nrf24l01p_read_rx_payload_width>:
    139c:	cf 93       	push	r28
    139e:	80 e0       	ldi	r24, 0x00	; 0
    13a0:	0e 94 46 09 	call	0x128c	; 0x128c <_nrf24l01p_csn_pin>
    13a4:	80 e6       	ldi	r24, 0x60	; 96
    13a6:	0e 94 30 09 	call	0x1260	; 0x1260 <arch_spi_master_transmit_byte_val>
    13aa:	8f ef       	ldi	r24, 0xFF	; 255
    13ac:	0e 94 30 09 	call	0x1260	; 0x1260 <arch_spi_master_transmit_byte_val>
    13b0:	c8 2f       	mov	r28, r24
    13b2:	81 e0       	ldi	r24, 0x01	; 1
    13b4:	0e 94 46 09 	call	0x128c	; 0x128c <_nrf24l01p_csn_pin>
    13b8:	8c 2f       	mov	r24, r28
    13ba:	90 e0       	ldi	r25, 0x00	; 0
    13bc:	cf 91       	pop	r28
    13be:	08 95       	ret

000013c0 <_nrf24l01p_get_status>:
    13c0:	cf 93       	push	r28
    13c2:	80 e0       	ldi	r24, 0x00	; 0
    13c4:	0e 94 46 09 	call	0x128c	; 0x128c <_nrf24l01p_csn_pin>
    13c8:	8f ef       	ldi	r24, 0xFF	; 255
    13ca:	0e 94 30 09 	call	0x1260	; 0x1260 <arch_spi_master_transmit_byte_val>
    13ce:	c8 2f       	mov	r28, r24
    13d0:	81 e0       	ldi	r24, 0x01	; 1
    13d2:	0e 94 46 09 	call	0x128c	; 0x128c <_nrf24l01p_csn_pin>
    13d6:	8c 2f       	mov	r24, r28
    13d8:	90 e0       	ldi	r25, 0x00	; 0
    13da:	cf 91       	pop	r28
    13dc:	08 95       	ret

000013de <_nrf24l01p_power_up>:
    13de:	cf 93       	push	r28
    13e0:	df 93       	push	r29
    13e2:	1f 92       	push	r1
    13e4:	cd b7       	in	r28, 0x3d	; 61
    13e6:	de b7       	in	r29, 0x3e	; 62
    13e8:	41 e0       	ldi	r20, 0x01	; 1
    13ea:	50 e0       	ldi	r21, 0x00	; 0
    13ec:	be 01       	movw	r22, r28
    13ee:	6f 5f       	subi	r22, 0xFF	; 255
    13f0:	7f 4f       	sbci	r23, 0xFF	; 255
    13f2:	80 e0       	ldi	r24, 0x00	; 0
    13f4:	0e 94 4e 09 	call	0x129c	; 0x129c <_nrf24l01p_read_register>
    13f8:	89 81       	ldd	r24, Y+1	; 0x01
    13fa:	82 60       	ori	r24, 0x02	; 2
    13fc:	89 83       	std	Y+1, r24	; 0x01
    13fe:	41 e0       	ldi	r20, 0x01	; 1
    1400:	50 e0       	ldi	r21, 0x00	; 0
    1402:	be 01       	movw	r22, r28
    1404:	6f 5f       	subi	r22, 0xFF	; 255
    1406:	7f 4f       	sbci	r23, 0xFF	; 255
    1408:	80 e0       	ldi	r24, 0x00	; 0
    140a:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    140e:	8f e4       	ldi	r24, 0x4F	; 79
    1410:	96 e4       	ldi	r25, 0x46	; 70
    1412:	01 97       	sbiw	r24, 0x01	; 1
    1414:	f1 f7       	brne	.-4      	; 0x1412 <_nrf24l01p_power_up+0x34>
    1416:	00 c0       	rjmp	.+0      	; 0x1418 <_nrf24l01p_power_up+0x3a>
    1418:	00 00       	nop
    141a:	82 e0       	ldi	r24, 0x02	; 2
    141c:	80 93 d2 04 	sts	0x04D2, r24
    1420:	0f 90       	pop	r0
    1422:	df 91       	pop	r29
    1424:	cf 91       	pop	r28
    1426:	08 95       	ret

00001428 <_nrf24l01p_power_down>:
    1428:	cf 93       	push	r28
    142a:	df 93       	push	r29
    142c:	1f 92       	push	r1
    142e:	cd b7       	in	r28, 0x3d	; 61
    1430:	de b7       	in	r29, 0x3e	; 62
    1432:	41 e0       	ldi	r20, 0x01	; 1
    1434:	50 e0       	ldi	r21, 0x00	; 0
    1436:	be 01       	movw	r22, r28
    1438:	6f 5f       	subi	r22, 0xFF	; 255
    143a:	7f 4f       	sbci	r23, 0xFF	; 255
    143c:	80 e0       	ldi	r24, 0x00	; 0
    143e:	0e 94 4e 09 	call	0x129c	; 0x129c <_nrf24l01p_read_register>
    1442:	89 81       	ldd	r24, Y+1	; 0x01
    1444:	8d 7f       	andi	r24, 0xFD	; 253
    1446:	89 83       	std	Y+1, r24	; 0x01
    1448:	41 e0       	ldi	r20, 0x01	; 1
    144a:	50 e0       	ldi	r21, 0x00	; 0
    144c:	be 01       	movw	r22, r28
    144e:	6f 5f       	subi	r22, 0xFF	; 255
    1450:	7f 4f       	sbci	r23, 0xFF	; 255
    1452:	80 e0       	ldi	r24, 0x00	; 0
    1454:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    1458:	81 e0       	ldi	r24, 0x01	; 1
    145a:	80 93 d2 04 	sts	0x04D2, r24
    145e:	0f 90       	pop	r0
    1460:	df 91       	pop	r29
    1462:	cf 91       	pop	r28
    1464:	08 95       	ret

00001466 <_nrf24l01p_rx_mode>:
    1466:	cf 93       	push	r28
    1468:	df 93       	push	r29
    146a:	1f 92       	push	r1
    146c:	cd b7       	in	r28, 0x3d	; 61
    146e:	de b7       	in	r29, 0x3e	; 62
    1470:	41 e0       	ldi	r20, 0x01	; 1
    1472:	50 e0       	ldi	r21, 0x00	; 0
    1474:	be 01       	movw	r22, r28
    1476:	6f 5f       	subi	r22, 0xFF	; 255
    1478:	7f 4f       	sbci	r23, 0xFF	; 255
    147a:	80 e0       	ldi	r24, 0x00	; 0
    147c:	0e 94 4e 09 	call	0x129c	; 0x129c <_nrf24l01p_read_register>
    1480:	89 81       	ldd	r24, Y+1	; 0x01
    1482:	81 60       	ori	r24, 0x01	; 1
    1484:	89 83       	std	Y+1, r24	; 0x01
    1486:	41 e0       	ldi	r20, 0x01	; 1
    1488:	50 e0       	ldi	r21, 0x00	; 0
    148a:	be 01       	movw	r22, r28
    148c:	6f 5f       	subi	r22, 0xFF	; 255
    148e:	7f 4f       	sbci	r23, 0xFF	; 255
    1490:	80 e0       	ldi	r24, 0x00	; 0
    1492:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    1496:	83 e0       	ldi	r24, 0x03	; 3
    1498:	80 93 d2 04 	sts	0x04D2, r24
    149c:	0f 90       	pop	r0
    149e:	df 91       	pop	r29
    14a0:	cf 91       	pop	r28
    14a2:	08 95       	ret

000014a4 <_nrf24l01p_enable_auto_ack>:
    14a4:	1f 93       	push	r17
    14a6:	cf 93       	push	r28
    14a8:	df 93       	push	r29
    14aa:	1f 92       	push	r1
    14ac:	cd b7       	in	r28, 0x3d	; 61
    14ae:	de b7       	in	r29, 0x3e	; 62
    14b0:	18 2f       	mov	r17, r24
    14b2:	41 e0       	ldi	r20, 0x01	; 1
    14b4:	50 e0       	ldi	r21, 0x00	; 0
    14b6:	be 01       	movw	r22, r28
    14b8:	6f 5f       	subi	r22, 0xFF	; 255
    14ba:	7f 4f       	sbci	r23, 0xFF	; 255
    14bc:	81 e0       	ldi	r24, 0x01	; 1
    14be:	0e 94 4e 09 	call	0x129c	; 0x129c <_nrf24l01p_read_register>
    14c2:	21 e0       	ldi	r18, 0x01	; 1
    14c4:	30 e0       	ldi	r19, 0x00	; 0
    14c6:	c9 01       	movw	r24, r18
    14c8:	02 c0       	rjmp	.+4      	; 0x14ce <_nrf24l01p_enable_auto_ack+0x2a>
    14ca:	88 0f       	add	r24, r24
    14cc:	99 1f       	adc	r25, r25
    14ce:	1a 95       	dec	r17
    14d0:	e2 f7       	brpl	.-8      	; 0x14ca <_nrf24l01p_enable_auto_ack+0x26>
    14d2:	99 81       	ldd	r25, Y+1	; 0x01
    14d4:	89 2b       	or	r24, r25
    14d6:	89 83       	std	Y+1, r24	; 0x01
    14d8:	41 e0       	ldi	r20, 0x01	; 1
    14da:	50 e0       	ldi	r21, 0x00	; 0
    14dc:	be 01       	movw	r22, r28
    14de:	6f 5f       	subi	r22, 0xFF	; 255
    14e0:	7f 4f       	sbci	r23, 0xFF	; 255
    14e2:	81 e0       	ldi	r24, 0x01	; 1
    14e4:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    14e8:	0f 90       	pop	r0
    14ea:	df 91       	pop	r29
    14ec:	cf 91       	pop	r28
    14ee:	1f 91       	pop	r17
    14f0:	08 95       	ret

000014f2 <_nrf24l01p_disable_auto_ack_all_pipes>:
    14f2:	cf 93       	push	r28
    14f4:	df 93       	push	r29
    14f6:	1f 92       	push	r1
    14f8:	cd b7       	in	r28, 0x3d	; 61
    14fa:	de b7       	in	r29, 0x3e	; 62
    14fc:	19 82       	std	Y+1, r1	; 0x01
    14fe:	41 e0       	ldi	r20, 0x01	; 1
    1500:	50 e0       	ldi	r21, 0x00	; 0
    1502:	be 01       	movw	r22, r28
    1504:	6f 5f       	subi	r22, 0xFF	; 255
    1506:	7f 4f       	sbci	r23, 0xFF	; 255
    1508:	81 e0       	ldi	r24, 0x01	; 1
    150a:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    150e:	0f 90       	pop	r0
    1510:	df 91       	pop	r29
    1512:	cf 91       	pop	r28
    1514:	08 95       	ret

00001516 <_nrf24l01p_enable_rx_on_pipe>:
    1516:	1f 93       	push	r17
    1518:	cf 93       	push	r28
    151a:	df 93       	push	r29
    151c:	1f 92       	push	r1
    151e:	cd b7       	in	r28, 0x3d	; 61
    1520:	de b7       	in	r29, 0x3e	; 62
    1522:	18 2f       	mov	r17, r24
    1524:	41 e0       	ldi	r20, 0x01	; 1
    1526:	50 e0       	ldi	r21, 0x00	; 0
    1528:	be 01       	movw	r22, r28
    152a:	6f 5f       	subi	r22, 0xFF	; 255
    152c:	7f 4f       	sbci	r23, 0xFF	; 255
    152e:	82 e0       	ldi	r24, 0x02	; 2
    1530:	0e 94 4e 09 	call	0x129c	; 0x129c <_nrf24l01p_read_register>
    1534:	21 e0       	ldi	r18, 0x01	; 1
    1536:	30 e0       	ldi	r19, 0x00	; 0
    1538:	c9 01       	movw	r24, r18
    153a:	02 c0       	rjmp	.+4      	; 0x1540 <_nrf24l01p_enable_rx_on_pipe+0x2a>
    153c:	88 0f       	add	r24, r24
    153e:	99 1f       	adc	r25, r25
    1540:	1a 95       	dec	r17
    1542:	e2 f7       	brpl	.-8      	; 0x153c <_nrf24l01p_enable_rx_on_pipe+0x26>
    1544:	99 81       	ldd	r25, Y+1	; 0x01
    1546:	89 2b       	or	r24, r25
    1548:	89 83       	std	Y+1, r24	; 0x01
    154a:	41 e0       	ldi	r20, 0x01	; 1
    154c:	50 e0       	ldi	r21, 0x00	; 0
    154e:	be 01       	movw	r22, r28
    1550:	6f 5f       	subi	r22, 0xFF	; 255
    1552:	7f 4f       	sbci	r23, 0xFF	; 255
    1554:	82 e0       	ldi	r24, 0x02	; 2
    1556:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    155a:	0f 90       	pop	r0
    155c:	df 91       	pop	r29
    155e:	cf 91       	pop	r28
    1560:	1f 91       	pop	r17
    1562:	08 95       	ret

00001564 <_nrf24l01p_set_auto_retransmission_delay>:
    1564:	1f 93       	push	r17
    1566:	cf 93       	push	r28
    1568:	df 93       	push	r29
    156a:	1f 92       	push	r1
    156c:	cd b7       	in	r28, 0x3d	; 61
    156e:	de b7       	in	r29, 0x3e	; 62
    1570:	18 2f       	mov	r17, r24
    1572:	41 e0       	ldi	r20, 0x01	; 1
    1574:	50 e0       	ldi	r21, 0x00	; 0
    1576:	be 01       	movw	r22, r28
    1578:	6f 5f       	subi	r22, 0xFF	; 255
    157a:	7f 4f       	sbci	r23, 0xFF	; 255
    157c:	84 e0       	ldi	r24, 0x04	; 4
    157e:	0e 94 4e 09 	call	0x129c	; 0x129c <_nrf24l01p_read_register>
    1582:	20 e1       	ldi	r18, 0x10	; 16
    1584:	12 9f       	mul	r17, r18
    1586:	c0 01       	movw	r24, r0
    1588:	11 24       	eor	r1, r1
    158a:	99 81       	ldd	r25, Y+1	; 0x01
    158c:	9f 70       	andi	r25, 0x0F	; 15
    158e:	89 2b       	or	r24, r25
    1590:	89 83       	std	Y+1, r24	; 0x01
    1592:	41 e0       	ldi	r20, 0x01	; 1
    1594:	50 e0       	ldi	r21, 0x00	; 0
    1596:	be 01       	movw	r22, r28
    1598:	6f 5f       	subi	r22, 0xFF	; 255
    159a:	7f 4f       	sbci	r23, 0xFF	; 255
    159c:	84 e0       	ldi	r24, 0x04	; 4
    159e:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    15a2:	0f 90       	pop	r0
    15a4:	df 91       	pop	r29
    15a6:	cf 91       	pop	r28
    15a8:	1f 91       	pop	r17
    15aa:	08 95       	ret

000015ac <_nrf24l01p_set_DataRate>:
    15ac:	1f 93       	push	r17
    15ae:	cf 93       	push	r28
    15b0:	df 93       	push	r29
    15b2:	1f 92       	push	r1
    15b4:	cd b7       	in	r28, 0x3d	; 61
    15b6:	de b7       	in	r29, 0x3e	; 62
    15b8:	18 2f       	mov	r17, r24
    15ba:	41 e0       	ldi	r20, 0x01	; 1
    15bc:	50 e0       	ldi	r21, 0x00	; 0
    15be:	be 01       	movw	r22, r28
    15c0:	6f 5f       	subi	r22, 0xFF	; 255
    15c2:	7f 4f       	sbci	r23, 0xFF	; 255
    15c4:	86 e0       	ldi	r24, 0x06	; 6
    15c6:	0e 94 4e 09 	call	0x129c	; 0x129c <_nrf24l01p_read_register>
    15ca:	99 81       	ldd	r25, Y+1	; 0x01
    15cc:	97 7d       	andi	r25, 0xD7	; 215
    15ce:	81 2f       	mov	r24, r17
    15d0:	89 2b       	or	r24, r25
    15d2:	89 83       	std	Y+1, r24	; 0x01
    15d4:	41 e0       	ldi	r20, 0x01	; 1
    15d6:	50 e0       	ldi	r21, 0x00	; 0
    15d8:	be 01       	movw	r22, r28
    15da:	6f 5f       	subi	r22, 0xFF	; 255
    15dc:	7f 4f       	sbci	r23, 0xFF	; 255
    15de:	86 e0       	ldi	r24, 0x06	; 6
    15e0:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    15e4:	0f 90       	pop	r0
    15e6:	df 91       	pop	r29
    15e8:	cf 91       	pop	r28
    15ea:	1f 91       	pop	r17
    15ec:	08 95       	ret

000015ee <_nrf24l01p_clear_data_ready_flag>:
    15ee:	cf 93       	push	r28
    15f0:	df 93       	push	r29
    15f2:	1f 92       	push	r1
    15f4:	cd b7       	in	r28, 0x3d	; 61
    15f6:	de b7       	in	r29, 0x3e	; 62
    15f8:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <_nrf24l01p_get_status>
    15fc:	80 64       	ori	r24, 0x40	; 64
    15fe:	89 83       	std	Y+1, r24	; 0x01
    1600:	41 e0       	ldi	r20, 0x01	; 1
    1602:	50 e0       	ldi	r21, 0x00	; 0
    1604:	be 01       	movw	r22, r28
    1606:	6f 5f       	subi	r22, 0xFF	; 255
    1608:	7f 4f       	sbci	r23, 0xFF	; 255
    160a:	87 e0       	ldi	r24, 0x07	; 7
    160c:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    1610:	0f 90       	pop	r0
    1612:	df 91       	pop	r29
    1614:	cf 91       	pop	r28
    1616:	08 95       	ret

00001618 <_nrf24l01p_set_RX_pipe_address>:
    1618:	2f 92       	push	r2
    161a:	3f 92       	push	r3
    161c:	4f 92       	push	r4
    161e:	5f 92       	push	r5
    1620:	6f 92       	push	r6
    1622:	7f 92       	push	r7
    1624:	8f 92       	push	r8
    1626:	9f 92       	push	r9
    1628:	af 92       	push	r10
    162a:	bf 92       	push	r11
    162c:	cf 92       	push	r12
    162e:	df 92       	push	r13
    1630:	ef 92       	push	r14
    1632:	ff 92       	push	r15
    1634:	0f 93       	push	r16
    1636:	1f 93       	push	r17
    1638:	cf 93       	push	r28
    163a:	df 93       	push	r29
    163c:	00 d0       	rcall	.+0      	; 0x163e <_nrf24l01p_set_RX_pipe_address+0x26>
    163e:	00 d0       	rcall	.+0      	; 0x1640 <_nrf24l01p_set_RX_pipe_address+0x28>
    1640:	1f 92       	push	r1
    1642:	cd b7       	in	r28, 0x3d	; 61
    1644:	de b7       	in	r29, 0x3e	; 62
    1646:	48 2e       	mov	r4, r24
    1648:	b0 2e       	mov	r11, r16
    164a:	a2 2e       	mov	r10, r18
    164c:	93 2e       	mov	r9, r19
    164e:	84 2e       	mov	r8, r20
    1650:	75 2e       	mov	r7, r21
    1652:	66 2e       	mov	r6, r22
    1654:	57 2e       	mov	r5, r23
    1656:	81 e0       	ldi	r24, 0x01	; 1
    1658:	84 15       	cp	r24, r4
    165a:	68 f4       	brcc	.+26     	; 0x1676 <_nrf24l01p_set_RX_pipe_address+0x5e>
    165c:	21 e0       	ldi	r18, 0x01	; 1
    165e:	90 e0       	ldi	r25, 0x00	; 0
    1660:	8e ef       	ldi	r24, 0xFE	; 254
    1662:	84 0d       	add	r24, r4
    1664:	84 30       	cpi	r24, 0x04	; 4
    1666:	08 f0       	brcs	.+2      	; 0x166a <_nrf24l01p_set_RX_pipe_address+0x52>
    1668:	20 e0       	ldi	r18, 0x00	; 0
    166a:	c2 2e       	mov	r12, r18
    166c:	d9 2e       	mov	r13, r25
    166e:	1c 14       	cp	r1, r12
    1670:	1d 04       	cpc	r1, r13
    1672:	34 f0       	brlt	.+12     	; 0x1680 <_nrf24l01p_set_RX_pipe_address+0x68>
    1674:	21 c0       	rjmp	.+66     	; 0x16b8 <_nrf24l01p_set_RX_pipe_address+0xa0>
    1676:	0f 2e       	mov	r0, r31
    1678:	f5 e0       	ldi	r31, 0x05	; 5
    167a:	cf 2e       	mov	r12, r31
    167c:	d1 2c       	mov	r13, r1
    167e:	f0 2d       	mov	r31, r0
    1680:	de 01       	movw	r26, r28
    1682:	11 96       	adiw	r26, 0x01	; 1
    1684:	7d 01       	movw	r14, r26
    1686:	21 2c       	mov	r2, r1
    1688:	31 2c       	mov	r3, r1
    168a:	e0 e0       	ldi	r30, 0x00	; 0
    168c:	f0 e0       	ldi	r31, 0x00	; 0
    168e:	2b 2d       	mov	r18, r11
    1690:	31 2f       	mov	r19, r17
    1692:	4a 2d       	mov	r20, r10
    1694:	59 2d       	mov	r21, r9
    1696:	68 2d       	mov	r22, r8
    1698:	77 2d       	mov	r23, r7
    169a:	86 2d       	mov	r24, r6
    169c:	95 2d       	mov	r25, r5
    169e:	02 2d       	mov	r16, r2
    16a0:	0e 94 b9 0c 	call	0x1972	; 0x1972 <__lshrdi3>
    16a4:	d7 01       	movw	r26, r14
    16a6:	2d 93       	st	X+, r18
    16a8:	7d 01       	movw	r14, r26
    16aa:	31 96       	adiw	r30, 0x01	; 1
    16ac:	b8 e0       	ldi	r27, 0x08	; 8
    16ae:	2b 0e       	add	r2, r27
    16b0:	31 1c       	adc	r3, r1
    16b2:	ec 15       	cp	r30, r12
    16b4:	fd 05       	cpc	r31, r13
    16b6:	5c f3       	brlt	.-42     	; 0x168e <_nrf24l01p_set_RX_pipe_address+0x76>
    16b8:	a6 01       	movw	r20, r12
    16ba:	be 01       	movw	r22, r28
    16bc:	6f 5f       	subi	r22, 0xFF	; 255
    16be:	7f 4f       	sbci	r23, 0xFF	; 255
    16c0:	8a e0       	ldi	r24, 0x0A	; 10
    16c2:	84 0d       	add	r24, r4
    16c4:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    16c8:	0f 90       	pop	r0
    16ca:	0f 90       	pop	r0
    16cc:	0f 90       	pop	r0
    16ce:	0f 90       	pop	r0
    16d0:	0f 90       	pop	r0
    16d2:	df 91       	pop	r29
    16d4:	cf 91       	pop	r28
    16d6:	1f 91       	pop	r17
    16d8:	0f 91       	pop	r16
    16da:	ff 90       	pop	r15
    16dc:	ef 90       	pop	r14
    16de:	df 90       	pop	r13
    16e0:	cf 90       	pop	r12
    16e2:	bf 90       	pop	r11
    16e4:	af 90       	pop	r10
    16e6:	9f 90       	pop	r9
    16e8:	8f 90       	pop	r8
    16ea:	7f 90       	pop	r7
    16ec:	6f 90       	pop	r6
    16ee:	5f 90       	pop	r5
    16f0:	4f 90       	pop	r4
    16f2:	3f 90       	pop	r3
    16f4:	2f 90       	pop	r2
    16f6:	08 95       	ret

000016f8 <_nrf24l01p_get_fifo_flag_rx_empty>:
    16f8:	cf 93       	push	r28
    16fa:	df 93       	push	r29
    16fc:	1f 92       	push	r1
    16fe:	cd b7       	in	r28, 0x3d	; 61
    1700:	de b7       	in	r29, 0x3e	; 62
    1702:	41 e0       	ldi	r20, 0x01	; 1
    1704:	50 e0       	ldi	r21, 0x00	; 0
    1706:	be 01       	movw	r22, r28
    1708:	6f 5f       	subi	r22, 0xFF	; 255
    170a:	7f 4f       	sbci	r23, 0xFF	; 255
    170c:	87 e1       	ldi	r24, 0x17	; 23
    170e:	0e 94 4e 09 	call	0x129c	; 0x129c <_nrf24l01p_read_register>
    1712:	89 81       	ldd	r24, Y+1	; 0x01
    1714:	81 70       	andi	r24, 0x01	; 1
    1716:	0f 90       	pop	r0
    1718:	df 91       	pop	r29
    171a:	cf 91       	pop	r28
    171c:	08 95       	ret

0000171e <_nrf24l01p_enable_dynamic_payload_pipe>:
    171e:	1f 93       	push	r17
    1720:	cf 93       	push	r28
    1722:	df 93       	push	r29
    1724:	1f 92       	push	r1
    1726:	cd b7       	in	r28, 0x3d	; 61
    1728:	de b7       	in	r29, 0x3e	; 62
    172a:	18 2f       	mov	r17, r24
    172c:	41 e0       	ldi	r20, 0x01	; 1
    172e:	50 e0       	ldi	r21, 0x00	; 0
    1730:	be 01       	movw	r22, r28
    1732:	6f 5f       	subi	r22, 0xFF	; 255
    1734:	7f 4f       	sbci	r23, 0xFF	; 255
    1736:	8c e1       	ldi	r24, 0x1C	; 28
    1738:	0e 94 4e 09 	call	0x129c	; 0x129c <_nrf24l01p_read_register>
    173c:	21 e0       	ldi	r18, 0x01	; 1
    173e:	30 e0       	ldi	r19, 0x00	; 0
    1740:	c9 01       	movw	r24, r18
    1742:	02 c0       	rjmp	.+4      	; 0x1748 <_nrf24l01p_enable_dynamic_payload_pipe+0x2a>
    1744:	88 0f       	add	r24, r24
    1746:	99 1f       	adc	r25, r25
    1748:	1a 95       	dec	r17
    174a:	e2 f7       	brpl	.-8      	; 0x1744 <_nrf24l01p_enable_dynamic_payload_pipe+0x26>
    174c:	99 81       	ldd	r25, Y+1	; 0x01
    174e:	89 2b       	or	r24, r25
    1750:	89 83       	std	Y+1, r24	; 0x01
    1752:	41 e0       	ldi	r20, 0x01	; 1
    1754:	50 e0       	ldi	r21, 0x00	; 0
    1756:	be 01       	movw	r22, r28
    1758:	6f 5f       	subi	r22, 0xFF	; 255
    175a:	7f 4f       	sbci	r23, 0xFF	; 255
    175c:	8c e1       	ldi	r24, 0x1C	; 28
    175e:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    1762:	0f 90       	pop	r0
    1764:	df 91       	pop	r29
    1766:	cf 91       	pop	r28
    1768:	1f 91       	pop	r17
    176a:	08 95       	ret

0000176c <_nrf24l01p_disable_dynamic_payload_all_pipe>:
    176c:	cf 93       	push	r28
    176e:	df 93       	push	r29
    1770:	1f 92       	push	r1
    1772:	cd b7       	in	r28, 0x3d	; 61
    1774:	de b7       	in	r29, 0x3e	; 62
    1776:	19 82       	std	Y+1, r1	; 0x01
    1778:	41 e0       	ldi	r20, 0x01	; 1
    177a:	50 e0       	ldi	r21, 0x00	; 0
    177c:	be 01       	movw	r22, r28
    177e:	6f 5f       	subi	r22, 0xFF	; 255
    1780:	7f 4f       	sbci	r23, 0xFF	; 255
    1782:	8c e1       	ldi	r24, 0x1C	; 28
    1784:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    1788:	0f 90       	pop	r0
    178a:	df 91       	pop	r29
    178c:	cf 91       	pop	r28
    178e:	08 95       	ret

00001790 <_nrf24l01p_enable_dynamic_payload>:
    1790:	cf 93       	push	r28
    1792:	df 93       	push	r29
    1794:	1f 92       	push	r1
    1796:	cd b7       	in	r28, 0x3d	; 61
    1798:	de b7       	in	r29, 0x3e	; 62
    179a:	41 e0       	ldi	r20, 0x01	; 1
    179c:	50 e0       	ldi	r21, 0x00	; 0
    179e:	be 01       	movw	r22, r28
    17a0:	6f 5f       	subi	r22, 0xFF	; 255
    17a2:	7f 4f       	sbci	r23, 0xFF	; 255
    17a4:	8d e1       	ldi	r24, 0x1D	; 29
    17a6:	0e 94 4e 09 	call	0x129c	; 0x129c <_nrf24l01p_read_register>
    17aa:	89 81       	ldd	r24, Y+1	; 0x01
    17ac:	84 60       	ori	r24, 0x04	; 4
    17ae:	89 83       	std	Y+1, r24	; 0x01
    17b0:	41 e0       	ldi	r20, 0x01	; 1
    17b2:	50 e0       	ldi	r21, 0x00	; 0
    17b4:	be 01       	movw	r22, r28
    17b6:	6f 5f       	subi	r22, 0xFF	; 255
    17b8:	7f 4f       	sbci	r23, 0xFF	; 255
    17ba:	8d e1       	ldi	r24, 0x1D	; 29
    17bc:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    17c0:	0f 90       	pop	r0
    17c2:	df 91       	pop	r29
    17c4:	cf 91       	pop	r28
    17c6:	08 95       	ret

000017c8 <_nrf24l01p_enable_payload_with_ack>:
    17c8:	cf 93       	push	r28
    17ca:	df 93       	push	r29
    17cc:	1f 92       	push	r1
    17ce:	cd b7       	in	r28, 0x3d	; 61
    17d0:	de b7       	in	r29, 0x3e	; 62
    17d2:	41 e0       	ldi	r20, 0x01	; 1
    17d4:	50 e0       	ldi	r21, 0x00	; 0
    17d6:	be 01       	movw	r22, r28
    17d8:	6f 5f       	subi	r22, 0xFF	; 255
    17da:	7f 4f       	sbci	r23, 0xFF	; 255
    17dc:	8d e1       	ldi	r24, 0x1D	; 29
    17de:	0e 94 4e 09 	call	0x129c	; 0x129c <_nrf24l01p_read_register>
    17e2:	89 81       	ldd	r24, Y+1	; 0x01
    17e4:	82 60       	ori	r24, 0x02	; 2
    17e6:	89 83       	std	Y+1, r24	; 0x01
    17e8:	41 e0       	ldi	r20, 0x01	; 1
    17ea:	50 e0       	ldi	r21, 0x00	; 0
    17ec:	be 01       	movw	r22, r28
    17ee:	6f 5f       	subi	r22, 0xFF	; 255
    17f0:	7f 4f       	sbci	r23, 0xFF	; 255
    17f2:	8d e1       	ldi	r24, 0x1D	; 29
    17f4:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    17f8:	0f 90       	pop	r0
    17fa:	df 91       	pop	r29
    17fc:	cf 91       	pop	r28
    17fe:	08 95       	ret

00001800 <_nrf24l01p_startup>:
    1800:	cf 93       	push	r28
    1802:	df 93       	push	r29
    1804:	1f 92       	push	r1
    1806:	cd b7       	in	r28, 0x3d	; 61
    1808:	de b7       	in	r29, 0x3e	; 62
    180a:	87 e0       	ldi	r24, 0x07	; 7
    180c:	89 83       	std	Y+1, r24	; 0x01
    180e:	41 e0       	ldi	r20, 0x01	; 1
    1810:	50 e0       	ldi	r21, 0x00	; 0
    1812:	be 01       	movw	r22, r28
    1814:	6f 5f       	subi	r22, 0xFF	; 255
    1816:	7f 4f       	sbci	r23, 0xFF	; 255
    1818:	86 e0       	ldi	r24, 0x06	; 6
    181a:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    181e:	19 82       	std	Y+1, r1	; 0x01
    1820:	41 e0       	ldi	r20, 0x01	; 1
    1822:	50 e0       	ldi	r21, 0x00	; 0
    1824:	be 01       	movw	r22, r28
    1826:	6f 5f       	subi	r22, 0xFF	; 255
    1828:	7f 4f       	sbci	r23, 0xFF	; 255
    182a:	81 e0       	ldi	r24, 0x01	; 1
    182c:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    1830:	81 e0       	ldi	r24, 0x01	; 1
    1832:	89 83       	std	Y+1, r24	; 0x01
    1834:	41 e0       	ldi	r20, 0x01	; 1
    1836:	50 e0       	ldi	r21, 0x00	; 0
    1838:	be 01       	movw	r22, r28
    183a:	6f 5f       	subi	r22, 0xFF	; 255
    183c:	7f 4f       	sbci	r23, 0xFF	; 255
    183e:	86 e0       	ldi	r24, 0x06	; 6
    1840:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    1844:	0e 94 ef 09 	call	0x13de	; 0x13de <_nrf24l01p_power_up>
    1848:	8f e4       	ldi	r24, 0x4F	; 79
    184a:	96 e4       	ldi	r25, 0x46	; 70
    184c:	01 97       	sbiw	r24, 0x01	; 1
    184e:	f1 f7       	brne	.-4      	; 0x184c <_nrf24l01p_startup+0x4c>
    1850:	00 c0       	rjmp	.+0      	; 0x1852 <_nrf24l01p_startup+0x52>
    1852:	00 00       	nop
    1854:	0e 94 33 0a 	call	0x1466	; 0x1466 <_nrf24l01p_rx_mode>
    1858:	81 e0       	ldi	r24, 0x01	; 1
    185a:	0e 94 3e 09 	call	0x127c	; 0x127c <_nrf24l01p_ce_pin>
    185e:	0f 90       	pop	r0
    1860:	df 91       	pop	r29
    1862:	cf 91       	pop	r28
    1864:	08 95       	ret

00001866 <_nrf24l01p_init>:
    1866:	cf 93       	push	r28
    1868:	df 93       	push	r29
    186a:	00 d0       	rcall	.+0      	; 0x186c <_nrf24l01p_init+0x6>
    186c:	cd b7       	in	r28, 0x3d	; 61
    186e:	de b7       	in	r29, 0x3e	; 62
    1870:	57 9a       	sbi	0x0a, 7	; 10
    1872:	24 9a       	sbi	0x04, 4	; 4
    1874:	2c 98       	cbi	0x05, 4	; 5
    1876:	5f 9a       	sbi	0x0b, 7	; 11
    1878:	84 b1       	in	r24, 0x04	; 4
    187a:	87 60       	ori	r24, 0x07	; 7
    187c:	84 b9       	out	0x04, r24	; 4
    187e:	23 98       	cbi	0x04, 3	; 4
    1880:	8c b5       	in	r24, 0x2c	; 44
    1882:	80 65       	ori	r24, 0x50	; 80
    1884:	8c bd       	out	0x2c, r24	; 44
    1886:	80 e0       	ldi	r24, 0x00	; 0
    1888:	0e 94 3e 09 	call	0x127c	; 0x127c <_nrf24l01p_ce_pin>
    188c:	81 e0       	ldi	r24, 0x01	; 1
    188e:	0e 94 46 09 	call	0x128c	; 0x128c <_nrf24l01p_csn_pin>
    1892:	0e 94 c4 09 	call	0x1388	; 0x1388 <_nrf24l01p_flush_rx>
    1896:	0e 94 14 0a 	call	0x1428	; 0x1428 <_nrf24l01p_power_down>
    189a:	8e e0       	ldi	r24, 0x0E	; 14
    189c:	89 83       	std	Y+1, r24	; 0x01
    189e:	41 e0       	ldi	r20, 0x01	; 1
    18a0:	50 e0       	ldi	r21, 0x00	; 0
    18a2:	be 01       	movw	r22, r28
    18a4:	6f 5f       	subi	r22, 0xFF	; 255
    18a6:	7f 4f       	sbci	r23, 0xFF	; 255
    18a8:	87 e0       	ldi	r24, 0x07	; 7
    18aa:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    18ae:	8b e0       	ldi	r24, 0x0B	; 11
    18b0:	8a 83       	std	Y+2, r24	; 0x02
    18b2:	41 e0       	ldi	r20, 0x01	; 1
    18b4:	50 e0       	ldi	r21, 0x00	; 0
    18b6:	be 01       	movw	r22, r28
    18b8:	6e 5f       	subi	r22, 0xFE	; 254
    18ba:	7f 4f       	sbci	r23, 0xFF	; 255
    18bc:	80 e0       	ldi	r24, 0x00	; 0
    18be:	0e 94 77 09 	call	0x12ee	; 0x12ee <_nrf24l01p_write_register>
    18c2:	0e 94 79 0a 	call	0x14f2	; 0x14f2 <_nrf24l01p_disable_auto_ack_all_pipes>
    18c6:	0e 94 b6 0b 	call	0x176c	; 0x176c <_nrf24l01p_disable_dynamic_payload_all_pipe>
    18ca:	0e 94 00 0c 	call	0x1800	; 0x1800 <_nrf24l01p_startup>
    18ce:	0f 90       	pop	r0
    18d0:	0f 90       	pop	r0
    18d2:	df 91       	pop	r29
    18d4:	cf 91       	pop	r28
    18d6:	08 95       	ret

000018d8 <_nrf24l01p_readable>:
    18d8:	cf 93       	push	r28
    18da:	86 30       	cpi	r24, 0x06	; 6
    18dc:	90 f4       	brcc	.+36     	; 0x1902 <_nrf24l01p_readable+0x2a>
    18de:	c8 2f       	mov	r28, r24
    18e0:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <_nrf24l01p_get_status>
    18e4:	86 ff       	sbrs	r24, 6
    18e6:	0f c0       	rjmp	.+30     	; 0x1906 <_nrf24l01p_readable+0x2e>
    18e8:	8e 70       	andi	r24, 0x0E	; 14
    18ea:	99 27       	eor	r25, r25
    18ec:	ac 01       	movw	r20, r24
    18ee:	55 95       	asr	r21
    18f0:	47 95       	ror	r20
    18f2:	2c 2f       	mov	r18, r28
    18f4:	30 e0       	ldi	r19, 0x00	; 0
    18f6:	81 e0       	ldi	r24, 0x01	; 1
    18f8:	42 17       	cp	r20, r18
    18fa:	53 07       	cpc	r21, r19
    18fc:	29 f0       	breq	.+10     	; 0x1908 <_nrf24l01p_readable+0x30>
    18fe:	80 e0       	ldi	r24, 0x00	; 0
    1900:	03 c0       	rjmp	.+6      	; 0x1908 <_nrf24l01p_readable+0x30>
    1902:	80 e0       	ldi	r24, 0x00	; 0
    1904:	01 c0       	rjmp	.+2      	; 0x1908 <_nrf24l01p_readable+0x30>
    1906:	80 e0       	ldi	r24, 0x00	; 0
    1908:	cf 91       	pop	r28
    190a:	08 95       	ret

0000190c <_nrf24l01p_read_dyn_pld>:
int _nrf24l01p_read_dyn_pld(_nrf24l01p_pipe_t pipe, uint8_t *data){
    190c:	0f 93       	push	r16
    190e:	1f 93       	push	r17
    1910:	cf 93       	push	r28
    1912:	df 93       	push	r29
	
	int rxPayloadWidth;
	
	if ( ( pipe < 0 ) || ( pipe > 5 ) ) {
    1914:	86 30       	cpi	r24, 0x06	; 6
    1916:	f0 f4       	brcc	.+60     	; 0x1954 <_nrf24l01p_read_dyn_pld+0x48>
    1918:	eb 01       	movw	r28, r22
		return -1;
	}
	
	if (_nrf24l01p_readable(pipe) ) {
    191a:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <_nrf24l01p_readable>
    191e:	88 23       	and	r24, r24
    1920:	e1 f0       	breq	.+56     	; 0x195a <_nrf24l01p_read_dyn_pld+0x4e>
		asm("nop");
    1922:	00 00       	nop
		rxPayloadWidth = _nrf24l01p_read_rx_payload_width();
    1924:	0e 94 ce 09 	call	0x139c	; 0x139c <_nrf24l01p_read_rx_payload_width>
    1928:	8c 01       	movw	r16, r24
	
		if ( ( rxPayloadWidth < 0 ) || ( rxPayloadWidth > _NRF24L01P_RX_FIFO_SIZE ) ) {
    192a:	81 32       	cpi	r24, 0x21	; 33
    192c:	91 05       	cpc	r25, r1
    192e:	28 f0       	brcs	.+10     	; 0x193a <_nrf24l01p_read_dyn_pld+0x2e>
			_nrf24l01p_flush_rx();
    1930:	0e 94 c4 09 	call	0x1388	; 0x1388 <_nrf24l01p_flush_rx>
			if(_nrf24l01p_get_fifo_flag_rx_empty()) {
				_nrf24l01p_clear_data_ready_flag();
			}
		}

		return rxPayloadWidth;
    1934:	80 2f       	mov	r24, r16
    1936:	91 2f       	mov	r25, r17
    1938:	15 c0       	rjmp	.+42     	; 0x1964 <_nrf24l01p_read_dyn_pld+0x58>
	
		if ( ( rxPayloadWidth < 0 ) || ( rxPayloadWidth > _NRF24L01P_RX_FIFO_SIZE ) ) {
			_nrf24l01p_flush_rx();
		}
		else{
			_nrf24l01p_read_rx_payload(data,rxPayloadWidth);
    193a:	bc 01       	movw	r22, r24
    193c:	ce 01       	movw	r24, r28
    193e:	0e 94 9f 09 	call	0x133e	; 0x133e <_nrf24l01p_read_rx_payload>
					
			if(_nrf24l01p_get_fifo_flag_rx_empty()) {
    1942:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <_nrf24l01p_get_fifo_flag_rx_empty>
    1946:	88 23       	and	r24, r24
    1948:	59 f0       	breq	.+22     	; 0x1960 <_nrf24l01p_read_dyn_pld+0x54>
				_nrf24l01p_clear_data_ready_flag();
    194a:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <_nrf24l01p_clear_data_ready_flag>
			}
		}

		return rxPayloadWidth;
    194e:	80 2f       	mov	r24, r16
    1950:	91 2f       	mov	r25, r17
    1952:	08 c0       	rjmp	.+16     	; 0x1964 <_nrf24l01p_read_dyn_pld+0x58>
int _nrf24l01p_read_dyn_pld(_nrf24l01p_pipe_t pipe, uint8_t *data){
	
	int rxPayloadWidth;
	
	if ( ( pipe < 0 ) || ( pipe > 5 ) ) {
		return -1;
    1954:	8f ef       	ldi	r24, 0xFF	; 255
    1956:	9f ef       	ldi	r25, 0xFF	; 255
    1958:	05 c0       	rjmp	.+10     	; 0x1964 <_nrf24l01p_read_dyn_pld+0x58>
// 			_nrf24l01p_clear_data_ready_flag();
// 		}
// 		return rxPayloadWidth;
//	}
	else {//if pipe not readable
		return 0;
    195a:	80 e0       	ldi	r24, 0x00	; 0
    195c:	90 e0       	ldi	r25, 0x00	; 0
    195e:	02 c0       	rjmp	.+4      	; 0x1964 <_nrf24l01p_read_dyn_pld+0x58>
			if(_nrf24l01p_get_fifo_flag_rx_empty()) {
				_nrf24l01p_clear_data_ready_flag();
			}
		}

		return rxPayloadWidth;
    1960:	80 2f       	mov	r24, r16
    1962:	91 2f       	mov	r25, r17
//	}
	else {//if pipe not readable
		return 0;
	}
	return 0;
}
    1964:	df 91       	pop	r29
    1966:	cf 91       	pop	r28
    1968:	1f 91       	pop	r17
    196a:	0f 91       	pop	r16
    196c:	08 95       	ret

0000196e <__ashrdi3>:
    196e:	97 fb       	bst	r25, 7
    1970:	10 f8       	bld	r1, 0

00001972 <__lshrdi3>:
    1972:	16 94       	lsr	r1
    1974:	00 08       	sbc	r0, r0
    1976:	0f 93       	push	r16
    1978:	08 30       	cpi	r16, 0x08	; 8
    197a:	98 f0       	brcs	.+38     	; 0x19a2 <__lshrdi3+0x30>
    197c:	08 50       	subi	r16, 0x08	; 8
    197e:	23 2f       	mov	r18, r19
    1980:	34 2f       	mov	r19, r20
    1982:	45 2f       	mov	r20, r21
    1984:	56 2f       	mov	r21, r22
    1986:	67 2f       	mov	r22, r23
    1988:	78 2f       	mov	r23, r24
    198a:	89 2f       	mov	r24, r25
    198c:	90 2d       	mov	r25, r0
    198e:	f4 cf       	rjmp	.-24     	; 0x1978 <__lshrdi3+0x6>
    1990:	05 94       	asr	r0
    1992:	97 95       	ror	r25
    1994:	87 95       	ror	r24
    1996:	77 95       	ror	r23
    1998:	67 95       	ror	r22
    199a:	57 95       	ror	r21
    199c:	47 95       	ror	r20
    199e:	37 95       	ror	r19
    19a0:	27 95       	ror	r18
    19a2:	0a 95       	dec	r16
    19a4:	aa f7       	brpl	.-22     	; 0x1990 <__lshrdi3+0x1e>
    19a6:	0f 91       	pop	r16
    19a8:	08 95       	ret

000019aa <strtok>:
    19aa:	48 e1       	ldi	r20, 0x18	; 24
    19ac:	51 e0       	ldi	r21, 0x01	; 1
    19ae:	0e 94 e3 0c 	call	0x19c6	; 0x19c6 <strtok_r>
    19b2:	08 95       	ret

000019b4 <strcmp>:
    19b4:	fb 01       	movw	r30, r22
    19b6:	dc 01       	movw	r26, r24
    19b8:	8d 91       	ld	r24, X+
    19ba:	01 90       	ld	r0, Z+
    19bc:	80 19       	sub	r24, r0
    19be:	01 10       	cpse	r0, r1
    19c0:	d9 f3       	breq	.-10     	; 0x19b8 <strcmp+0x4>
    19c2:	99 0b       	sbc	r25, r25
    19c4:	08 95       	ret

000019c6 <strtok_r>:
    19c6:	fa 01       	movw	r30, r20
    19c8:	a1 91       	ld	r26, Z+
    19ca:	b0 81       	ld	r27, Z
    19cc:	00 97       	sbiw	r24, 0x00	; 0
    19ce:	19 f4       	brne	.+6      	; 0x19d6 <strtok_r+0x10>
    19d0:	10 97       	sbiw	r26, 0x00	; 0
    19d2:	e1 f0       	breq	.+56     	; 0x1a0c <strtok_r+0x46>
    19d4:	cd 01       	movw	r24, r26
    19d6:	dc 01       	movw	r26, r24
    19d8:	cd 01       	movw	r24, r26
    19da:	0d 90       	ld	r0, X+
    19dc:	00 20       	and	r0, r0
    19de:	11 f4       	brne	.+4      	; 0x19e4 <strtok_r+0x1e>
    19e0:	c0 01       	movw	r24, r0
    19e2:	13 c0       	rjmp	.+38     	; 0x1a0a <strtok_r+0x44>
    19e4:	fb 01       	movw	r30, r22
    19e6:	21 91       	ld	r18, Z+
    19e8:	22 23       	and	r18, r18
    19ea:	19 f0       	breq	.+6      	; 0x19f2 <strtok_r+0x2c>
    19ec:	20 15       	cp	r18, r0
    19ee:	d9 f7       	brne	.-10     	; 0x19e6 <strtok_r+0x20>
    19f0:	f3 cf       	rjmp	.-26     	; 0x19d8 <strtok_r+0x12>
    19f2:	fb 01       	movw	r30, r22
    19f4:	21 91       	ld	r18, Z+
    19f6:	20 15       	cp	r18, r0
    19f8:	19 f4       	brne	.+6      	; 0x1a00 <strtok_r+0x3a>
    19fa:	1e 92       	st	-X, r1
    19fc:	11 96       	adiw	r26, 0x01	; 1
    19fe:	06 c0       	rjmp	.+12     	; 0x1a0c <strtok_r+0x46>
    1a00:	22 23       	and	r18, r18
    1a02:	c1 f7       	brne	.-16     	; 0x19f4 <strtok_r+0x2e>
    1a04:	0d 90       	ld	r0, X+
    1a06:	00 20       	and	r0, r0
    1a08:	a1 f7       	brne	.-24     	; 0x19f2 <strtok_r+0x2c>
    1a0a:	d0 01       	movw	r26, r0
    1a0c:	fa 01       	movw	r30, r20
    1a0e:	a1 93       	st	Z+, r26
    1a10:	b0 83       	st	Z, r27
    1a12:	08 95       	ret

00001a14 <_exit>:
    1a14:	f8 94       	cli

00001a16 <__stop_program>:
    1a16:	ff cf       	rjmp	.-2      	; 0x1a16 <__stop_program>
