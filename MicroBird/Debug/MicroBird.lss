
MicroBird.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000024  00800100  00001e2a  00001ebe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001e2a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000003b5  00800124  00800124  00001ee2  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00001ee2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001f40  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000500  00000000  00000000  00001f80  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005f4b  00000000  00000000  00002480  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000014a8  00000000  00000000  000083cb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002046  00000000  00000000  00009873  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001098  00000000  00000000  0000b8bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000025a6  00000000  00000000  0000c954  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004430  00000000  00000000  0000eefa  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006a0  00000000  00000000  0001332a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
       0:	0c 94 56 00 	jmp	0xac	; 0xac <__ctors_end>
       4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
       8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
       c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      10:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      14:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      18:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      1c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
      20:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      24:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
      28:	0c 94 52 06 	jmp	0xca4	; 0xca4 <__vector_10>
      2c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
      30:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
      34:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>

	if (Endpoint_IsSETUPReceived())
      38:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
      3c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>

		switch (USB_ControlRequest.bRequest)
      40:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      44:	0c 94 d0 01 	jmp	0x3a0	; 0x3a0 <__vector_17>
      48:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      4c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      50:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      54:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
      58:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      5c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      60:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
      64:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
      68:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      6c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
      70:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
      74:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      78:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      7c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
      80:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      84:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      88:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
      8c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      90:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      94:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
      98:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
				UEDATX = (Data >> 8);
      9c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
      a0:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
	Endpoint_ClearSETUP();

	Endpoint_Write_16_LE(CurrentStatus);
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
      a4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      a8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>

000000ac <__ctors_end>:
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
      ac:	11 24       	eor	r1, r1
      ae:	1f be       	out	0x3f, r1	; 63
      b0:	cf ef       	ldi	r28, 0xFF	; 255
      b2:	da e0       	ldi	r29, 0x0A	; 10
      b4:	de bf       	out	0x3e, r29	; 62
      b6:	cd bf       	out	0x3d, r28	; 61

000000b8 <__do_copy_data>:
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
      b8:	11 e0       	ldi	r17, 0x01	; 1
      ba:	a0 e0       	ldi	r26, 0x00	; 0
      bc:	b1 e0       	ldi	r27, 0x01	; 1
      be:	ea e2       	ldi	r30, 0x2A	; 42
      c0:	fe e1       	ldi	r31, 0x1E	; 30
      c2:	02 c0       	rjmp	.+4      	; 0xc8 <__do_copy_data+0x10>
      c4:	05 90       	lpm	r0, Z+
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
      c6:	0d 92       	st	X+, r0
      c8:	a4 32       	cpi	r26, 0x24	; 36
      ca:	b1 07       	cpc	r27, r17

				if (EndpointIndex == ENDPOINT_CONTROLEP)
      cc:	d9 f7       	brne	.-10     	; 0xc4 <__do_copy_data+0xc>

000000ce <__do_clear_bss>:
      ce:	24 e0       	ldi	r18, 0x04	; 4
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
      d0:	a4 e2       	ldi	r26, 0x24	; 36
      d2:	b1 e0       	ldi	r27, 0x01	; 1
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
      d4:	01 c0       	rjmp	.+2      	; 0xd8 <.do_clear_bss_start>

000000d6 <.do_clear_bss_loop>:
      d6:	1d 92       	st	X+, r1

000000d8 <.do_clear_bss_start>:
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
      d8:	a9 3d       	cpi	r26, 0xD9	; 217
      da:	b2 07       	cpc	r27, r18
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
      dc:	e1 f7       	brne	.-8      	; 0xd6 <.do_clear_bss_loop>
      de:	0e 94 cf 07 	call	0xf9e	; 0xf9e <main>
      e2:	0c 94 13 0f 	jmp	0x1e26	; 0x1e26 <_exit>

000000e6 <__bad_interrupt>:
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
      e6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ea <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
      ea:	31 e1       	ldi	r19, 0x11	; 17
      ec:	fc 01       	movw	r30, r24
      ee:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
      f0:	31 97       	sbiw	r30, 0x01	; 1
      f2:	22 e2       	ldi	r18, 0x22	; 34
      f4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
      f6:	31 97       	sbiw	r30, 0x01	; 1
      f8:	a3 e3       	ldi	r26, 0x33	; 51
      fa:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
      fc:	31 97       	sbiw	r30, 0x01	; 1
      fe:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     100:	31 97       	sbiw	r30, 0x01	; 1
     102:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     104:	31 97       	sbiw	r30, 0x01	; 1
     106:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     108:	31 97       	sbiw	r30, 0x01	; 1
     10a:	60 e8       	ldi	r22, 0x80	; 128
     10c:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     10e:	31 97       	sbiw	r30, 0x01	; 1
     110:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     112:	31 97       	sbiw	r30, 0x01	; 1
     114:	62 e0       	ldi	r22, 0x02	; 2
     116:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     118:	31 97       	sbiw	r30, 0x01	; 1
     11a:	63 e0       	ldi	r22, 0x03	; 3
     11c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     11e:	31 97       	sbiw	r30, 0x01	; 1
     120:	64 e0       	ldi	r22, 0x04	; 4
     122:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     124:	31 97       	sbiw	r30, 0x01	; 1
     126:	65 e0       	ldi	r22, 0x05	; 5
     128:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     12a:	31 97       	sbiw	r30, 0x01	; 1
     12c:	66 e0       	ldi	r22, 0x06	; 6
     12e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     130:	31 97       	sbiw	r30, 0x01	; 1
     132:	67 e0       	ldi	r22, 0x07	; 7
     134:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     136:	31 97       	sbiw	r30, 0x01	; 1
     138:	68 e0       	ldi	r22, 0x08	; 8
     13a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     13c:	31 97       	sbiw	r30, 0x01	; 1
     13e:	69 e0       	ldi	r22, 0x09	; 9
     140:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     142:	31 97       	sbiw	r30, 0x01	; 1
     144:	60 e1       	ldi	r22, 0x10	; 16
     146:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     148:	31 97       	sbiw	r30, 0x01	; 1
     14a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     14c:	31 97       	sbiw	r30, 0x01	; 1
     14e:	32 e1       	ldi	r19, 0x12	; 18
     150:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     152:	31 97       	sbiw	r30, 0x01	; 1
     154:	33 e1       	ldi	r19, 0x13	; 19
     156:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     158:	31 97       	sbiw	r30, 0x01	; 1
     15a:	34 e1       	ldi	r19, 0x14	; 20
     15c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     15e:	31 97       	sbiw	r30, 0x01	; 1
     160:	35 e1       	ldi	r19, 0x15	; 21
     162:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     164:	31 97       	sbiw	r30, 0x01	; 1
     166:	36 e1       	ldi	r19, 0x16	; 22
     168:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     16a:	31 97       	sbiw	r30, 0x01	; 1
     16c:	37 e1       	ldi	r19, 0x17	; 23
     16e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     170:	31 97       	sbiw	r30, 0x01	; 1
     172:	38 e1       	ldi	r19, 0x18	; 24
     174:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     176:	31 97       	sbiw	r30, 0x01	; 1
     178:	39 e1       	ldi	r19, 0x19	; 25
     17a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     17c:	31 97       	sbiw	r30, 0x01	; 1
     17e:	30 e2       	ldi	r19, 0x20	; 32
     180:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     182:	31 97       	sbiw	r30, 0x01	; 1
     184:	31 e2       	ldi	r19, 0x21	; 33
     186:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     188:	31 97       	sbiw	r30, 0x01	; 1
     18a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     18c:	31 97       	sbiw	r30, 0x01	; 1
     18e:	23 e2       	ldi	r18, 0x23	; 35
     190:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     192:	31 97       	sbiw	r30, 0x01	; 1
     194:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     196:	31 97       	sbiw	r30, 0x01	; 1
     198:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     19a:	31 97       	sbiw	r30, 0x01	; 1
     19c:	26 e2       	ldi	r18, 0x26	; 38
     19e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     1a0:	31 97       	sbiw	r30, 0x01	; 1
     1a2:	27 e2       	ldi	r18, 0x27	; 39
     1a4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     1a6:	31 97       	sbiw	r30, 0x01	; 1
     1a8:	28 e2       	ldi	r18, 0x28	; 40
     1aa:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     1ac:	31 97       	sbiw	r30, 0x01	; 1
     1ae:	29 e2       	ldi	r18, 0x29	; 41
     1b0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     1b2:	31 97       	sbiw	r30, 0x01	; 1
     1b4:	20 e3       	ldi	r18, 0x30	; 48
     1b6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     1b8:	31 97       	sbiw	r30, 0x01	; 1
     1ba:	21 e3       	ldi	r18, 0x31	; 49
     1bc:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     1be:	86 97       	sbiw	r24, 0x26	; 38
     1c0:	08 95       	ret

000001c2 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     1c2:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     1c6:	89 ef       	ldi	r24, 0xF9	; 249
     1c8:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     1cc:	8b e0       	ldi	r24, 0x0B	; 11
     1ce:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     1d2:	ef e6       	ldi	r30, 0x6F	; 111
     1d4:	f0 e0       	ldi	r31, 0x00	; 0
     1d6:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     1d8:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
     1da:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     1dc:	a0 91 c7 04 	lds	r26, 0x04C7
     1e0:	b0 91 c8 04 	lds	r27, 0x04C8
     1e4:	cd 91       	ld	r28, X+
     1e6:	cd bf       	out	0x3d, r28	; 61
     1e8:	dd 91       	ld	r29, X+
     1ea:	de bf       	out	0x3e, r29	; 62
     1ec:	ff 91       	pop	r31
     1ee:	ef 91       	pop	r30
     1f0:	df 91       	pop	r29
     1f2:	cf 91       	pop	r28
     1f4:	bf 91       	pop	r27
     1f6:	af 91       	pop	r26
     1f8:	9f 91       	pop	r25
     1fa:	8f 91       	pop	r24
     1fc:	7f 91       	pop	r23
     1fe:	6f 91       	pop	r22
     200:	5f 91       	pop	r21
     202:	4f 91       	pop	r20
     204:	3f 91       	pop	r19
     206:	2f 91       	pop	r18
     208:	1f 91       	pop	r17
     20a:	0f 91       	pop	r16
     20c:	ff 90       	pop	r15
     20e:	ef 90       	pop	r14
     210:	df 90       	pop	r13
     212:	cf 90       	pop	r12
     214:	bf 90       	pop	r11
     216:	af 90       	pop	r10
     218:	9f 90       	pop	r9
     21a:	8f 90       	pop	r8
     21c:	7f 90       	pop	r7
     21e:	6f 90       	pop	r6
     220:	5f 90       	pop	r5
     222:	4f 90       	pop	r4
     224:	3f 90       	pop	r3
     226:	2f 90       	pop	r2
     228:	1f 90       	pop	r1
     22a:	0f 90       	pop	r0
     22c:	0f be       	out	0x3f, r0	; 63
     22e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     230:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     232:	81 e0       	ldi	r24, 0x01	; 1
     234:	08 95       	ret

00000236 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     236:	0f 92       	push	r0
     238:	0f b6       	in	r0, 0x3f	; 63
     23a:	f8 94       	cli
     23c:	0f 92       	push	r0
     23e:	1f 92       	push	r1
     240:	11 24       	eor	r1, r1
     242:	2f 92       	push	r2
     244:	3f 92       	push	r3
     246:	4f 92       	push	r4
     248:	5f 92       	push	r5
     24a:	6f 92       	push	r6
     24c:	7f 92       	push	r7
     24e:	8f 92       	push	r8
     250:	9f 92       	push	r9
     252:	af 92       	push	r10
     254:	bf 92       	push	r11
     256:	cf 92       	push	r12
     258:	df 92       	push	r13
     25a:	ef 92       	push	r14
     25c:	ff 92       	push	r15
     25e:	0f 93       	push	r16
     260:	1f 93       	push	r17
     262:	2f 93       	push	r18
     264:	3f 93       	push	r19
     266:	4f 93       	push	r20
     268:	5f 93       	push	r21
     26a:	6f 93       	push	r22
     26c:	7f 93       	push	r23
     26e:	8f 93       	push	r24
     270:	9f 93       	push	r25
     272:	af 93       	push	r26
     274:	bf 93       	push	r27
     276:	cf 93       	push	r28
     278:	df 93       	push	r29
     27a:	ef 93       	push	r30
     27c:	ff 93       	push	r31
     27e:	a0 91 c7 04 	lds	r26, 0x04C7
     282:	b0 91 c8 04 	lds	r27, 0x04C8
     286:	0d b6       	in	r0, 0x3d	; 61
     288:	0d 92       	st	X+, r0
     28a:	0e b6       	in	r0, 0x3e	; 62
     28c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     28e:	0e 94 7f 05 	call	0xafe	; 0xafe <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     292:	a0 91 c7 04 	lds	r26, 0x04C7
     296:	b0 91 c8 04 	lds	r27, 0x04C8
     29a:	cd 91       	ld	r28, X+
     29c:	cd bf       	out	0x3d, r28	; 61
     29e:	dd 91       	ld	r29, X+
     2a0:	de bf       	out	0x3e, r29	; 62
     2a2:	ff 91       	pop	r31
     2a4:	ef 91       	pop	r30
     2a6:	df 91       	pop	r29
     2a8:	cf 91       	pop	r28
     2aa:	bf 91       	pop	r27
     2ac:	af 91       	pop	r26
     2ae:	9f 91       	pop	r25
     2b0:	8f 91       	pop	r24
     2b2:	7f 91       	pop	r23
     2b4:	6f 91       	pop	r22
     2b6:	5f 91       	pop	r21
     2b8:	4f 91       	pop	r20
     2ba:	3f 91       	pop	r19
     2bc:	2f 91       	pop	r18
     2be:	1f 91       	pop	r17
     2c0:	0f 91       	pop	r16
     2c2:	ff 90       	pop	r15
     2c4:	ef 90       	pop	r14
     2c6:	df 90       	pop	r13
     2c8:	cf 90       	pop	r12
     2ca:	bf 90       	pop	r11
     2cc:	af 90       	pop	r10
     2ce:	9f 90       	pop	r9
     2d0:	8f 90       	pop	r8
     2d2:	7f 90       	pop	r7
     2d4:	6f 90       	pop	r6
     2d6:	5f 90       	pop	r5
     2d8:	4f 90       	pop	r4
     2da:	3f 90       	pop	r3
     2dc:	2f 90       	pop	r2
     2de:	1f 90       	pop	r1
     2e0:	0f 90       	pop	r0
     2e2:	0f be       	out	0x3f, r0	; 63
     2e4:	0f 90       	pop	r0

	asm volatile ( "ret" );
     2e6:	08 95       	ret

000002e8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     2e8:	0f 92       	push	r0
     2ea:	0f b6       	in	r0, 0x3f	; 63
     2ec:	f8 94       	cli
     2ee:	0f 92       	push	r0
     2f0:	1f 92       	push	r1
     2f2:	11 24       	eor	r1, r1
     2f4:	2f 92       	push	r2
     2f6:	3f 92       	push	r3
     2f8:	4f 92       	push	r4
     2fa:	5f 92       	push	r5
     2fc:	6f 92       	push	r6
     2fe:	7f 92       	push	r7
     300:	8f 92       	push	r8
     302:	9f 92       	push	r9
     304:	af 92       	push	r10
     306:	bf 92       	push	r11
     308:	cf 92       	push	r12
     30a:	df 92       	push	r13
     30c:	ef 92       	push	r14
     30e:	ff 92       	push	r15
     310:	0f 93       	push	r16
     312:	1f 93       	push	r17
     314:	2f 93       	push	r18
     316:	3f 93       	push	r19
     318:	4f 93       	push	r20
     31a:	5f 93       	push	r21
     31c:	6f 93       	push	r22
     31e:	7f 93       	push	r23
     320:	8f 93       	push	r24
     322:	9f 93       	push	r25
     324:	af 93       	push	r26
     326:	bf 93       	push	r27
     328:	cf 93       	push	r28
     32a:	df 93       	push	r29
     32c:	ef 93       	push	r30
     32e:	ff 93       	push	r31
     330:	a0 91 c7 04 	lds	r26, 0x04C7
     334:	b0 91 c8 04 	lds	r27, 0x04C8
     338:	0d b6       	in	r0, 0x3d	; 61
     33a:	0d 92       	st	X+, r0
     33c:	0e b6       	in	r0, 0x3e	; 62
     33e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     340:	0e 94 04 04 	call	0x808	; 0x808 <xTaskIncrementTick>
     344:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     346:	0e 94 7f 05 	call	0xafe	; 0xafe <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     34a:	a0 91 c7 04 	lds	r26, 0x04C7
     34e:	b0 91 c8 04 	lds	r27, 0x04C8
     352:	cd 91       	ld	r28, X+
     354:	cd bf       	out	0x3d, r28	; 61
     356:	dd 91       	ld	r29, X+
     358:	de bf       	out	0x3e, r29	; 62
     35a:	ff 91       	pop	r31
     35c:	ef 91       	pop	r30
     35e:	df 91       	pop	r29
     360:	cf 91       	pop	r28
     362:	bf 91       	pop	r27
     364:	af 91       	pop	r26
     366:	9f 91       	pop	r25
     368:	8f 91       	pop	r24
     36a:	7f 91       	pop	r23
     36c:	6f 91       	pop	r22
     36e:	5f 91       	pop	r21
     370:	4f 91       	pop	r20
     372:	3f 91       	pop	r19
     374:	2f 91       	pop	r18
     376:	1f 91       	pop	r17
     378:	0f 91       	pop	r16
     37a:	ff 90       	pop	r15
     37c:	ef 90       	pop	r14
     37e:	df 90       	pop	r13
     380:	cf 90       	pop	r12
     382:	bf 90       	pop	r11
     384:	af 90       	pop	r10
     386:	9f 90       	pop	r9
     388:	8f 90       	pop	r8
     38a:	7f 90       	pop	r7
     38c:	6f 90       	pop	r6
     38e:	5f 90       	pop	r5
     390:	4f 90       	pop	r4
     392:	3f 90       	pop	r3
     394:	2f 90       	pop	r2
     396:	1f 90       	pop	r1
     398:	0f 90       	pop	r0
     39a:	0f be       	out	0x3f, r0	; 63
     39c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     39e:	08 95       	ret

000003a0 <__vector_17>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     3a0:	0e 94 74 01 	call	0x2e8	; 0x2e8 <vPortYieldFromTick>
		asm volatile ( "reti" );
     3a4:	18 95       	reti

000003a6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     3a6:	cf 93       	push	r28
     3a8:	df 93       	push	r29
     3aa:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     3ac:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     3b0:	80 91 24 01 	lds	r24, 0x0124
     3b4:	90 91 25 01 	lds	r25, 0x0125
     3b8:	89 2b       	or	r24, r25
     3ba:	31 f4       	brne	.+12     	; 0x3c8 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     3bc:	89 e2       	ldi	r24, 0x29	; 41
     3be:	91 e0       	ldi	r25, 0x01	; 1
     3c0:	90 93 25 01 	sts	0x0125, r25
     3c4:	80 93 24 01 	sts	0x0124, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     3c8:	20 91 26 01 	lds	r18, 0x0126
     3cc:	30 91 27 01 	lds	r19, 0x0127
     3d0:	ce 01       	movw	r24, r28
     3d2:	82 0f       	add	r24, r18
     3d4:	93 1f       	adc	r25, r19
     3d6:	81 35       	cpi	r24, 0x51	; 81
     3d8:	43 e0       	ldi	r20, 0x03	; 3
     3da:	94 07       	cpc	r25, r20
     3dc:	70 f4       	brcc	.+28     	; 0x3fa <pvPortMalloc+0x54>
     3de:	28 17       	cp	r18, r24
     3e0:	39 07       	cpc	r19, r25
     3e2:	70 f4       	brcc	.+28     	; 0x400 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     3e4:	c0 91 24 01 	lds	r28, 0x0124
     3e8:	d0 91 25 01 	lds	r29, 0x0125
     3ec:	c2 0f       	add	r28, r18
     3ee:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     3f0:	90 93 27 01 	sts	0x0127, r25
     3f4:	80 93 26 01 	sts	0x0126, r24
     3f8:	05 c0       	rjmp	.+10     	; 0x404 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     3fa:	c0 e0       	ldi	r28, 0x00	; 0
     3fc:	d0 e0       	ldi	r29, 0x00	; 0
     3fe:	02 c0       	rjmp	.+4      	; 0x404 <pvPortMalloc+0x5e>
     400:	c0 e0       	ldi	r28, 0x00	; 0
     402:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     404:	0e 94 dd 04 	call	0x9ba	; 0x9ba <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     408:	ce 01       	movw	r24, r28
     40a:	df 91       	pop	r29
     40c:	cf 91       	pop	r28
     40e:	08 95       	ret

00000410 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     410:	08 95       	ret

00000412 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     412:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     414:	03 96       	adiw	r24, 0x03	; 3
     416:	92 83       	std	Z+2, r25	; 0x02
     418:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     41a:	2f ef       	ldi	r18, 0xFF	; 255
     41c:	3f ef       	ldi	r19, 0xFF	; 255
     41e:	34 83       	std	Z+4, r19	; 0x04
     420:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     422:	96 83       	std	Z+6, r25	; 0x06
     424:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     426:	90 87       	std	Z+8, r25	; 0x08
     428:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     42a:	10 82       	st	Z, r1
     42c:	08 95       	ret

0000042e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     42e:	fc 01       	movw	r30, r24
     430:	11 86       	std	Z+9, r1	; 0x09
     432:	10 86       	std	Z+8, r1	; 0x08
     434:	08 95       	ret

00000436 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     436:	cf 93       	push	r28
     438:	df 93       	push	r29
     43a:	9c 01       	movw	r18, r24
     43c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     43e:	dc 01       	movw	r26, r24
     440:	11 96       	adiw	r26, 0x01	; 1
     442:	cd 91       	ld	r28, X+
     444:	dc 91       	ld	r29, X
     446:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     448:	d3 83       	std	Z+3, r29	; 0x03
     44a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     44c:	8c 81       	ldd	r24, Y+4	; 0x04
     44e:	9d 81       	ldd	r25, Y+5	; 0x05
     450:	95 83       	std	Z+5, r25	; 0x05
     452:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     454:	8c 81       	ldd	r24, Y+4	; 0x04
     456:	9d 81       	ldd	r25, Y+5	; 0x05
     458:	dc 01       	movw	r26, r24
     45a:	13 96       	adiw	r26, 0x03	; 3
     45c:	7c 93       	st	X, r23
     45e:	6e 93       	st	-X, r22
     460:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     462:	7d 83       	std	Y+5, r23	; 0x05
     464:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     466:	31 87       	std	Z+9, r19	; 0x09
     468:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     46a:	f9 01       	movw	r30, r18
     46c:	80 81       	ld	r24, Z
     46e:	8f 5f       	subi	r24, 0xFF	; 255
     470:	80 83       	st	Z, r24
}
     472:	df 91       	pop	r29
     474:	cf 91       	pop	r28
     476:	08 95       	ret

00000478 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     478:	cf 93       	push	r28
     47a:	df 93       	push	r29
     47c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     47e:	48 81       	ld	r20, Y
     480:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     482:	4f 3f       	cpi	r20, 0xFF	; 255
     484:	2f ef       	ldi	r18, 0xFF	; 255
     486:	52 07       	cpc	r21, r18
     488:	21 f4       	brne	.+8      	; 0x492 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     48a:	fc 01       	movw	r30, r24
     48c:	a7 81       	ldd	r26, Z+7	; 0x07
     48e:	b0 85       	ldd	r27, Z+8	; 0x08
     490:	0d c0       	rjmp	.+26     	; 0x4ac <vListInsert+0x34>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     492:	dc 01       	movw	r26, r24
     494:	13 96       	adiw	r26, 0x03	; 3
     496:	01 c0       	rjmp	.+2      	; 0x49a <vListInsert+0x22>
     498:	df 01       	movw	r26, r30
     49a:	12 96       	adiw	r26, 0x02	; 2
     49c:	ed 91       	ld	r30, X+
     49e:	fc 91       	ld	r31, X
     4a0:	13 97       	sbiw	r26, 0x03	; 3
     4a2:	20 81       	ld	r18, Z
     4a4:	31 81       	ldd	r19, Z+1	; 0x01
     4a6:	42 17       	cp	r20, r18
     4a8:	53 07       	cpc	r21, r19
     4aa:	b0 f7       	brcc	.-20     	; 0x498 <vListInsert+0x20>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     4ac:	12 96       	adiw	r26, 0x02	; 2
     4ae:	ed 91       	ld	r30, X+
     4b0:	fc 91       	ld	r31, X
     4b2:	13 97       	sbiw	r26, 0x03	; 3
     4b4:	fb 83       	std	Y+3, r31	; 0x03
     4b6:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     4b8:	d5 83       	std	Z+5, r29	; 0x05
     4ba:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     4bc:	bd 83       	std	Y+5, r27	; 0x05
     4be:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     4c0:	13 96       	adiw	r26, 0x03	; 3
     4c2:	dc 93       	st	X, r29
     4c4:	ce 93       	st	-X, r28
     4c6:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     4c8:	99 87       	std	Y+9, r25	; 0x09
     4ca:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     4cc:	fc 01       	movw	r30, r24
     4ce:	20 81       	ld	r18, Z
     4d0:	2f 5f       	subi	r18, 0xFF	; 255
     4d2:	20 83       	st	Z, r18
}
     4d4:	df 91       	pop	r29
     4d6:	cf 91       	pop	r28
     4d8:	08 95       	ret

000004da <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     4da:	cf 93       	push	r28
     4dc:	df 93       	push	r29
     4de:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     4e0:	a0 85       	ldd	r26, Z+8	; 0x08
     4e2:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     4e4:	c2 81       	ldd	r28, Z+2	; 0x02
     4e6:	d3 81       	ldd	r29, Z+3	; 0x03
     4e8:	84 81       	ldd	r24, Z+4	; 0x04
     4ea:	95 81       	ldd	r25, Z+5	; 0x05
     4ec:	9d 83       	std	Y+5, r25	; 0x05
     4ee:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     4f0:	c4 81       	ldd	r28, Z+4	; 0x04
     4f2:	d5 81       	ldd	r29, Z+5	; 0x05
     4f4:	82 81       	ldd	r24, Z+2	; 0x02
     4f6:	93 81       	ldd	r25, Z+3	; 0x03
     4f8:	9b 83       	std	Y+3, r25	; 0x03
     4fa:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     4fc:	11 96       	adiw	r26, 0x01	; 1
     4fe:	cd 91       	ld	r28, X+
     500:	dc 91       	ld	r29, X
     502:	12 97       	sbiw	r26, 0x02	; 2
     504:	ce 17       	cp	r28, r30
     506:	df 07       	cpc	r29, r31
     508:	31 f4       	brne	.+12     	; 0x516 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     50a:	8c 81       	ldd	r24, Y+4	; 0x04
     50c:	9d 81       	ldd	r25, Y+5	; 0x05
     50e:	12 96       	adiw	r26, 0x02	; 2
     510:	9c 93       	st	X, r25
     512:	8e 93       	st	-X, r24
     514:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     516:	11 86       	std	Z+9, r1	; 0x09
     518:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     51a:	8c 91       	ld	r24, X
     51c:	81 50       	subi	r24, 0x01	; 1
     51e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     520:	df 91       	pop	r29
     522:	cf 91       	pop	r28
     524:	08 95       	ret

00000526 <prvIdleTask>:
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
     526:	ff cf       	rjmp	.-2      	; 0x526 <prvIdleTask>

00000528 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
     528:	cf 93       	push	r28
     52a:	df 93       	push	r29
     52c:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     52e:	e0 91 c7 04 	lds	r30, 0x04C7
     532:	f0 91 c8 04 	lds	r31, 0x04C8
     536:	93 83       	std	Z+3, r25	; 0x03
     538:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     53a:	80 91 81 04 	lds	r24, 0x0481
     53e:	90 91 82 04 	lds	r25, 0x0482
     542:	c8 17       	cp	r28, r24
     544:	d9 07       	cpc	r29, r25
     546:	68 f4       	brcc	.+26     	; 0x562 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     548:	60 91 c7 04 	lds	r22, 0x04C7
     54c:	70 91 c8 04 	lds	r23, 0x04C8
     550:	80 91 8d 04 	lds	r24, 0x048D
     554:	90 91 8e 04 	lds	r25, 0x048E
     558:	6e 5f       	subi	r22, 0xFE	; 254
     55a:	7f 4f       	sbci	r23, 0xFF	; 255
     55c:	0e 94 3c 02 	call	0x478	; 0x478 <vListInsert>
     560:	17 c0       	rjmp	.+46     	; 0x590 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     562:	60 91 c7 04 	lds	r22, 0x04C7
     566:	70 91 c8 04 	lds	r23, 0x04C8
     56a:	80 91 8f 04 	lds	r24, 0x048F
     56e:	90 91 90 04 	lds	r25, 0x0490
     572:	6e 5f       	subi	r22, 0xFE	; 254
     574:	7f 4f       	sbci	r23, 0xFF	; 255
     576:	0e 94 3c 02 	call	0x478	; 0x478 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     57a:	80 91 00 01 	lds	r24, 0x0100
     57e:	90 91 01 01 	lds	r25, 0x0101
     582:	c8 17       	cp	r28, r24
     584:	d9 07       	cpc	r29, r25
     586:	20 f4       	brcc	.+8      	; 0x590 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
     588:	d0 93 01 01 	sts	0x0101, r29
     58c:	c0 93 00 01 	sts	0x0100, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     590:	df 91       	pop	r29
     592:	cf 91       	pop	r28
     594:	08 95       	ret

00000596 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
     596:	4f 92       	push	r4
     598:	5f 92       	push	r5
     59a:	6f 92       	push	r6
     59c:	7f 92       	push	r7
     59e:	8f 92       	push	r8
     5a0:	9f 92       	push	r9
     5a2:	af 92       	push	r10
     5a4:	bf 92       	push	r11
     5a6:	cf 92       	push	r12
     5a8:	df 92       	push	r13
     5aa:	ef 92       	push	r14
     5ac:	ff 92       	push	r15
     5ae:	0f 93       	push	r16
     5b0:	1f 93       	push	r17
     5b2:	cf 93       	push	r28
     5b4:	df 93       	push	r29
     5b6:	4c 01       	movw	r8, r24
     5b8:	eb 01       	movw	r28, r22
     5ba:	5a 01       	movw	r10, r20
     5bc:	29 01       	movw	r4, r18
{
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     5be:	81 e2       	ldi	r24, 0x21	; 33
     5c0:	90 e0       	ldi	r25, 0x00	; 0
     5c2:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <pvPortMalloc>
     5c6:	3c 01       	movw	r6, r24

	if( pxNewTCB != NULL )
     5c8:	00 97       	sbiw	r24, 0x00	; 0
     5ca:	09 f4       	brne	.+2      	; 0x5ce <xTaskGenericCreate+0x38>
     5cc:	da c0       	rjmp	.+436    	; 0x782 <xTaskGenericCreate+0x1ec>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     5ce:	c1 14       	cp	r12, r1
     5d0:	d1 04       	cpc	r13, r1
     5d2:	09 f0       	breq	.+2      	; 0x5d6 <xTaskGenericCreate+0x40>
     5d4:	d2 c0       	rjmp	.+420    	; 0x77a <xTaskGenericCreate+0x1e4>
     5d6:	c5 01       	movw	r24, r10
     5d8:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <pvPortMalloc>
     5dc:	f3 01       	movw	r30, r6
     5de:	90 8f       	std	Z+24, r25	; 0x18
     5e0:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
     5e2:	89 2b       	or	r24, r25
     5e4:	21 f4       	brne	.+8      	; 0x5ee <xTaskGenericCreate+0x58>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
     5e6:	c3 01       	movw	r24, r6
     5e8:	0e 94 08 02 	call	0x410	; 0x410 <vPortFree>
     5ec:	ca c0       	rjmp	.+404    	; 0x782 <xTaskGenericCreate+0x1ec>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
     5ee:	f1 e0       	ldi	r31, 0x01	; 1
     5f0:	af 1a       	sub	r10, r31
     5f2:	b1 08       	sbc	r11, r1
     5f4:	f3 01       	movw	r30, r6
     5f6:	87 89       	ldd	r24, Z+23	; 0x17
     5f8:	90 8d       	ldd	r25, Z+24	; 0x18
     5fa:	a8 0e       	add	r10, r24
     5fc:	b9 1e       	adc	r11, r25
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     5fe:	88 81       	ld	r24, Y
     600:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     602:	88 81       	ld	r24, Y
     604:	88 23       	and	r24, r24
     606:	81 f0       	breq	.+32     	; 0x628 <xTaskGenericCreate+0x92>
     608:	d3 01       	movw	r26, r6
     60a:	5a 96       	adiw	r26, 0x1a	; 26
     60c:	fe 01       	movw	r30, r28
     60e:	31 96       	adiw	r30, 0x01	; 1
     610:	9e 01       	movw	r18, r28
     612:	28 5f       	subi	r18, 0xF8	; 248
     614:	3f 4f       	sbci	r19, 0xFF	; 255
     616:	ef 01       	movw	r28, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     618:	81 91       	ld	r24, Z+
     61a:	8d 93       	st	X+, r24

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     61c:	88 81       	ld	r24, Y
     61e:	88 23       	and	r24, r24
     620:	19 f0       	breq	.+6      	; 0x628 <xTaskGenericCreate+0x92>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     622:	e2 17       	cp	r30, r18
     624:	f3 07       	cpc	r31, r19
     626:	b9 f7       	brne	.-18     	; 0x616 <xTaskGenericCreate+0x80>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     628:	f3 01       	movw	r30, r6
     62a:	10 a2       	std	Z+32, r1	; 0x20
     62c:	10 2f       	mov	r17, r16
     62e:	04 30       	cpi	r16, 0x04	; 4
     630:	08 f0       	brcs	.+2      	; 0x634 <xTaskGenericCreate+0x9e>
     632:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
     634:	f3 01       	movw	r30, r6
     636:	16 8b       	std	Z+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     638:	e3 01       	movw	r28, r6
     63a:	22 96       	adiw	r28, 0x02	; 2
     63c:	ce 01       	movw	r24, r28
     63e:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     642:	c3 01       	movw	r24, r6
     644:	0c 96       	adiw	r24, 0x0c	; 12
     646:	0e 94 17 02 	call	0x42e	; 0x42e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     64a:	f3 01       	movw	r30, r6
     64c:	71 86       	std	Z+9, r7	; 0x09
     64e:	60 86       	std	Z+8, r6	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     650:	84 e0       	ldi	r24, 0x04	; 4
     652:	90 e0       	ldi	r25, 0x00	; 0
     654:	81 1b       	sub	r24, r17
     656:	91 09       	sbc	r25, r1
     658:	95 87       	std	Z+13, r25	; 0x0d
     65a:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     65c:	73 8a       	std	Z+19, r7	; 0x13
     65e:	62 8a       	std	Z+18, r6	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     660:	a2 01       	movw	r20, r4
     662:	b4 01       	movw	r22, r8
     664:	c5 01       	movw	r24, r10
     666:	0e 94 75 00 	call	0xea	; 0xea <pxPortInitialiseStack>
     66a:	f3 01       	movw	r30, r6
     66c:	91 83       	std	Z+1, r25	; 0x01
     66e:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     670:	e1 14       	cp	r14, r1
     672:	f1 04       	cpc	r15, r1
     674:	19 f0       	breq	.+6      	; 0x67c <xTaskGenericCreate+0xe6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     676:	f7 01       	movw	r30, r14
     678:	71 82       	std	Z+1, r7	; 0x01
     67a:	60 82       	st	Z, r6
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     67c:	0f b6       	in	r0, 0x3f	; 63
     67e:	f8 94       	cli
     680:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     682:	80 91 83 04 	lds	r24, 0x0483
     686:	8f 5f       	subi	r24, 0xFF	; 255
     688:	80 93 83 04 	sts	0x0483, r24
			if( pxCurrentTCB == NULL )
     68c:	80 91 c7 04 	lds	r24, 0x04C7
     690:	90 91 c8 04 	lds	r25, 0x04C8
     694:	89 2b       	or	r24, r25
     696:	89 f5       	brne	.+98     	; 0x6fa <xTaskGenericCreate+0x164>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     698:	70 92 c8 04 	sts	0x04C8, r7
     69c:	60 92 c7 04 	sts	0x04C7, r6

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     6a0:	80 91 83 04 	lds	r24, 0x0483
     6a4:	81 30       	cpi	r24, 0x01	; 1
     6a6:	c1 f5       	brne	.+112    	; 0x718 <xTaskGenericCreate+0x182>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     6a8:	83 ea       	ldi	r24, 0xA3	; 163
     6aa:	94 e0       	ldi	r25, 0x04	; 4
     6ac:	0e 94 09 02 	call	0x412	; 0x412 <vListInitialise>
     6b0:	8c ea       	ldi	r24, 0xAC	; 172
     6b2:	94 e0       	ldi	r25, 0x04	; 4
     6b4:	0e 94 09 02 	call	0x412	; 0x412 <vListInitialise>
     6b8:	85 eb       	ldi	r24, 0xB5	; 181
     6ba:	94 e0       	ldi	r25, 0x04	; 4
     6bc:	0e 94 09 02 	call	0x412	; 0x412 <vListInitialise>
     6c0:	8e eb       	ldi	r24, 0xBE	; 190
     6c2:	94 e0       	ldi	r25, 0x04	; 4
     6c4:	0e 94 09 02 	call	0x412	; 0x412 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     6c8:	8a e9       	ldi	r24, 0x9A	; 154
     6ca:	94 e0       	ldi	r25, 0x04	; 4
     6cc:	0e 94 09 02 	call	0x412	; 0x412 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     6d0:	81 e9       	ldi	r24, 0x91	; 145
     6d2:	94 e0       	ldi	r25, 0x04	; 4
     6d4:	0e 94 09 02 	call	0x412	; 0x412 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     6d8:	84 e8       	ldi	r24, 0x84	; 132
     6da:	94 e0       	ldi	r25, 0x04	; 4
     6dc:	0e 94 09 02 	call	0x412	; 0x412 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     6e0:	8a e9       	ldi	r24, 0x9A	; 154
     6e2:	94 e0       	ldi	r25, 0x04	; 4
     6e4:	90 93 90 04 	sts	0x0490, r25
     6e8:	80 93 8f 04 	sts	0x048F, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     6ec:	81 e9       	ldi	r24, 0x91	; 145
     6ee:	94 e0       	ldi	r25, 0x04	; 4
     6f0:	90 93 8e 04 	sts	0x048E, r25
     6f4:	80 93 8d 04 	sts	0x048D, r24
     6f8:	0f c0       	rjmp	.+30     	; 0x718 <xTaskGenericCreate+0x182>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     6fa:	80 91 7f 04 	lds	r24, 0x047F
     6fe:	81 11       	cpse	r24, r1
     700:	0b c0       	rjmp	.+22     	; 0x718 <xTaskGenericCreate+0x182>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     702:	e0 91 c7 04 	lds	r30, 0x04C7
     706:	f0 91 c8 04 	lds	r31, 0x04C8
     70a:	86 89       	ldd	r24, Z+22	; 0x16
     70c:	08 17       	cp	r16, r24
     70e:	20 f0       	brcs	.+8      	; 0x718 <xTaskGenericCreate+0x182>
					{
						pxCurrentTCB = pxNewTCB;
     710:	70 92 c8 04 	sts	0x04C8, r7
     714:	60 92 c7 04 	sts	0x04C7, r6
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
     718:	80 91 7b 04 	lds	r24, 0x047B
     71c:	8f 5f       	subi	r24, 0xFF	; 255
     71e:	80 93 7b 04 	sts	0x047B, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     722:	f3 01       	movw	r30, r6
     724:	86 89       	ldd	r24, Z+22	; 0x16
     726:	90 91 80 04 	lds	r25, 0x0480
     72a:	98 17       	cp	r25, r24
     72c:	10 f4       	brcc	.+4      	; 0x732 <xTaskGenericCreate+0x19c>
     72e:	80 93 80 04 	sts	0x0480, r24
     732:	90 e0       	ldi	r25, 0x00	; 0
     734:	9c 01       	movw	r18, r24
     736:	22 0f       	add	r18, r18
     738:	33 1f       	adc	r19, r19
     73a:	22 0f       	add	r18, r18
     73c:	33 1f       	adc	r19, r19
     73e:	22 0f       	add	r18, r18
     740:	33 1f       	adc	r19, r19
     742:	82 0f       	add	r24, r18
     744:	93 1f       	adc	r25, r19
     746:	be 01       	movw	r22, r28
     748:	8d 55       	subi	r24, 0x5D	; 93
     74a:	9b 4f       	sbci	r25, 0xFB	; 251
     74c:	0e 94 1b 02 	call	0x436	; 0x436 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     750:	0f 90       	pop	r0
     752:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
     754:	80 91 7f 04 	lds	r24, 0x047F
     758:	88 23       	and	r24, r24
     75a:	59 f0       	breq	.+22     	; 0x772 <xTaskGenericCreate+0x1dc>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     75c:	e0 91 c7 04 	lds	r30, 0x04C7
     760:	f0 91 c8 04 	lds	r31, 0x04C8
     764:	86 89       	ldd	r24, Z+22	; 0x16
     766:	80 17       	cp	r24, r16
     768:	30 f4       	brcc	.+12     	; 0x776 <xTaskGenericCreate+0x1e0>
			{
				taskYIELD_IF_USING_PREEMPTION();
     76a:	0e 94 1b 01 	call	0x236	; 0x236 <vPortYield>
     76e:	81 e0       	ldi	r24, 0x01	; 1
     770:	09 c0       	rjmp	.+18     	; 0x784 <xTaskGenericCreate+0x1ee>
     772:	81 e0       	ldi	r24, 0x01	; 1
     774:	07 c0       	rjmp	.+14     	; 0x784 <xTaskGenericCreate+0x1ee>
     776:	81 e0       	ldi	r24, 0x01	; 1
     778:	05 c0       	rjmp	.+10     	; 0x784 <xTaskGenericCreate+0x1ee>
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     77a:	fc 01       	movw	r30, r24
     77c:	d0 8e       	std	Z+24, r13	; 0x18
     77e:	c7 8a       	std	Z+23, r12	; 0x17
     780:	36 cf       	rjmp	.-404    	; 0x5ee <xTaskGenericCreate+0x58>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     782:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
     784:	df 91       	pop	r29
     786:	cf 91       	pop	r28
     788:	1f 91       	pop	r17
     78a:	0f 91       	pop	r16
     78c:	ff 90       	pop	r15
     78e:	ef 90       	pop	r14
     790:	df 90       	pop	r13
     792:	cf 90       	pop	r12
     794:	bf 90       	pop	r11
     796:	af 90       	pop	r10
     798:	9f 90       	pop	r9
     79a:	8f 90       	pop	r8
     79c:	7f 90       	pop	r7
     79e:	6f 90       	pop	r6
     7a0:	5f 90       	pop	r5
     7a2:	4f 90       	pop	r4
     7a4:	08 95       	ret

000007a6 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     7a6:	af 92       	push	r10
     7a8:	bf 92       	push	r11
     7aa:	cf 92       	push	r12
     7ac:	df 92       	push	r13
     7ae:	ef 92       	push	r14
     7b0:	ff 92       	push	r15
     7b2:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     7b4:	a1 2c       	mov	r10, r1
     7b6:	b1 2c       	mov	r11, r1
     7b8:	c1 2c       	mov	r12, r1
     7ba:	d1 2c       	mov	r13, r1
     7bc:	e1 2c       	mov	r14, r1
     7be:	f1 2c       	mov	r15, r1
     7c0:	00 e0       	ldi	r16, 0x00	; 0
     7c2:	20 e0       	ldi	r18, 0x00	; 0
     7c4:	30 e0       	ldi	r19, 0x00	; 0
     7c6:	45 e5       	ldi	r20, 0x55	; 85
     7c8:	50 e0       	ldi	r21, 0x00	; 0
     7ca:	62 e0       	ldi	r22, 0x02	; 2
     7cc:	71 e0       	ldi	r23, 0x01	; 1
     7ce:	83 e9       	ldi	r24, 0x93	; 147
     7d0:	92 e0       	ldi	r25, 0x02	; 2
     7d2:	0e 94 cb 02 	call	0x596	; 0x596 <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     7d6:	81 30       	cpi	r24, 0x01	; 1
     7d8:	49 f4       	brne	.+18     	; 0x7ec <vTaskStartScheduler+0x46>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     7da:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
     7dc:	80 93 7f 04 	sts	0x047F, r24
		xTickCount = ( TickType_t ) 0U;
     7e0:	10 92 82 04 	sts	0x0482, r1
     7e4:	10 92 81 04 	sts	0x0481, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     7e8:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     7ec:	0f 91       	pop	r16
     7ee:	ff 90       	pop	r15
     7f0:	ef 90       	pop	r14
     7f2:	df 90       	pop	r13
     7f4:	cf 90       	pop	r12
     7f6:	bf 90       	pop	r11
     7f8:	af 90       	pop	r10
     7fa:	08 95       	ret

000007fc <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     7fc:	80 91 7a 04 	lds	r24, 0x047A
     800:	8f 5f       	subi	r24, 0xFF	; 255
     802:	80 93 7a 04 	sts	0x047A, r24
     806:	08 95       	ret

00000808 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     808:	cf 92       	push	r12
     80a:	df 92       	push	r13
     80c:	ef 92       	push	r14
     80e:	ff 92       	push	r15
     810:	0f 93       	push	r16
     812:	1f 93       	push	r17
     814:	cf 93       	push	r28
     816:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     818:	80 91 7a 04 	lds	r24, 0x047A
     81c:	81 11       	cpse	r24, r1
     81e:	b7 c0       	rjmp	.+366    	; 0x98e <xTaskIncrementTick+0x186>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     820:	80 91 81 04 	lds	r24, 0x0481
     824:	90 91 82 04 	lds	r25, 0x0482
     828:	01 96       	adiw	r24, 0x01	; 1
     82a:	90 93 82 04 	sts	0x0482, r25
     82e:	80 93 81 04 	sts	0x0481, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     832:	e0 90 81 04 	lds	r14, 0x0481
     836:	f0 90 82 04 	lds	r15, 0x0482

			if( xConstTickCount == ( TickType_t ) 0U )
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	99 f5       	brne	.+102    	; 0x8a6 <xTaskIncrementTick+0x9e>
			{
				taskSWITCH_DELAYED_LISTS();
     840:	80 91 8f 04 	lds	r24, 0x048F
     844:	90 91 90 04 	lds	r25, 0x0490
     848:	20 91 8d 04 	lds	r18, 0x048D
     84c:	30 91 8e 04 	lds	r19, 0x048E
     850:	30 93 90 04 	sts	0x0490, r19
     854:	20 93 8f 04 	sts	0x048F, r18
     858:	90 93 8e 04 	sts	0x048E, r25
     85c:	80 93 8d 04 	sts	0x048D, r24
     860:	80 91 7c 04 	lds	r24, 0x047C
     864:	8f 5f       	subi	r24, 0xFF	; 255
     866:	80 93 7c 04 	sts	0x047C, r24

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     86a:	e0 91 8f 04 	lds	r30, 0x048F
     86e:	f0 91 90 04 	lds	r31, 0x0490
     872:	80 81       	ld	r24, Z
     874:	81 11       	cpse	r24, r1
     876:	07 c0       	rjmp	.+14     	; 0x886 <xTaskIncrementTick+0x7e>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     878:	8f ef       	ldi	r24, 0xFF	; 255
     87a:	9f ef       	ldi	r25, 0xFF	; 255
     87c:	90 93 01 01 	sts	0x0101, r25
     880:	80 93 00 01 	sts	0x0100, r24
     884:	10 c0       	rjmp	.+32     	; 0x8a6 <xTaskIncrementTick+0x9e>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     886:	e0 91 8f 04 	lds	r30, 0x048F
     88a:	f0 91 90 04 	lds	r31, 0x0490
     88e:	05 80       	ldd	r0, Z+5	; 0x05
     890:	f6 81       	ldd	r31, Z+6	; 0x06
     892:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
     894:	06 80       	ldd	r0, Z+6	; 0x06
     896:	f7 81       	ldd	r31, Z+7	; 0x07
     898:	e0 2d       	mov	r30, r0
     89a:	82 81       	ldd	r24, Z+2	; 0x02
     89c:	93 81       	ldd	r25, Z+3	; 0x03
     89e:	90 93 01 01 	sts	0x0101, r25
     8a2:	80 93 00 01 	sts	0x0100, r24

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     8a6:	80 91 00 01 	lds	r24, 0x0100
     8aa:	90 91 01 01 	lds	r25, 0x0101
     8ae:	e8 16       	cp	r14, r24
     8b0:	f9 06       	cpc	r15, r25
     8b2:	10 f4       	brcc	.+4      	; 0x8b8 <xTaskIncrementTick+0xb0>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     8b4:	d1 2c       	mov	r13, r1
     8b6:	53 c0       	rjmp	.+166    	; 0x95e <xTaskIncrementTick+0x156>
     8b8:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
     8ba:	cc 24       	eor	r12, r12
     8bc:	c3 94       	inc	r12
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     8be:	e0 91 8f 04 	lds	r30, 0x048F
     8c2:	f0 91 90 04 	lds	r31, 0x0490
     8c6:	90 81       	ld	r25, Z
     8c8:	91 11       	cpse	r25, r1
     8ca:	07 c0       	rjmp	.+14     	; 0x8da <xTaskIncrementTick+0xd2>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     8cc:	8f ef       	ldi	r24, 0xFF	; 255
     8ce:	9f ef       	ldi	r25, 0xFF	; 255
     8d0:	90 93 01 01 	sts	0x0101, r25
     8d4:	80 93 00 01 	sts	0x0100, r24
						break;
     8d8:	42 c0       	rjmp	.+132    	; 0x95e <xTaskIncrementTick+0x156>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     8da:	e0 91 8f 04 	lds	r30, 0x048F
     8de:	f0 91 90 04 	lds	r31, 0x0490
     8e2:	05 80       	ldd	r0, Z+5	; 0x05
     8e4:	f6 81       	ldd	r31, Z+6	; 0x06
     8e6:	e0 2d       	mov	r30, r0
     8e8:	c6 81       	ldd	r28, Z+6	; 0x06
     8ea:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     8ec:	2a 81       	ldd	r18, Y+2	; 0x02
     8ee:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
     8f0:	e2 16       	cp	r14, r18
     8f2:	f3 06       	cpc	r15, r19
     8f4:	28 f4       	brcc	.+10     	; 0x900 <xTaskIncrementTick+0xf8>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
     8f6:	30 93 01 01 	sts	0x0101, r19
     8fa:	20 93 00 01 	sts	0x0100, r18
							break;
     8fe:	2f c0       	rjmp	.+94     	; 0x95e <xTaskIncrementTick+0x156>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     900:	8e 01       	movw	r16, r28
     902:	0e 5f       	subi	r16, 0xFE	; 254
     904:	1f 4f       	sbci	r17, 0xFF	; 255
     906:	c8 01       	movw	r24, r16
     908:	0e 94 6d 02 	call	0x4da	; 0x4da <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     90c:	8c 89       	ldd	r24, Y+20	; 0x14
     90e:	9d 89       	ldd	r25, Y+21	; 0x15
     910:	89 2b       	or	r24, r25
     912:	21 f0       	breq	.+8      	; 0x91c <xTaskIncrementTick+0x114>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     914:	ce 01       	movw	r24, r28
     916:	0c 96       	adiw	r24, 0x0c	; 12
     918:	0e 94 6d 02 	call	0x4da	; 0x4da <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     91c:	2e 89       	ldd	r18, Y+22	; 0x16
     91e:	80 91 80 04 	lds	r24, 0x0480
     922:	82 17       	cp	r24, r18
     924:	10 f4       	brcc	.+4      	; 0x92a <xTaskIncrementTick+0x122>
     926:	20 93 80 04 	sts	0x0480, r18
     92a:	30 e0       	ldi	r19, 0x00	; 0
     92c:	c9 01       	movw	r24, r18
     92e:	88 0f       	add	r24, r24
     930:	99 1f       	adc	r25, r25
     932:	88 0f       	add	r24, r24
     934:	99 1f       	adc	r25, r25
     936:	88 0f       	add	r24, r24
     938:	99 1f       	adc	r25, r25
     93a:	82 0f       	add	r24, r18
     93c:	93 1f       	adc	r25, r19
     93e:	b8 01       	movw	r22, r16
     940:	8d 55       	subi	r24, 0x5D	; 93
     942:	9b 4f       	sbci	r25, 0xFB	; 251
     944:	0e 94 1b 02 	call	0x436	; 0x436 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     948:	e0 91 c7 04 	lds	r30, 0x04C7
     94c:	f0 91 c8 04 	lds	r31, 0x04C8
     950:	9e 89       	ldd	r25, Y+22	; 0x16
     952:	86 89       	ldd	r24, Z+22	; 0x16
     954:	98 17       	cp	r25, r24
     956:	08 f4       	brcc	.+2      	; 0x95a <xTaskIncrementTick+0x152>
     958:	b2 cf       	rjmp	.-156    	; 0x8be <xTaskIncrementTick+0xb6>
							{
								xSwitchRequired = pdTRUE;
     95a:	dc 2c       	mov	r13, r12
     95c:	b0 cf       	rjmp	.-160    	; 0x8be <xTaskIncrementTick+0xb6>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     95e:	e0 91 c7 04 	lds	r30, 0x04C7
     962:	f0 91 c8 04 	lds	r31, 0x04C8
     966:	86 89       	ldd	r24, Z+22	; 0x16
     968:	90 e0       	ldi	r25, 0x00	; 0
     96a:	fc 01       	movw	r30, r24
     96c:	ee 0f       	add	r30, r30
     96e:	ff 1f       	adc	r31, r31
     970:	ee 0f       	add	r30, r30
     972:	ff 1f       	adc	r31, r31
     974:	ee 0f       	add	r30, r30
     976:	ff 1f       	adc	r31, r31
     978:	8e 0f       	add	r24, r30
     97a:	9f 1f       	adc	r25, r31
     97c:	fc 01       	movw	r30, r24
     97e:	ed 55       	subi	r30, 0x5D	; 93
     980:	fb 4f       	sbci	r31, 0xFB	; 251
     982:	80 81       	ld	r24, Z
     984:	82 30       	cpi	r24, 0x02	; 2
     986:	48 f0       	brcs	.+18     	; 0x99a <xTaskIncrementTick+0x192>
			{
				xSwitchRequired = pdTRUE;
     988:	dd 24       	eor	r13, r13
     98a:	d3 94       	inc	r13
     98c:	06 c0       	rjmp	.+12     	; 0x99a <xTaskIncrementTick+0x192>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     98e:	80 91 7e 04 	lds	r24, 0x047E
     992:	8f 5f       	subi	r24, 0xFF	; 255
     994:	80 93 7e 04 	sts	0x047E, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     998:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     99a:	80 91 7d 04 	lds	r24, 0x047D
     99e:	88 23       	and	r24, r24
     9a0:	11 f0       	breq	.+4      	; 0x9a6 <xTaskIncrementTick+0x19e>
		{
			xSwitchRequired = pdTRUE;
     9a2:	dd 24       	eor	r13, r13
     9a4:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     9a6:	8d 2d       	mov	r24, r13
     9a8:	df 91       	pop	r29
     9aa:	cf 91       	pop	r28
     9ac:	1f 91       	pop	r17
     9ae:	0f 91       	pop	r16
     9b0:	ff 90       	pop	r15
     9b2:	ef 90       	pop	r14
     9b4:	df 90       	pop	r13
     9b6:	cf 90       	pop	r12
     9b8:	08 95       	ret

000009ba <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     9ba:	df 92       	push	r13
     9bc:	ef 92       	push	r14
     9be:	ff 92       	push	r15
     9c0:	0f 93       	push	r16
     9c2:	1f 93       	push	r17
     9c4:	cf 93       	push	r28
     9c6:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     9c8:	0f b6       	in	r0, 0x3f	; 63
     9ca:	f8 94       	cli
     9cc:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     9ce:	80 91 7a 04 	lds	r24, 0x047A
     9d2:	81 50       	subi	r24, 0x01	; 1
     9d4:	80 93 7a 04 	sts	0x047A, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     9d8:	80 91 7a 04 	lds	r24, 0x047A
     9dc:	81 11       	cpse	r24, r1
     9de:	62 c0       	rjmp	.+196    	; 0xaa4 <xTaskResumeAll+0xea>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     9e0:	80 91 83 04 	lds	r24, 0x0483
     9e4:	81 11       	cpse	r24, r1
     9e6:	33 c0       	rjmp	.+102    	; 0xa4e <xTaskResumeAll+0x94>
     9e8:	60 c0       	rjmp	.+192    	; 0xaaa <xTaskResumeAll+0xf0>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     9ea:	d7 01       	movw	r26, r14
     9ec:	15 96       	adiw	r26, 0x05	; 5
     9ee:	ed 91       	ld	r30, X+
     9f0:	fc 91       	ld	r31, X
     9f2:	16 97       	sbiw	r26, 0x06	; 6
     9f4:	c6 81       	ldd	r28, Z+6	; 0x06
     9f6:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     9f8:	ce 01       	movw	r24, r28
     9fa:	0c 96       	adiw	r24, 0x0c	; 12
     9fc:	0e 94 6d 02 	call	0x4da	; 0x4da <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     a00:	8e 01       	movw	r16, r28
     a02:	0e 5f       	subi	r16, 0xFE	; 254
     a04:	1f 4f       	sbci	r17, 0xFF	; 255
     a06:	c8 01       	movw	r24, r16
     a08:	0e 94 6d 02 	call	0x4da	; 0x4da <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     a0c:	2e 89       	ldd	r18, Y+22	; 0x16
     a0e:	80 91 80 04 	lds	r24, 0x0480
     a12:	82 17       	cp	r24, r18
     a14:	10 f4       	brcc	.+4      	; 0xa1a <xTaskResumeAll+0x60>
     a16:	20 93 80 04 	sts	0x0480, r18
     a1a:	30 e0       	ldi	r19, 0x00	; 0
     a1c:	c9 01       	movw	r24, r18
     a1e:	88 0f       	add	r24, r24
     a20:	99 1f       	adc	r25, r25
     a22:	88 0f       	add	r24, r24
     a24:	99 1f       	adc	r25, r25
     a26:	88 0f       	add	r24, r24
     a28:	99 1f       	adc	r25, r25
     a2a:	82 0f       	add	r24, r18
     a2c:	93 1f       	adc	r25, r19
     a2e:	b8 01       	movw	r22, r16
     a30:	8d 55       	subi	r24, 0x5D	; 93
     a32:	9b 4f       	sbci	r25, 0xFB	; 251
     a34:	0e 94 1b 02 	call	0x436	; 0x436 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     a38:	e0 91 c7 04 	lds	r30, 0x04C7
     a3c:	f0 91 c8 04 	lds	r31, 0x04C8
     a40:	9e 89       	ldd	r25, Y+22	; 0x16
     a42:	86 89       	ldd	r24, Z+22	; 0x16
     a44:	98 17       	cp	r25, r24
     a46:	58 f0       	brcs	.+22     	; 0xa5e <xTaskResumeAll+0xa4>
					{
						xYieldPending = pdTRUE;
     a48:	d0 92 7d 04 	sts	0x047D, r13
     a4c:	08 c0       	rjmp	.+16     	; 0xa5e <xTaskResumeAll+0xa4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     a4e:	0f 2e       	mov	r0, r31
     a50:	f4 e8       	ldi	r31, 0x84	; 132
     a52:	ef 2e       	mov	r14, r31
     a54:	f4 e0       	ldi	r31, 0x04	; 4
     a56:	ff 2e       	mov	r15, r31
     a58:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     a5a:	dd 24       	eor	r13, r13
     a5c:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     a5e:	f7 01       	movw	r30, r14
     a60:	80 81       	ld	r24, Z
     a62:	81 11       	cpse	r24, r1
     a64:	c2 cf       	rjmp	.-124    	; 0x9ea <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
     a66:	80 91 7e 04 	lds	r24, 0x047E
     a6a:	88 23       	and	r24, r24
     a6c:	99 f0       	breq	.+38     	; 0xa94 <xTaskResumeAll+0xda>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     a6e:	80 91 7e 04 	lds	r24, 0x047E
     a72:	88 23       	and	r24, r24
     a74:	79 f0       	breq	.+30     	; 0xa94 <xTaskResumeAll+0xda>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
     a76:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
     a78:	0e 94 04 04 	call	0x808	; 0x808 <xTaskIncrementTick>
     a7c:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
     a7e:	c0 93 7d 04 	sts	0x047D, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
     a82:	80 91 7e 04 	lds	r24, 0x047E
     a86:	81 50       	subi	r24, 0x01	; 1
     a88:	80 93 7e 04 	sts	0x047E, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     a8c:	80 91 7e 04 	lds	r24, 0x047E
     a90:	81 11       	cpse	r24, r1
     a92:	f2 cf       	rjmp	.-28     	; 0xa78 <xTaskResumeAll+0xbe>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
     a94:	80 91 7d 04 	lds	r24, 0x047D
     a98:	81 30       	cpi	r24, 0x01	; 1
     a9a:	31 f4       	brne	.+12     	; 0xaa8 <xTaskResumeAll+0xee>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     a9c:	0e 94 1b 01 	call	0x236	; 0x236 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     aa0:	81 e0       	ldi	r24, 0x01	; 1
     aa2:	03 c0       	rjmp	.+6      	; 0xaaa <xTaskResumeAll+0xf0>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
     aa4:	80 e0       	ldi	r24, 0x00	; 0
     aa6:	01 c0       	rjmp	.+2      	; 0xaaa <xTaskResumeAll+0xf0>
     aa8:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     aaa:	0f 90       	pop	r0
     aac:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     aae:	df 91       	pop	r29
     ab0:	cf 91       	pop	r28
     ab2:	1f 91       	pop	r17
     ab4:	0f 91       	pop	r16
     ab6:	ff 90       	pop	r15
     ab8:	ef 90       	pop	r14
     aba:	df 90       	pop	r13
     abc:	08 95       	ret

00000abe <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     abe:	cf 93       	push	r28
     ac0:	df 93       	push	r29
     ac2:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     ac4:	89 2b       	or	r24, r25
     ac6:	b1 f0       	breq	.+44     	; 0xaf4 <vTaskDelay+0x36>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     ac8:	0e 94 fe 03 	call	0x7fc	; 0x7fc <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     acc:	80 91 81 04 	lds	r24, 0x0481
     ad0:	90 91 82 04 	lds	r25, 0x0482
     ad4:	c8 0f       	add	r28, r24
     ad6:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     ad8:	80 91 c7 04 	lds	r24, 0x04C7
     adc:	90 91 c8 04 	lds	r25, 0x04C8
     ae0:	02 96       	adiw	r24, 0x02	; 2
     ae2:	0e 94 6d 02 	call	0x4da	; 0x4da <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     ae6:	ce 01       	movw	r24, r28
     ae8:	0e 94 94 02 	call	0x528	; 0x528 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     aec:	0e 94 dd 04 	call	0x9ba	; 0x9ba <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     af0:	81 11       	cpse	r24, r1
     af2:	02 c0       	rjmp	.+4      	; 0xaf8 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
     af4:	0e 94 1b 01 	call	0x236	; 0x236 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     af8:	df 91       	pop	r29
     afa:	cf 91       	pop	r28
     afc:	08 95       	ret

00000afe <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     afe:	80 91 7a 04 	lds	r24, 0x047A
     b02:	88 23       	and	r24, r24
     b04:	21 f0       	breq	.+8      	; 0xb0e <__stack+0xf>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     b06:	81 e0       	ldi	r24, 0x01	; 1
     b08:	80 93 7d 04 	sts	0x047D, r24
     b0c:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     b0e:	10 92 7d 04 	sts	0x047D, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     b12:	80 91 80 04 	lds	r24, 0x0480
     b16:	90 e0       	ldi	r25, 0x00	; 0
     b18:	fc 01       	movw	r30, r24
     b1a:	ee 0f       	add	r30, r30
     b1c:	ff 1f       	adc	r31, r31
     b1e:	ee 0f       	add	r30, r30
     b20:	ff 1f       	adc	r31, r31
     b22:	ee 0f       	add	r30, r30
     b24:	ff 1f       	adc	r31, r31
     b26:	8e 0f       	add	r24, r30
     b28:	9f 1f       	adc	r25, r31
     b2a:	fc 01       	movw	r30, r24
     b2c:	ed 55       	subi	r30, 0x5D	; 93
     b2e:	fb 4f       	sbci	r31, 0xFB	; 251
     b30:	80 81       	ld	r24, Z
     b32:	81 11       	cpse	r24, r1
     b34:	17 c0       	rjmp	.+46     	; 0xb64 <__stack+0x65>
     b36:	80 91 80 04 	lds	r24, 0x0480
     b3a:	81 50       	subi	r24, 0x01	; 1
     b3c:	80 93 80 04 	sts	0x0480, r24
     b40:	80 91 80 04 	lds	r24, 0x0480
     b44:	90 e0       	ldi	r25, 0x00	; 0
     b46:	fc 01       	movw	r30, r24
     b48:	ee 0f       	add	r30, r30
     b4a:	ff 1f       	adc	r31, r31
     b4c:	ee 0f       	add	r30, r30
     b4e:	ff 1f       	adc	r31, r31
     b50:	ee 0f       	add	r30, r30
     b52:	ff 1f       	adc	r31, r31
     b54:	8e 0f       	add	r24, r30
     b56:	9f 1f       	adc	r25, r31
     b58:	fc 01       	movw	r30, r24
     b5a:	ed 55       	subi	r30, 0x5D	; 93
     b5c:	fb 4f       	sbci	r31, 0xFB	; 251
     b5e:	80 81       	ld	r24, Z
     b60:	88 23       	and	r24, r24
     b62:	49 f3       	breq	.-46     	; 0xb36 <__stack+0x37>
     b64:	80 91 80 04 	lds	r24, 0x0480
     b68:	90 e0       	ldi	r25, 0x00	; 0
     b6a:	9c 01       	movw	r18, r24
     b6c:	22 0f       	add	r18, r18
     b6e:	33 1f       	adc	r19, r19
     b70:	22 0f       	add	r18, r18
     b72:	33 1f       	adc	r19, r19
     b74:	22 0f       	add	r18, r18
     b76:	33 1f       	adc	r19, r19
     b78:	28 0f       	add	r18, r24
     b7a:	39 1f       	adc	r19, r25
     b7c:	d9 01       	movw	r26, r18
     b7e:	ad 55       	subi	r26, 0x5D	; 93
     b80:	bb 4f       	sbci	r27, 0xFB	; 251
     b82:	11 96       	adiw	r26, 0x01	; 1
     b84:	ed 91       	ld	r30, X+
     b86:	fc 91       	ld	r31, X
     b88:	12 97       	sbiw	r26, 0x02	; 2
     b8a:	02 80       	ldd	r0, Z+2	; 0x02
     b8c:	f3 81       	ldd	r31, Z+3	; 0x03
     b8e:	e0 2d       	mov	r30, r0
     b90:	12 96       	adiw	r26, 0x02	; 2
     b92:	fc 93       	st	X, r31
     b94:	ee 93       	st	-X, r30
     b96:	11 97       	sbiw	r26, 0x01	; 1
     b98:	2a 55       	subi	r18, 0x5A	; 90
     b9a:	3b 4f       	sbci	r19, 0xFB	; 251
     b9c:	e2 17       	cp	r30, r18
     b9e:	f3 07       	cpc	r31, r19
     ba0:	29 f4       	brne	.+10     	; 0xbac <__stack+0xad>
     ba2:	22 81       	ldd	r18, Z+2	; 0x02
     ba4:	33 81       	ldd	r19, Z+3	; 0x03
     ba6:	fd 01       	movw	r30, r26
     ba8:	32 83       	std	Z+2, r19	; 0x02
     baa:	21 83       	std	Z+1, r18	; 0x01
     bac:	fc 01       	movw	r30, r24
     bae:	ee 0f       	add	r30, r30
     bb0:	ff 1f       	adc	r31, r31
     bb2:	ee 0f       	add	r30, r30
     bb4:	ff 1f       	adc	r31, r31
     bb6:	ee 0f       	add	r30, r30
     bb8:	ff 1f       	adc	r31, r31
     bba:	8e 0f       	add	r24, r30
     bbc:	9f 1f       	adc	r25, r31
     bbe:	fc 01       	movw	r30, r24
     bc0:	ed 55       	subi	r30, 0x5D	; 93
     bc2:	fb 4f       	sbci	r31, 0xFB	; 251
     bc4:	01 80       	ldd	r0, Z+1	; 0x01
     bc6:	f2 81       	ldd	r31, Z+2	; 0x02
     bc8:	e0 2d       	mov	r30, r0
     bca:	86 81       	ldd	r24, Z+6	; 0x06
     bcc:	97 81       	ldd	r25, Z+7	; 0x07
     bce:	90 93 c8 04 	sts	0x04C8, r25
     bd2:	80 93 c7 04 	sts	0x04C7, r24
     bd6:	08 95       	ret

00000bd8 <Endpoint_ConfigureEndpoint_Prv>:
}

bool Endpoint_ConfigureEndpoint_Prv(const uint8_t Number,
                                    const uint8_t UECFG0XData,
                                    const uint8_t UECFG1XData)
{
     bd8:	8f 92       	push	r8
     bda:	9f 92       	push	r9
     bdc:	bf 92       	push	r11
     bde:	cf 92       	push	r12
     be0:	df 92       	push	r13
     be2:	ef 92       	push	r14
     be4:	ff 92       	push	r15
     be6:	0f 93       	push	r16
     be8:	1f 93       	push	r17
     bea:	cf 93       	push	r28
     bec:	df 93       	push	r29
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
     bee:	87 30       	cpi	r24, 0x07	; 7
     bf0:	70 f1       	brcs	.+92     	; 0xc4e <Endpoint_ConfigureEndpoint_Prv+0x76>
     bf2:	26 c0       	rjmp	.+76     	; 0xc40 <Endpoint_ConfigureEndpoint_Prv+0x68>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
     bf4:	29 2f       	mov	r18, r25
     bf6:	2f 70       	andi	r18, 0x0F	; 15
     bf8:	e7 01       	movw	r28, r14
     bfa:	28 83       	st	Y, r18
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
     bfc:	89 17       	cp	r24, r25
     bfe:	31 f0       	breq	.+12     	; 0xc0c <Endpoint_ConfigureEndpoint_Prv+0x34>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
     c00:	e8 01       	movw	r28, r16
     c02:	78 81       	ld	r23, Y
			UECFG1XTemp = UECFG1X;
     c04:	20 81       	ld	r18, Z
			UEIENXTemp  = UEIENX;
     c06:	e4 01       	movw	r28, r8
     c08:	58 81       	ld	r21, Y
     c0a:	03 c0       	rjmp	.+6      	; 0xc12 <Endpoint_ConfigureEndpoint_Prv+0x3a>
		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
     c0c:	24 2f       	mov	r18, r20

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
     c0e:	76 2f       	mov	r23, r22
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
     c10:	5b 2d       	mov	r21, r11
			UECFG0XTemp = UECFG0X;
			UECFG1XTemp = UECFG1X;
			UEIENXTemp  = UEIENX;
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
     c12:	21 ff       	sbrs	r18, 1
     c14:	12 c0       	rjmp	.+36     	; 0xc3a <Endpoint_ConfigureEndpoint_Prv+0x62>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
     c16:	3c 91       	ld	r19, X
     c18:	3e 7f       	andi	r19, 0xFE	; 254
     c1a:	3c 93       	st	X, r19
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
     c1c:	30 81       	ld	r19, Z
     c1e:	3d 7f       	andi	r19, 0xFD	; 253
     c20:	30 83       	st	Z, r19
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
     c22:	3c 91       	ld	r19, X
     c24:	31 60       	ori	r19, 0x01	; 1
     c26:	3c 93       	st	X, r19

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
     c28:	e8 01       	movw	r28, r16
     c2a:	78 83       	st	Y, r23
		UECFG1X = UECFG1XTemp;
     c2c:	20 83       	st	Z, r18
		UEIENX  = UEIENXTemp;
     c2e:	e4 01       	movw	r28, r8
     c30:	58 83       	st	Y, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
     c32:	e6 01       	movw	r28, r12
     c34:	28 81       	ld	r18, Y

		if (!(Endpoint_IsConfigured()))
     c36:	22 23       	and	r18, r18
     c38:	44 f4       	brge	.+16     	; 0xc4a <Endpoint_ConfigureEndpoint_Prv+0x72>
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
     c3a:	9f 5f       	subi	r25, 0xFF	; 255
     c3c:	97 30       	cpi	r25, 0x07	; 7
     c3e:	d1 f6       	brne	.-76     	; 0xbf4 <Endpoint_ConfigureEndpoint_Prv+0x1c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
     c40:	8f 70       	andi	r24, 0x0F	; 15
     c42:	80 93 e9 00 	sts	0x00E9, r24
		if (!(Endpoint_IsConfigured()))
		  return false;
	}

	Endpoint_SelectEndpoint(Number);
	return true;
     c46:	81 e0       	ldi	r24, 0x01	; 1
     c48:	21 c0       	rjmp	.+66     	; 0xc8c <Endpoint_ConfigureEndpoint_Prv+0xb4>
		UECFG0X = UECFG0XTemp;
		UECFG1X = UECFG1XTemp;
		UEIENX  = UEIENXTemp;

		if (!(Endpoint_IsConfigured()))
		  return false;
     c4a:	80 e0       	ldi	r24, 0x00	; 0
     c4c:	1f c0       	rjmp	.+62     	; 0xc8c <Endpoint_ConfigureEndpoint_Prv+0xb4>
     c4e:	98 2f       	mov	r25, r24
     c50:	9f 70       	andi	r25, 0x0F	; 15
     c52:	90 93 e9 00 	sts	0x00E9, r25
     c56:	98 2f       	mov	r25, r24
		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
     c58:	24 2f       	mov	r18, r20

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
     c5a:	76 2f       	mov	r23, r22
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
     c5c:	50 e0       	ldi	r21, 0x00	; 0
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
     c5e:	ab ee       	ldi	r26, 0xEB	; 235
     c60:	b0 e0       	ldi	r27, 0x00	; 0

		if (!(UECFG1XTemp & (1 << ALLOC)))
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
     c62:	ed ee       	ldi	r30, 0xED	; 237
     c64:	f0 e0       	ldi	r31, 0x00	; 0

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
     c66:	0c ee       	ldi	r16, 0xEC	; 236
     c68:	10 e0       	ldi	r17, 0x00	; 0
		UECFG1X = UECFG1XTemp;
		UEIENX  = UEIENXTemp;
     c6a:	0f 2e       	mov	r0, r31
     c6c:	f0 ef       	ldi	r31, 0xF0	; 240
     c6e:	8f 2e       	mov	r8, r31
     c70:	91 2c       	mov	r9, r1
     c72:	f0 2d       	mov	r31, r0
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
     c74:	0f 2e       	mov	r0, r31
     c76:	fe ee       	ldi	r31, 0xEE	; 238
     c78:	cf 2e       	mov	r12, r31
     c7a:	d1 2c       	mov	r13, r1
     c7c:	f0 2d       	mov	r31, r0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
     c7e:	0f 2e       	mov	r0, r31
     c80:	f9 ee       	ldi	r31, 0xE9	; 233
     c82:	ef 2e       	mov	r14, r31
     c84:	f1 2c       	mov	r15, r1
     c86:	f0 2d       	mov	r31, r0

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
     c88:	b1 2c       	mov	r11, r1
     c8a:	c3 cf       	rjmp	.-122    	; 0xc12 <Endpoint_ConfigureEndpoint_Prv+0x3a>
	}

	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
     c8c:	df 91       	pop	r29
     c8e:	cf 91       	pop	r28
     c90:	1f 91       	pop	r17
     c92:	0f 91       	pop	r16
     c94:	ff 90       	pop	r15
     c96:	ef 90       	pop	r14
     c98:	df 90       	pop	r13
     c9a:	cf 90       	pop	r12
     c9c:	bf 90       	pop	r11
     c9e:	9f 90       	pop	r9
     ca0:	8f 90       	pop	r8
     ca2:	08 95       	ret

00000ca4 <__vector_10>:
	UDINT  = 0;
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
     ca4:	1f 92       	push	r1
     ca6:	0f 92       	push	r0
     ca8:	0f b6       	in	r0, 0x3f	; 63
     caa:	0f 92       	push	r0
     cac:	11 24       	eor	r1, r1
     cae:	2f 93       	push	r18
     cb0:	3f 93       	push	r19
     cb2:	4f 93       	push	r20
     cb4:	5f 93       	push	r21
     cb6:	6f 93       	push	r22
     cb8:	7f 93       	push	r23
     cba:	8f 93       	push	r24
     cbc:	9f 93       	push	r25
     cbe:	af 93       	push	r26
     cc0:	bf 93       	push	r27
     cc2:	ef 93       	push	r30
     cc4:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
     cc6:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
     cca:	82 ff       	sbrs	r24, 2
     ccc:	0b c0       	rjmp	.+22     	; 0xce4 <__vector_10+0x40>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
     cce:	80 91 e2 00 	lds	r24, 0x00E2
     cd2:	82 ff       	sbrs	r24, 2
     cd4:	07 c0       	rjmp	.+14     	; 0xce4 <__vector_10+0x40>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
     cd6:	e1 ee       	ldi	r30, 0xE1	; 225
     cd8:	f0 e0       	ldi	r31, 0x00	; 0
     cda:	80 81       	ld	r24, Z
     cdc:	8b 7f       	andi	r24, 0xFB	; 251
     cde:	80 83       	st	Z, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
     ce0:	0e 94 19 07 	call	0xe32	; 0xe32 <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
     ce4:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
     ce8:	80 ff       	sbrs	r24, 0
     cea:	1f c0       	rjmp	.+62     	; 0xd2a <__vector_10+0x86>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
     cec:	80 91 d8 00 	lds	r24, 0x00D8
     cf0:	80 ff       	sbrs	r24, 0
     cf2:	1b c0       	rjmp	.+54     	; 0xd2a <__vector_10+0x86>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
     cf4:	ea ed       	ldi	r30, 0xDA	; 218
     cf6:	f0 e0       	ldi	r31, 0x00	; 0
     cf8:	80 81       	ld	r24, Z
     cfa:	8e 7f       	andi	r24, 0xFE	; 254
     cfc:	80 83       	st	Z, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
     cfe:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
     d02:	80 ff       	sbrs	r24, 0
     d04:	0d c0       	rjmp	.+26     	; 0xd20 <__vector_10+0x7c>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
     d06:	80 e1       	ldi	r24, 0x10	; 16
     d08:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
     d0a:	82 e1       	ldi	r24, 0x12	; 18
     d0c:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
     d0e:	09 b4       	in	r0, 0x29	; 41
     d10:	00 fe       	sbrs	r0, 0
     d12:	fd cf       	rjmp	.-6      	; 0xd0e <__vector_10+0x6a>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
     d14:	81 e0       	ldi	r24, 0x01	; 1
     d16:	80 93 cd 04 	sts	0x04CD, r24
			EVENT_USB_Device_Connect();
     d1a:	0e 94 19 07 	call	0xe32	; 0xe32 <USB_Event_Stub>
     d1e:	05 c0       	rjmp	.+10     	; 0xd2a <__vector_10+0x86>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
     d20:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
     d22:	10 92 cd 04 	sts	0x04CD, r1
			EVENT_USB_Device_Disconnect();
     d26:	0e 94 19 07 	call	0xe32	; 0xe32 <USB_Event_Stub>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
     d2a:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
     d2e:	80 ff       	sbrs	r24, 0
     d30:	17 c0       	rjmp	.+46     	; 0xd60 <__vector_10+0xbc>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
     d32:	80 91 e2 00 	lds	r24, 0x00E2
     d36:	80 ff       	sbrs	r24, 0
     d38:	13 c0       	rjmp	.+38     	; 0xd60 <__vector_10+0xbc>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
     d3a:	e2 ee       	ldi	r30, 0xE2	; 226
     d3c:	f0 e0       	ldi	r31, 0x00	; 0
     d3e:	80 81       	ld	r24, Z
     d40:	8e 7f       	andi	r24, 0xFE	; 254
     d42:	80 83       	st	Z, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
     d44:	80 81       	ld	r24, Z
     d46:	80 61       	ori	r24, 0x10	; 16
     d48:	80 83       	st	Z, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
     d4a:	e8 ed       	ldi	r30, 0xD8	; 216
     d4c:	f0 e0       	ldi	r31, 0x00	; 0
     d4e:	80 81       	ld	r24, Z
     d50:	80 62       	ori	r24, 0x20	; 32
     d52:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
     d54:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
     d56:	85 e0       	ldi	r24, 0x05	; 5
     d58:	80 93 cd 04 	sts	0x04CD, r24
		EVENT_USB_Device_Suspend();
     d5c:	0e 94 19 07 	call	0xe32	; 0xe32 <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
     d60:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
     d64:	84 ff       	sbrs	r24, 4
     d66:	30 c0       	rjmp	.+96     	; 0xdc8 <__vector_10+0x124>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
     d68:	80 91 e2 00 	lds	r24, 0x00E2
     d6c:	84 ff       	sbrs	r24, 4
     d6e:	2c c0       	rjmp	.+88     	; 0xdc8 <__vector_10+0x124>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
     d70:	80 e1       	ldi	r24, 0x10	; 16
     d72:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
     d74:	82 e1       	ldi	r24, 0x12	; 18
     d76:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
     d78:	09 b4       	in	r0, 0x29	; 41
     d7a:	00 fe       	sbrs	r0, 0
     d7c:	fd cf       	rjmp	.-6      	; 0xd78 <__vector_10+0xd4>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
     d7e:	e8 ed       	ldi	r30, 0xD8	; 216
     d80:	f0 e0       	ldi	r31, 0x00	; 0
     d82:	80 81       	ld	r24, Z
     d84:	8f 7d       	andi	r24, 0xDF	; 223
     d86:	80 83       	st	Z, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
     d88:	e1 ee       	ldi	r30, 0xE1	; 225
     d8a:	f0 e0       	ldi	r31, 0x00	; 0
     d8c:	80 81       	ld	r24, Z
     d8e:	8f 7e       	andi	r24, 0xEF	; 239
     d90:	80 83       	st	Z, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
     d92:	e2 ee       	ldi	r30, 0xE2	; 226
     d94:	f0 e0       	ldi	r31, 0x00	; 0
     d96:	80 81       	ld	r24, Z
     d98:	8f 7e       	andi	r24, 0xEF	; 239
     d9a:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
     d9c:	80 81       	ld	r24, Z
     d9e:	81 60       	ori	r24, 0x01	; 1
     da0:	80 83       	st	Z, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
     da2:	80 91 c9 04 	lds	r24, 0x04C9
     da6:	88 23       	and	r24, r24
     da8:	21 f0       	breq	.+8      	; 0xdb2 <__vector_10+0x10e>
		  USB_DeviceState = DEVICE_STATE_Configured;
     daa:	84 e0       	ldi	r24, 0x04	; 4
     dac:	80 93 cd 04 	sts	0x04CD, r24
     db0:	09 c0       	rjmp	.+18     	; 0xdc4 <__vector_10+0x120>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
     db2:	80 91 e3 00 	lds	r24, 0x00E3
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Addressed : DEVICE_STATE_Powered;
     db6:	88 23       	and	r24, r24
     db8:	14 f0       	brlt	.+4      	; 0xdbe <__vector_10+0x11a>
     dba:	81 e0       	ldi	r24, 0x01	; 1
     dbc:	01 c0       	rjmp	.+2      	; 0xdc0 <__vector_10+0x11c>
     dbe:	83 e0       	ldi	r24, 0x03	; 3
     dc0:	80 93 cd 04 	sts	0x04CD, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
     dc4:	0e 94 19 07 	call	0xe32	; 0xe32 <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
     dc8:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
     dcc:	83 ff       	sbrs	r24, 3
     dce:	20 c0       	rjmp	.+64     	; 0xe10 <__vector_10+0x16c>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
     dd0:	80 91 e2 00 	lds	r24, 0x00E2
     dd4:	83 ff       	sbrs	r24, 3
     dd6:	1c c0       	rjmp	.+56     	; 0xe10 <__vector_10+0x16c>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
     dd8:	e1 ee       	ldi	r30, 0xE1	; 225
     dda:	f0 e0       	ldi	r31, 0x00	; 0
     ddc:	80 81       	ld	r24, Z
     dde:	87 7f       	andi	r24, 0xF7	; 247
     de0:	80 83       	st	Z, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
     de2:	82 e0       	ldi	r24, 0x02	; 2
     de4:	80 93 cd 04 	sts	0x04CD, r24
		USB_Device_ConfigurationNumber = 0;
     de8:	10 92 c9 04 	sts	0x04C9, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
     dec:	80 81       	ld	r24, Z
     dee:	8e 7f       	andi	r24, 0xFE	; 254
     df0:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
     df2:	e2 ee       	ldi	r30, 0xE2	; 226
     df4:	f0 e0       	ldi	r31, 0x00	; 0
     df6:	80 81       	ld	r24, Z
     df8:	8e 7f       	andi	r24, 0xFE	; 254
     dfa:	80 83       	st	Z, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
     dfc:	80 81       	ld	r24, Z
     dfe:	80 61       	ori	r24, 0x10	; 16
     e00:	80 83       	st	Z, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
     e02:	42 e0       	ldi	r20, 0x02	; 2
     e04:	60 e0       	ldi	r22, 0x00	; 0
     e06:	80 e0       	ldi	r24, 0x00	; 0
     e08:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
     e0c:	0e 94 19 07 	call	0xe32	; 0xe32 <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
     e10:	ff 91       	pop	r31
     e12:	ef 91       	pop	r30
     e14:	bf 91       	pop	r27
     e16:	af 91       	pop	r26
     e18:	9f 91       	pop	r25
     e1a:	8f 91       	pop	r24
     e1c:	7f 91       	pop	r23
     e1e:	6f 91       	pop	r22
     e20:	5f 91       	pop	r21
     e22:	4f 91       	pop	r20
     e24:	3f 91       	pop	r19
     e26:	2f 91       	pop	r18
     e28:	0f 90       	pop	r0
     e2a:	0f be       	out	0x3f, r0	; 63
     e2c:	0f 90       	pop	r0
     e2e:	1f 90       	pop	r1
     e30:	18 95       	reti

00000e32 <USB_Event_Stub>:
#define  __INCLUDE_FROM_EVENTS_C
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

void USB_Event_Stub(void)
{
     e32:	08 95       	ret

00000e34 <thread_1>:
#include "task.h"
#include "nrf24l01p/nrf24l01p.h"


int thread_1(void)
{
     e34:	cf 93       	push	r28
     e36:	df 93       	push	r29
     e38:	cd b7       	in	r28, 0x3d	; 61
     e3a:	de b7       	in	r29, 0x3e	; 62
     e3c:	a0 97       	sbiw	r28, 0x20	; 32
     e3e:	0f b6       	in	r0, 0x3f	; 63
     e40:	f8 94       	cli
     e42:	de bf       	out	0x3e, r29	; 62
     e44:	0f be       	out	0x3f, r0	; 63
     e46:	cd bf       	out	0x3d, r28	; 61
	
	_nrf24l01p_init();
     e48:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <_nrf24l01p_init>
	_nrf24l01p_enable_dynamic_payload();
     e4c:	0e 94 ef 0a 	call	0x15de	; 0x15de <_nrf24l01p_enable_dynamic_payload>
	_nrf24l01p_enable_payload_with_ack();
     e50:	0e 94 0b 0b 	call	0x1616	; 0x1616 <_nrf24l01p_enable_payload_with_ack>

	_nrf24l01p_enable_auto_ack(_NRF24L01P_PIPE_P0);
     e54:	80 e0       	ldi	r24, 0x00	; 0
     e56:	0e 94 1c 09 	call	0x1238	; 0x1238 <_nrf24l01p_enable_auto_ack>
	_nrf24l01p_enable_auto_ack(_NRF24L01P_PIPE_P1);
     e5a:	81 e0       	ldi	r24, 0x01	; 1
     e5c:	0e 94 1c 09 	call	0x1238	; 0x1238 <_nrf24l01p_enable_auto_ack>
	_nrf24l01p_enable_auto_ack(_NRF24L01P_PIPE_P2);
     e60:	82 e0       	ldi	r24, 0x02	; 2
     e62:	0e 94 1c 09 	call	0x1238	; 0x1238 <_nrf24l01p_enable_auto_ack>
	_nrf24l01p_enable_auto_ack(_NRF24L01P_PIPE_P3);
     e66:	83 e0       	ldi	r24, 0x03	; 3
     e68:	0e 94 1c 09 	call	0x1238	; 0x1238 <_nrf24l01p_enable_auto_ack>
	_nrf24l01p_enable_auto_ack(_NRF24L01P_PIPE_P4);
     e6c:	84 e0       	ldi	r24, 0x04	; 4
     e6e:	0e 94 1c 09 	call	0x1238	; 0x1238 <_nrf24l01p_enable_auto_ack>
	_nrf24l01p_enable_auto_ack(_NRF24L01P_PIPE_P5);
     e72:	85 e0       	ldi	r24, 0x05	; 5
     e74:	0e 94 1c 09 	call	0x1238	; 0x1238 <_nrf24l01p_enable_auto_ack>

	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P0);
     e78:	80 e0       	ldi	r24, 0x00	; 0
     e7a:	0e 94 b6 0a 	call	0x156c	; 0x156c <_nrf24l01p_enable_dynamic_payload_pipe>
	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P1);
     e7e:	81 e0       	ldi	r24, 0x01	; 1
     e80:	0e 94 b6 0a 	call	0x156c	; 0x156c <_nrf24l01p_enable_dynamic_payload_pipe>
	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P2);
     e84:	82 e0       	ldi	r24, 0x02	; 2
     e86:	0e 94 b6 0a 	call	0x156c	; 0x156c <_nrf24l01p_enable_dynamic_payload_pipe>
	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P3);
     e8a:	83 e0       	ldi	r24, 0x03	; 3
     e8c:	0e 94 b6 0a 	call	0x156c	; 0x156c <_nrf24l01p_enable_dynamic_payload_pipe>
	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P4);
     e90:	84 e0       	ldi	r24, 0x04	; 4
     e92:	0e 94 b6 0a 	call	0x156c	; 0x156c <_nrf24l01p_enable_dynamic_payload_pipe>
	_nrf24l01p_enable_dynamic_payload_pipe(_NRF24L01P_PIPE_P5);
     e96:	85 e0       	ldi	r24, 0x05	; 5
     e98:	0e 94 b6 0a 	call	0x156c	; 0x156c <_nrf24l01p_enable_dynamic_payload_pipe>

	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P0);
     e9c:	80 e0       	ldi	r24, 0x00	; 0
     e9e:	0e 94 55 09 	call	0x12aa	; 0x12aa <_nrf24l01p_enable_rx_on_pipe>
	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P1);
     ea2:	81 e0       	ldi	r24, 0x01	; 1
     ea4:	0e 94 55 09 	call	0x12aa	; 0x12aa <_nrf24l01p_enable_rx_on_pipe>
	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P2);
     ea8:	82 e0       	ldi	r24, 0x02	; 2
     eaa:	0e 94 55 09 	call	0x12aa	; 0x12aa <_nrf24l01p_enable_rx_on_pipe>
	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P3);
     eae:	83 e0       	ldi	r24, 0x03	; 3
     eb0:	0e 94 55 09 	call	0x12aa	; 0x12aa <_nrf24l01p_enable_rx_on_pipe>
	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P4);
     eb4:	84 e0       	ldi	r24, 0x04	; 4
     eb6:	0e 94 55 09 	call	0x12aa	; 0x12aa <_nrf24l01p_enable_rx_on_pipe>
	_nrf24l01p_enable_rx_on_pipe(_NRF24L01P_PIPE_P5);
     eba:	85 e0       	ldi	r24, 0x05	; 5
     ebc:	0e 94 55 09 	call	0x12aa	; 0x12aa <_nrf24l01p_enable_rx_on_pipe>

	_nrf24l01p_set_auto_retransmission_delay(15);
     ec0:	8f e0       	ldi	r24, 0x0F	; 15
     ec2:	0e 94 7c 09 	call	0x12f8	; 0x12f8 <_nrf24l01p_set_auto_retransmission_delay>
	_nrf24l01p_set_DataRate(_NRF24L01P_RF_SETUP_RF_DR_250KBPS);
     ec6:	80 e2       	ldi	r24, 0x20	; 32
     ec8:	0e 94 a0 09 	call	0x1340	; 0x1340 <_nrf24l01p_set_DataRate>
	_nrf24l01p_flush_rx();
     ecc:	0e 94 81 08 	call	0x1102	; 0x1102 <_nrf24l01p_flush_rx>
	//LEFT
	_nrf24l01p_set_RX_pipe_address(_NRF24L01P_PIPE_P1, 0x4C4C4C4C31);
     ed0:	01 e3       	ldi	r16, 0x31	; 49
     ed2:	1c e4       	ldi	r17, 0x4C	; 76
     ed4:	2c e4       	ldi	r18, 0x4C	; 76
     ed6:	3c e4       	ldi	r19, 0x4C	; 76
     ed8:	4c e4       	ldi	r20, 0x4C	; 76
     eda:	50 e0       	ldi	r21, 0x00	; 0
     edc:	60 e0       	ldi	r22, 0x00	; 0
     ede:	70 e0       	ldi	r23, 0x00	; 0
     ee0:	81 e0       	ldi	r24, 0x01	; 1
     ee2:	0e 94 01 0a 	call	0x1402	; 0x1402 <_nrf24l01p_set_RX_pipe_address>
	_nrf24l01p_set_RX_pipe_address(_NRF24L01P_PIPE_P2, 0x4C4C4C4C32);
     ee6:	02 e3       	ldi	r16, 0x32	; 50
     ee8:	2c e4       	ldi	r18, 0x4C	; 76
     eea:	3c e4       	ldi	r19, 0x4C	; 76
     eec:	4c e4       	ldi	r20, 0x4C	; 76
     eee:	50 e0       	ldi	r21, 0x00	; 0
     ef0:	60 e0       	ldi	r22, 0x00	; 0
     ef2:	70 e0       	ldi	r23, 0x00	; 0
     ef4:	82 e0       	ldi	r24, 0x02	; 2
     ef6:	0e 94 01 0a 	call	0x1402	; 0x1402 <_nrf24l01p_set_RX_pipe_address>
	_nrf24l01p_set_RX_pipe_address(_NRF24L01P_PIPE_P3, 0x4C4C4C4C33);
     efa:	03 e3       	ldi	r16, 0x33	; 51
     efc:	2c e4       	ldi	r18, 0x4C	; 76
     efe:	3c e4       	ldi	r19, 0x4C	; 76
     f00:	4c e4       	ldi	r20, 0x4C	; 76
     f02:	50 e0       	ldi	r21, 0x00	; 0
     f04:	60 e0       	ldi	r22, 0x00	; 0
     f06:	70 e0       	ldi	r23, 0x00	; 0
     f08:	83 e0       	ldi	r24, 0x03	; 3
     f0a:	0e 94 01 0a 	call	0x1402	; 0x1402 <_nrf24l01p_set_RX_pipe_address>
	_nrf24l01p_set_RX_pipe_address(_NRF24L01P_PIPE_P4, 0x4C4C4C4C34);
     f0e:	04 e3       	ldi	r16, 0x34	; 52
     f10:	2c e4       	ldi	r18, 0x4C	; 76
     f12:	3c e4       	ldi	r19, 0x4C	; 76
     f14:	4c e4       	ldi	r20, 0x4C	; 76
     f16:	50 e0       	ldi	r21, 0x00	; 0
     f18:	60 e0       	ldi	r22, 0x00	; 0
     f1a:	70 e0       	ldi	r23, 0x00	; 0
     f1c:	84 e0       	ldi	r24, 0x04	; 4
     f1e:	0e 94 01 0a 	call	0x1402	; 0x1402 <_nrf24l01p_set_RX_pipe_address>
	_nrf24l01p_set_RX_pipe_address(_NRF24L01P_PIPE_P5, 0x4C4C4C4C35);
     f22:	05 e3       	ldi	r16, 0x35	; 53
     f24:	2c e4       	ldi	r18, 0x4C	; 76
     f26:	3c e4       	ldi	r19, 0x4C	; 76
     f28:	4c e4       	ldi	r20, 0x4C	; 76
     f2a:	50 e0       	ldi	r21, 0x00	; 0
     f2c:	60 e0       	ldi	r22, 0x00	; 0
     f2e:	70 e0       	ldi	r23, 0x00	; 0
     f30:	85 e0       	ldi	r24, 0x05	; 5
     f32:	0e 94 01 0a 	call	0x1402	; 0x1402 <_nrf24l01p_set_RX_pipe_address>
// 	_nrf24l01p_set_RX_pipe_address(_NRF24L01P_PIPE_P4, 0x5252525234);
// 	_nrf24l01p_set_RX_pipe_address(_NRF24L01P_PIPE_P5, 0x5252525235);	

	int txerr = 0;
	int passcount = 0;
	int total_count =0;
     f36:	a1 2c       	mov	r10, r1
     f38:	b1 2c       	mov	r11, r1
    while(1)
    {
 		char txData[] = "\t\t\tL";
		 
		 /*sprintf(txbuff,"\t\t\tL\t\t\t\t%d\t%d\t%d\t%d,",total_count,passcount,txerr);*/
		 sprintf(txbuff,"this is a sample text %d",total_count);
     f3a:	0f 2e       	mov	r0, r31
     f3c:	f7 e0       	ldi	r31, 0x07	; 7
     f3e:	8f 2e       	mov	r8, r31
     f40:	f1 e0       	ldi	r31, 0x01	; 1
     f42:	9f 2e       	mov	r9, r31
     f44:	f0 2d       	mov	r31, r0
     f46:	ce 01       	movw	r24, r28
     f48:	01 96       	adiw	r24, 0x01	; 1
     f4a:	6c 01       	movw	r12, r24
     f4c:	bf 92       	push	r11
     f4e:	af 92       	push	r10
     f50:	9f 92       	push	r9
     f52:	8f 92       	push	r8
     f54:	df 92       	push	r13
     f56:	cf 92       	push	r12
     f58:	0e 94 3b 0c 	call	0x1876	; 0x1876 <sprintf>
 		int txerrflag = _nrf24l01p_write_to_address_ack(0x4541525448, (uint8_t*)txbuff,strlen(txbuff));
     f5c:	f6 01       	movw	r30, r12
     f5e:	01 90       	ld	r0, Z+
     f60:	00 20       	and	r0, r0
     f62:	e9 f7       	brne	.-6      	; 0xf5e <thread_1+0x12a>
     f64:	31 97       	sbiw	r30, 0x01	; 1
     f66:	7f 01       	movw	r14, r30
     f68:	ec 18       	sub	r14, r12
     f6a:	fd 08       	sbc	r15, r13
     f6c:	86 01       	movw	r16, r12
     f6e:	28 e4       	ldi	r18, 0x48	; 72
     f70:	34 e5       	ldi	r19, 0x54	; 84
     f72:	42 e5       	ldi	r20, 0x52	; 82
     f74:	51 e4       	ldi	r21, 0x41	; 65
     f76:	65 e4       	ldi	r22, 0x45	; 69
     f78:	70 e0       	ldi	r23, 0x00	; 0
     f7a:	80 e0       	ldi	r24, 0x00	; 0
     f7c:	90 e0       	ldi	r25, 0x00	; 0
     f7e:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <_nrf24l01p_write_to_address_ack>
     f82:	0f 90       	pop	r0
     f84:	0f 90       	pop	r0
     f86:	0f 90       	pop	r0
     f88:	0f 90       	pop	r0
     f8a:	0f 90       	pop	r0
     f8c:	0f 90       	pop	r0
			 txerr++;
		 }
		 else{
			passcount++;
		 }
		total_count++;
     f8e:	9f ef       	ldi	r25, 0xFF	; 255
     f90:	a9 1a       	sub	r10, r25
     f92:	b9 0a       	sbc	r11, r25
		 vTaskDelay(1000); //wait 2 seconds
     f94:	88 ee       	ldi	r24, 0xE8	; 232
     f96:	93 e0       	ldi	r25, 0x03	; 3
     f98:	0e 94 5f 05 	call	0xabe	; 0xabe <vTaskDelay>
    }
     f9c:	d7 cf       	rjmp	.-82     	; 0xf4c <thread_1+0x118>

00000f9e <main>:
 *  setup of all components and the main program loop.
 */
int main(void)
{

	xTaskCreate(thread_1,(const char *) "t3", 200, NULL, tskIDLE_PRIORITY, NULL );
     f9e:	a1 2c       	mov	r10, r1
     fa0:	b1 2c       	mov	r11, r1
     fa2:	c1 2c       	mov	r12, r1
     fa4:	d1 2c       	mov	r13, r1
     fa6:	e1 2c       	mov	r14, r1
     fa8:	f1 2c       	mov	r15, r1
     faa:	00 e0       	ldi	r16, 0x00	; 0
     fac:	20 e0       	ldi	r18, 0x00	; 0
     fae:	30 e0       	ldi	r19, 0x00	; 0
     fb0:	48 ec       	ldi	r20, 0xC8	; 200
     fb2:	50 e0       	ldi	r21, 0x00	; 0
     fb4:	60 e2       	ldi	r22, 0x20	; 32
     fb6:	71 e0       	ldi	r23, 0x01	; 1
     fb8:	8a e1       	ldi	r24, 0x1A	; 26
     fba:	97 e0       	ldi	r25, 0x07	; 7
     fbc:	0e 94 cb 02 	call	0x596	; 0x596 <xTaskGenericCreate>
	
	//starting the scheduler
	vTaskStartScheduler();
     fc0:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <vTaskStartScheduler>
	
	
	while(1)
	{
		
	}
     fc4:	ff cf       	rjmp	.-2      	; 0xfc4 <main+0x26>

00000fc6 <arch_spi_master_transmit_byte_val>:


static uint8_t arch_spi_master_transmit_byte_val(uint8_t data)
{
	//fill SPDR with data to write
	SPDR = data;
     fc6:	8e bd       	out	0x2e, r24	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
     fc8:	0d b4       	in	r0, 0x2d	; 45
     fca:	07 fe       	sbrs	r0, 7
     fcc:	fd cf       	rjmp	.-6      	; 0xfc8 <arch_spi_master_transmit_byte_val+0x2>
	return SPDR;
     fce:	8e b5       	in	r24, 0x2e	; 46
}
     fd0:	08 95       	ret

00000fd2 <arch_spi_master_transmit_byte_ref>:

static uint8_t arch_spi_master_transmit_byte_ref(uint8_t *data)
{
	//fill SPDR with data to write
	SPDR = *data;
     fd2:	fc 01       	movw	r30, r24
     fd4:	80 81       	ld	r24, Z
     fd6:	8e bd       	out	0x2e, r24	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
     fd8:	0d b4       	in	r0, 0x2d	; 45
     fda:	07 fe       	sbrs	r0, 7
     fdc:	fd cf       	rjmp	.-6      	; 0xfd8 <arch_spi_master_transmit_byte_ref+0x6>
	return SPDR;
     fde:	8e b5       	in	r24, 0x2e	; 46
}
     fe0:	08 95       	ret

00000fe2 <_nrf24l01p_ce_pin>:
#define SPI_SS_PORT	PORTB
#define SPI_SS_BIT		0


static void arch_nrf24l01p_ce_pin(bool state){
	if(state){set_bit(CE_PORT,CE_PIN_BIT);}
     fe2:	88 23       	and	r24, r24
     fe4:	11 f0       	breq	.+4      	; 0xfea <_nrf24l01p_ce_pin+0x8>
     fe6:	2c 9a       	sbi	0x05, 4	; 5
     fe8:	01 c0       	rjmp	.+2      	; 0xfec <_nrf24l01p_ce_pin+0xa>
	else {clr_bit(CE_PORT,CE_PIN_BIT);}
     fea:	2c 98       	cbi	0x05, 4	; 5
#include "nrf24l01p.h"


void _nrf24l01p_ce_pin(bool state){
	arch_nrf24l01p_ce_pin(state);
	ce_value = state;
     fec:	80 93 d7 04 	sts	0x04D7, r24
     ff0:	08 95       	ret

00000ff2 <_nrf24l01p_csn_pin>:

	
}

static void arch_nrf24l01p_csn_pin(bool state){
	if(state){set_bit(CSN_PORT,CSN_PIN_BIT);}
     ff2:	88 23       	and	r24, r24
     ff4:	11 f0       	breq	.+4      	; 0xffa <_nrf24l01p_csn_pin+0x8>
     ff6:	5f 9a       	sbi	0x0b, 7	; 11
     ff8:	01 c0       	rjmp	.+2      	; 0xffc <_nrf24l01p_csn_pin+0xa>
	else {clr_bit(CSN_PORT,CSN_PIN_BIT);}
     ffa:	5f 98       	cbi	0x0b, 7	; 11
}
void _nrf24l01p_csn_pin(bool state){

	arch_nrf24l01p_csn_pin(state);
	csn_value = state;
     ffc:	80 93 d6 04 	sts	0x04D6, r24
    1000:	08 95       	ret

00001002 <_nrf24l01p_read_register>:
	_nrf24l01p_disable_dynamic_payload_all_pipe();/////////ALSO CREEATE FOR DISABLE AUTO ACK FOR ALL PIPE
	_nrf24l01p_startup();
	
}

void _nrf24l01p_read_register(uint8_t address, uint8_t *dataout, int len){
    1002:	ff 92       	push	r15
    1004:	0f 93       	push	r16
    1006:	1f 93       	push	r17
    1008:	cf 93       	push	r28
    100a:	df 93       	push	r29
    100c:	f8 2e       	mov	r15, r24
    100e:	8b 01       	movw	r16, r22
    1010:	ea 01       	movw	r28, r20
	_nrf24l01p_csn_pin(0);
    1012:	80 e0       	ldi	r24, 0x00	; 0
    1014:	0e 94 f9 07 	call	0xff2	; 0xff2 <_nrf24l01p_csn_pin>
	arch_spi_master_transmit_byte_val(address&(_NRF24L01P_REG_ADDRESS_MASK));
    1018:	8f 2d       	mov	r24, r15
    101a:	8f 71       	andi	r24, 0x1F	; 31
    101c:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <arch_spi_master_transmit_byte_val>
	for(int i=0;i<len;i++){
    1020:	1c 16       	cp	r1, r28
    1022:	1d 06       	cpc	r1, r29
    1024:	74 f4       	brge	.+28     	; 0x1042 <_nrf24l01p_read_register+0x40>
    1026:	f8 01       	movw	r30, r16
    1028:	a8 01       	movw	r20, r16
    102a:	4c 0f       	add	r20, r28
    102c:	5d 1f       	adc	r21, r29
	return SPDR;
}

static void arch_spi_master_receive_byte_ref(uint8_t *data){
	//fill SPDR with data to write
	SPDR = 0xFF;
    102e:	9f ef       	ldi	r25, 0xFF	; 255
    1030:	9e bd       	out	0x2e, r25	; 46
	//wait for transmission to complete
	while(!(SPSR&(1<<SPIF)));
    1032:	0d b4       	in	r0, 0x2d	; 45
    1034:	07 fe       	sbrs	r0, 7
    1036:	fd cf       	rjmp	.-6      	; 0x1032 <_nrf24l01p_read_register+0x30>
	*data = SPDR;
    1038:	8e b5       	in	r24, 0x2e	; 46
    103a:	81 93       	st	Z+, r24
    103c:	e4 17       	cp	r30, r20
    103e:	f5 07       	cpc	r31, r21
    1040:	b9 f7       	brne	.-18     	; 0x1030 <_nrf24l01p_read_register+0x2e>
		arch_spi_master_receive_byte_ref(dataout+ i);
	}
	_nrf24l01p_csn_pin(1);
    1042:	81 e0       	ldi	r24, 0x01	; 1
    1044:	0e 94 f9 07 	call	0xff2	; 0xff2 <_nrf24l01p_csn_pin>
}
    1048:	df 91       	pop	r29
    104a:	cf 91       	pop	r28
    104c:	1f 91       	pop	r17
    104e:	0f 91       	pop	r16
    1050:	ff 90       	pop	r15
    1052:	08 95       	ret

00001054 <_nrf24l01p_write_register>:

void _nrf24l01p_write_register(uint8_t address, uint8_t *datain, int len){
    1054:	ef 92       	push	r14
    1056:	ff 92       	push	r15
    1058:	0f 93       	push	r16
    105a:	1f 93       	push	r17
    105c:	cf 93       	push	r28
    105e:	df 93       	push	r29
    1060:	c8 2f       	mov	r28, r24
    1062:	7b 01       	movw	r14, r22
    1064:	8a 01       	movw	r16, r20
	_nrf24l01p_csn_pin(0);
    1066:	80 e0       	ldi	r24, 0x00	; 0
    1068:	0e 94 f9 07 	call	0xff2	; 0xff2 <_nrf24l01p_csn_pin>
	arch_spi_master_transmit_byte_val(( _NRF24L01P_SPI_CMD_WR_REG | (address&(_NRF24L01P_REG_ADDRESS_MASK))));
    106c:	8c 2f       	mov	r24, r28
    106e:	8f 71       	andi	r24, 0x1F	; 31
    1070:	80 62       	ori	r24, 0x20	; 32
    1072:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <arch_spi_master_transmit_byte_val>
	for(int i=0;i<len;i++){
    1076:	10 16       	cp	r1, r16
    1078:	11 06       	cpc	r1, r17
    107a:	54 f4       	brge	.+20     	; 0x1090 <_nrf24l01p_write_register+0x3c>
    107c:	e7 01       	movw	r28, r14
    107e:	0e 0d       	add	r16, r14
    1080:	1f 1d       	adc	r17, r15
		arch_spi_master_transmit_byte_ref(datain+i);
    1082:	ce 01       	movw	r24, r28
    1084:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <arch_spi_master_transmit_byte_ref>
    1088:	21 96       	adiw	r28, 0x01	; 1
}

void _nrf24l01p_write_register(uint8_t address, uint8_t *datain, int len){
	_nrf24l01p_csn_pin(0);
	arch_spi_master_transmit_byte_val(( _NRF24L01P_SPI_CMD_WR_REG | (address&(_NRF24L01P_REG_ADDRESS_MASK))));
	for(int i=0;i<len;i++){
    108a:	c0 17       	cp	r28, r16
    108c:	d1 07       	cpc	r29, r17
    108e:	c9 f7       	brne	.-14     	; 0x1082 <_nrf24l01p_write_register+0x2e>
		arch_spi_master_transmit_byte_ref(datain+i);
	}
	_nrf24l01p_csn_pin(1);
    1090:	81 e0       	ldi	r24, 0x01	; 1
    1092:	0e 94 f9 07 	call	0xff2	; 0xff2 <_nrf24l01p_csn_pin>
}
    1096:	df 91       	pop	r29
    1098:	cf 91       	pop	r28
    109a:	1f 91       	pop	r17
    109c:	0f 91       	pop	r16
    109e:	ff 90       	pop	r15
    10a0:	ef 90       	pop	r14
    10a2:	08 95       	ret

000010a4 <_nrf24l01p_write_tx_payload>:
	for(int i=0;i<pay_len;i++){
		arch_spi_master_receive_byte_ref(dataout+ i);
	}
	_nrf24l01p_csn_pin(1);
}
void _nrf24l01p_write_tx_payload(uint8_t *datain, int pay_len){
    10a4:	ef 92       	push	r14
    10a6:	ff 92       	push	r15
    10a8:	0f 93       	push	r16
    10aa:	1f 93       	push	r17
    10ac:	cf 93       	push	r28
    10ae:	df 93       	push	r29
    10b0:	7c 01       	movw	r14, r24
    10b2:	8b 01       	movw	r16, r22
	_nrf24l01p_csn_pin(0);
    10b4:	80 e0       	ldi	r24, 0x00	; 0
    10b6:	0e 94 f9 07 	call	0xff2	; 0xff2 <_nrf24l01p_csn_pin>
	arch_spi_master_transmit_byte_val(_NRF24L01P_SPI_CMD_WR_TX_PAYLOAD);
    10ba:	80 ea       	ldi	r24, 0xA0	; 160
    10bc:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <arch_spi_master_transmit_byte_val>
	for(int i=0;i<pay_len;i++){
    10c0:	10 16       	cp	r1, r16
    10c2:	11 06       	cpc	r1, r17
    10c4:	54 f4       	brge	.+20     	; 0x10da <_nrf24l01p_write_tx_payload+0x36>
    10c6:	e7 01       	movw	r28, r14
    10c8:	0e 0d       	add	r16, r14
    10ca:	1f 1d       	adc	r17, r15
		arch_spi_master_transmit_byte_ref(datain+i);
    10cc:	ce 01       	movw	r24, r28
    10ce:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <arch_spi_master_transmit_byte_ref>
    10d2:	21 96       	adiw	r28, 0x01	; 1
	_nrf24l01p_csn_pin(1);
}
void _nrf24l01p_write_tx_payload(uint8_t *datain, int pay_len){
	_nrf24l01p_csn_pin(0);
	arch_spi_master_transmit_byte_val(_NRF24L01P_SPI_CMD_WR_TX_PAYLOAD);
	for(int i=0;i<pay_len;i++){
    10d4:	c0 17       	cp	r28, r16
    10d6:	d1 07       	cpc	r29, r17
    10d8:	c9 f7       	brne	.-14     	; 0x10cc <_nrf24l01p_write_tx_payload+0x28>
		arch_spi_master_transmit_byte_ref(datain+i);
	}
	_nrf24l01p_csn_pin(1);
    10da:	81 e0       	ldi	r24, 0x01	; 1
    10dc:	0e 94 f9 07 	call	0xff2	; 0xff2 <_nrf24l01p_csn_pin>
}
    10e0:	df 91       	pop	r29
    10e2:	cf 91       	pop	r28
    10e4:	1f 91       	pop	r17
    10e6:	0f 91       	pop	r16
    10e8:	ff 90       	pop	r15
    10ea:	ef 90       	pop	r14
    10ec:	08 95       	ret

000010ee <_nrf24l01p_flush_tx>:

void _nrf24l01p_flush_tx(){
	_nrf24l01p_csn_pin(0);
    10ee:	80 e0       	ldi	r24, 0x00	; 0
    10f0:	0e 94 f9 07 	call	0xff2	; 0xff2 <_nrf24l01p_csn_pin>
	arch_spi_master_transmit_byte_val(_NRF24L01P_SPI_CMD_FLUSH_TX);
    10f4:	81 ee       	ldi	r24, 0xE1	; 225
    10f6:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <arch_spi_master_transmit_byte_val>
	_nrf24l01p_csn_pin(1);
    10fa:	81 e0       	ldi	r24, 0x01	; 1
    10fc:	0e 94 f9 07 	call	0xff2	; 0xff2 <_nrf24l01p_csn_pin>
    1100:	08 95       	ret

00001102 <_nrf24l01p_flush_rx>:
}
void _nrf24l01p_flush_rx(){
	_nrf24l01p_csn_pin(0);
    1102:	80 e0       	ldi	r24, 0x00	; 0
    1104:	0e 94 f9 07 	call	0xff2	; 0xff2 <_nrf24l01p_csn_pin>
	arch_spi_master_transmit_byte_val(_NRF24L01P_SPI_CMD_FLUSH_RX);
    1108:	82 ee       	ldi	r24, 0xE2	; 226
    110a:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <arch_spi_master_transmit_byte_val>
	_nrf24l01p_csn_pin(1);
    110e:	81 e0       	ldi	r24, 0x01	; 1
    1110:	0e 94 f9 07 	call	0xff2	; 0xff2 <_nrf24l01p_csn_pin>
    1114:	08 95       	ret

00001116 <_nrf24l01p_get_status>:
		arch_spi_master_transmit_byte_ref(datain+i);
	}
	_nrf24l01p_csn_pin(1);
}

int _nrf24l01p_get_status(){
    1116:	cf 93       	push	r28
	_nrf24l01p_csn_pin(0);
    1118:	80 e0       	ldi	r24, 0x00	; 0
    111a:	0e 94 f9 07 	call	0xff2	; 0xff2 <_nrf24l01p_csn_pin>
	int temp = arch_spi_master_transmit_byte_val(_NRF24L01P_SPI_CMD_NOP);
    111e:	8f ef       	ldi	r24, 0xFF	; 255
    1120:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <arch_spi_master_transmit_byte_val>
    1124:	c8 2f       	mov	r28, r24
	_nrf24l01p_csn_pin(1);
    1126:	81 e0       	ldi	r24, 0x01	; 1
    1128:	0e 94 f9 07 	call	0xff2	; 0xff2 <_nrf24l01p_csn_pin>
	
	return temp;
}
    112c:	8c 2f       	mov	r24, r28
    112e:	90 e0       	ldi	r25, 0x00	; 0
    1130:	cf 91       	pop	r28
    1132:	08 95       	ret

00001134 <_nrf24l01p_power_up>:

void _nrf24l01p_power_up(){
    1134:	cf 93       	push	r28
    1136:	df 93       	push	r29
    1138:	1f 92       	push	r1
    113a:	cd b7       	in	r28, 0x3d	; 61
    113c:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
    113e:	41 e0       	ldi	r20, 0x01	; 1
    1140:	50 e0       	ldi	r21, 0x00	; 0
    1142:	be 01       	movw	r22, r28
    1144:	6f 5f       	subi	r22, 0xFF	; 255
    1146:	7f 4f       	sbci	r23, 0xFF	; 255
    1148:	80 e0       	ldi	r24, 0x00	; 0
    114a:	0e 94 01 08 	call	0x1002	; 0x1002 <_nrf24l01p_read_register>
	temp |= _NRF24L01P_CONFIG_PWR_UP;
    114e:	89 81       	ldd	r24, Y+1	; 0x01
    1150:	82 60       	ori	r24, 0x02	; 2
    1152:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
    1154:	41 e0       	ldi	r20, 0x01	; 1
    1156:	50 e0       	ldi	r21, 0x00	; 0
    1158:	be 01       	movw	r22, r28
    115a:	6f 5f       	subi	r22, 0xFF	; 255
    115c:	7f 4f       	sbci	r23, 0xFF	; 255
    115e:	80 e0       	ldi	r24, 0x00	; 0
    1160:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1164:	8f e4       	ldi	r24, 0x4F	; 79
    1166:	96 e4       	ldi	r25, 0x46	; 70
    1168:	01 97       	sbiw	r24, 0x01	; 1
    116a:	f1 f7       	brne	.-4      	; 0x1168 <_nrf24l01p_power_up+0x34>
    116c:	00 c0       	rjmp	.+0      	; 0x116e <_nrf24l01p_power_up+0x3a>
    116e:	00 00       	nop
	_nrf24l01p_delay_us(_NRF24L01P_TIMING_Tpd2stby_us);
	mode = _NRF24L01P_MODE_STANDBY;
    1170:	82 e0       	ldi	r24, 0x02	; 2
    1172:	80 93 d8 04 	sts	0x04D8, r24
}
    1176:	0f 90       	pop	r0
    1178:	df 91       	pop	r29
    117a:	cf 91       	pop	r28
    117c:	08 95       	ret

0000117e <_nrf24l01p_power_down>:
void _nrf24l01p_power_down(){
    117e:	cf 93       	push	r28
    1180:	df 93       	push	r29
    1182:	1f 92       	push	r1
    1184:	cd b7       	in	r28, 0x3d	; 61
    1186:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
    1188:	41 e0       	ldi	r20, 0x01	; 1
    118a:	50 e0       	ldi	r21, 0x00	; 0
    118c:	be 01       	movw	r22, r28
    118e:	6f 5f       	subi	r22, 0xFF	; 255
    1190:	7f 4f       	sbci	r23, 0xFF	; 255
    1192:	80 e0       	ldi	r24, 0x00	; 0
    1194:	0e 94 01 08 	call	0x1002	; 0x1002 <_nrf24l01p_read_register>
	temp &= ~_NRF24L01P_CONFIG_PWR_UP;
    1198:	89 81       	ldd	r24, Y+1	; 0x01
    119a:	8d 7f       	andi	r24, 0xFD	; 253
    119c:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
    119e:	41 e0       	ldi	r20, 0x01	; 1
    11a0:	50 e0       	ldi	r21, 0x00	; 0
    11a2:	be 01       	movw	r22, r28
    11a4:	6f 5f       	subi	r22, 0xFF	; 255
    11a6:	7f 4f       	sbci	r23, 0xFF	; 255
    11a8:	80 e0       	ldi	r24, 0x00	; 0
    11aa:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
	mode = _NRF24L01P_MODE_POWER_DOWN;
    11ae:	81 e0       	ldi	r24, 0x01	; 1
    11b0:	80 93 d8 04 	sts	0x04D8, r24
}
    11b4:	0f 90       	pop	r0
    11b6:	df 91       	pop	r29
    11b8:	cf 91       	pop	r28
    11ba:	08 95       	ret

000011bc <_nrf24l01p_rx_mode>:
void _nrf24l01p_rx_mode(){
    11bc:	cf 93       	push	r28
    11be:	df 93       	push	r29
    11c0:	1f 92       	push	r1
    11c2:	cd b7       	in	r28, 0x3d	; 61
    11c4:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
    11c6:	41 e0       	ldi	r20, 0x01	; 1
    11c8:	50 e0       	ldi	r21, 0x00	; 0
    11ca:	be 01       	movw	r22, r28
    11cc:	6f 5f       	subi	r22, 0xFF	; 255
    11ce:	7f 4f       	sbci	r23, 0xFF	; 255
    11d0:	80 e0       	ldi	r24, 0x00	; 0
    11d2:	0e 94 01 08 	call	0x1002	; 0x1002 <_nrf24l01p_read_register>
	temp |= _NRF24L01P_CONFIG_PRIM_RX;
    11d6:	89 81       	ldd	r24, Y+1	; 0x01
    11d8:	81 60       	ori	r24, 0x01	; 1
    11da:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
    11dc:	41 e0       	ldi	r20, 0x01	; 1
    11de:	50 e0       	ldi	r21, 0x00	; 0
    11e0:	be 01       	movw	r22, r28
    11e2:	6f 5f       	subi	r22, 0xFF	; 255
    11e4:	7f 4f       	sbci	r23, 0xFF	; 255
    11e6:	80 e0       	ldi	r24, 0x00	; 0
    11e8:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
	mode = _NRF24L01P_MODE_RX;
    11ec:	83 e0       	ldi	r24, 0x03	; 3
    11ee:	80 93 d8 04 	sts	0x04D8, r24
}
    11f2:	0f 90       	pop	r0
    11f4:	df 91       	pop	r29
    11f6:	cf 91       	pop	r28
    11f8:	08 95       	ret

000011fa <_nrf24l01p_tx_mode>:
void _nrf24l01p_tx_mode(){
    11fa:	cf 93       	push	r28
    11fc:	df 93       	push	r29
    11fe:	1f 92       	push	r1
    1200:	cd b7       	in	r28, 0x3d	; 61
    1202:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
    1204:	41 e0       	ldi	r20, 0x01	; 1
    1206:	50 e0       	ldi	r21, 0x00	; 0
    1208:	be 01       	movw	r22, r28
    120a:	6f 5f       	subi	r22, 0xFF	; 255
    120c:	7f 4f       	sbci	r23, 0xFF	; 255
    120e:	80 e0       	ldi	r24, 0x00	; 0
    1210:	0e 94 01 08 	call	0x1002	; 0x1002 <_nrf24l01p_read_register>
	temp &= ~_NRF24L01P_CONFIG_PRIM_RX;
    1214:	89 81       	ldd	r24, Y+1	; 0x01
    1216:	8e 7f       	andi	r24, 0xFE	; 254
    1218:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
    121a:	41 e0       	ldi	r20, 0x01	; 1
    121c:	50 e0       	ldi	r21, 0x00	; 0
    121e:	be 01       	movw	r22, r28
    1220:	6f 5f       	subi	r22, 0xFF	; 255
    1222:	7f 4f       	sbci	r23, 0xFF	; 255
    1224:	80 e0       	ldi	r24, 0x00	; 0
    1226:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
	mode = _NRF24L01P_MODE_TX;
    122a:	84 e0       	ldi	r24, 0x04	; 4
    122c:	80 93 d8 04 	sts	0x04D8, r24
}
    1230:	0f 90       	pop	r0
    1232:	df 91       	pop	r29
    1234:	cf 91       	pop	r28
    1236:	08 95       	ret

00001238 <_nrf24l01p_enable_auto_ack>:
	temp &= ~(_NRF24L01P_CONFIG_CRC_MASK);
	temp |= opt;
	_nrf24l01p_write_register(_NRF24L01P_REG_CONFIG,&temp,sizeof(temp));
}

void _nrf24l01p_enable_auto_ack(_nrf24l01p_pipe_t pipe){
    1238:	1f 93       	push	r17
    123a:	cf 93       	push	r28
    123c:	df 93       	push	r29
    123e:	1f 92       	push	r1
    1240:	cd b7       	in	r28, 0x3d	; 61
    1242:	de b7       	in	r29, 0x3e	; 62
    1244:	18 2f       	mov	r17, r24
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_EN_AA,&temp,sizeof(temp));
    1246:	41 e0       	ldi	r20, 0x01	; 1
    1248:	50 e0       	ldi	r21, 0x00	; 0
    124a:	be 01       	movw	r22, r28
    124c:	6f 5f       	subi	r22, 0xFF	; 255
    124e:	7f 4f       	sbci	r23, 0xFF	; 255
    1250:	81 e0       	ldi	r24, 0x01	; 1
    1252:	0e 94 01 08 	call	0x1002	; 0x1002 <_nrf24l01p_read_register>
	set_bit(temp,pipe);
    1256:	21 e0       	ldi	r18, 0x01	; 1
    1258:	30 e0       	ldi	r19, 0x00	; 0
    125a:	c9 01       	movw	r24, r18
    125c:	02 c0       	rjmp	.+4      	; 0x1262 <_nrf24l01p_enable_auto_ack+0x2a>
    125e:	88 0f       	add	r24, r24
    1260:	99 1f       	adc	r25, r25
    1262:	1a 95       	dec	r17
    1264:	e2 f7       	brpl	.-8      	; 0x125e <_nrf24l01p_enable_auto_ack+0x26>
    1266:	99 81       	ldd	r25, Y+1	; 0x01
    1268:	89 2b       	or	r24, r25
    126a:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_EN_AA,&temp,sizeof(temp));
    126c:	41 e0       	ldi	r20, 0x01	; 1
    126e:	50 e0       	ldi	r21, 0x00	; 0
    1270:	be 01       	movw	r22, r28
    1272:	6f 5f       	subi	r22, 0xFF	; 255
    1274:	7f 4f       	sbci	r23, 0xFF	; 255
    1276:	81 e0       	ldi	r24, 0x01	; 1
    1278:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
}
    127c:	0f 90       	pop	r0
    127e:	df 91       	pop	r29
    1280:	cf 91       	pop	r28
    1282:	1f 91       	pop	r17
    1284:	08 95       	ret

00001286 <_nrf24l01p_disable_auto_ack_all_pipes>:
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_EN_AA,&temp,sizeof(temp));
	clr_bit(temp,pipe);
	_nrf24l01p_write_register(_NRF24L01P_REG_EN_AA,&temp,sizeof(temp));
}
void _nrf24l01p_disable_auto_ack_all_pipes(){
    1286:	cf 93       	push	r28
    1288:	df 93       	push	r29
    128a:	1f 92       	push	r1
    128c:	cd b7       	in	r28, 0x3d	; 61
    128e:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp = 0;
    1290:	19 82       	std	Y+1, r1	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_EN_AA,&temp,sizeof(temp));
    1292:	41 e0       	ldi	r20, 0x01	; 1
    1294:	50 e0       	ldi	r21, 0x00	; 0
    1296:	be 01       	movw	r22, r28
    1298:	6f 5f       	subi	r22, 0xFF	; 255
    129a:	7f 4f       	sbci	r23, 0xFF	; 255
    129c:	81 e0       	ldi	r24, 0x01	; 1
    129e:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
}
    12a2:	0f 90       	pop	r0
    12a4:	df 91       	pop	r29
    12a6:	cf 91       	pop	r28
    12a8:	08 95       	ret

000012aa <_nrf24l01p_enable_rx_on_pipe>:

void _nrf24l01p_enable_rx_on_pipe(_nrf24l01p_pipe_t pipe){
    12aa:	1f 93       	push	r17
    12ac:	cf 93       	push	r28
    12ae:	df 93       	push	r29
    12b0:	1f 92       	push	r1
    12b2:	cd b7       	in	r28, 0x3d	; 61
    12b4:	de b7       	in	r29, 0x3e	; 62
    12b6:	18 2f       	mov	r17, r24
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_EN_RXADDR,&temp,sizeof(temp));
    12b8:	41 e0       	ldi	r20, 0x01	; 1
    12ba:	50 e0       	ldi	r21, 0x00	; 0
    12bc:	be 01       	movw	r22, r28
    12be:	6f 5f       	subi	r22, 0xFF	; 255
    12c0:	7f 4f       	sbci	r23, 0xFF	; 255
    12c2:	82 e0       	ldi	r24, 0x02	; 2
    12c4:	0e 94 01 08 	call	0x1002	; 0x1002 <_nrf24l01p_read_register>
	set_bit(temp,pipe);
    12c8:	21 e0       	ldi	r18, 0x01	; 1
    12ca:	30 e0       	ldi	r19, 0x00	; 0
    12cc:	c9 01       	movw	r24, r18
    12ce:	02 c0       	rjmp	.+4      	; 0x12d4 <_nrf24l01p_enable_rx_on_pipe+0x2a>
    12d0:	88 0f       	add	r24, r24
    12d2:	99 1f       	adc	r25, r25
    12d4:	1a 95       	dec	r17
    12d6:	e2 f7       	brpl	.-8      	; 0x12d0 <_nrf24l01p_enable_rx_on_pipe+0x26>
    12d8:	99 81       	ldd	r25, Y+1	; 0x01
    12da:	89 2b       	or	r24, r25
    12dc:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_EN_RXADDR,&temp,sizeof(temp));
    12de:	41 e0       	ldi	r20, 0x01	; 1
    12e0:	50 e0       	ldi	r21, 0x00	; 0
    12e2:	be 01       	movw	r22, r28
    12e4:	6f 5f       	subi	r22, 0xFF	; 255
    12e6:	7f 4f       	sbci	r23, 0xFF	; 255
    12e8:	82 e0       	ldi	r24, 0x02	; 2
    12ea:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
}
    12ee:	0f 90       	pop	r0
    12f0:	df 91       	pop	r29
    12f2:	cf 91       	pop	r28
    12f4:	1f 91       	pop	r17
    12f6:	08 95       	ret

000012f8 <_nrf24l01p_set_auto_retransmission_delay>:
uint8_t _nrf24l01p_read_auto_retransmission_count(){
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_SETUP_RETR,&temp,sizeof(temp));
	return temp & 0x0F;
}
void _nrf24l01p_set_auto_retransmission_delay(uint8_t times250us){
    12f8:	1f 93       	push	r17
    12fa:	cf 93       	push	r28
    12fc:	df 93       	push	r29
    12fe:	1f 92       	push	r1
    1300:	cd b7       	in	r28, 0x3d	; 61
    1302:	de b7       	in	r29, 0x3e	; 62
    1304:	18 2f       	mov	r17, r24
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_SETUP_RETR,&temp,sizeof(temp));
    1306:	41 e0       	ldi	r20, 0x01	; 1
    1308:	50 e0       	ldi	r21, 0x00	; 0
    130a:	be 01       	movw	r22, r28
    130c:	6f 5f       	subi	r22, 0xFF	; 255
    130e:	7f 4f       	sbci	r23, 0xFF	; 255
    1310:	84 e0       	ldi	r24, 0x04	; 4
    1312:	0e 94 01 08 	call	0x1002	; 0x1002 <_nrf24l01p_read_register>
	temp &= ~(0xF0);
	temp |= (times250us<<4);
    1316:	20 e1       	ldi	r18, 0x10	; 16
    1318:	12 9f       	mul	r17, r18
    131a:	c0 01       	movw	r24, r0
    131c:	11 24       	eor	r1, r1
	return temp & 0x0F;
}
void _nrf24l01p_set_auto_retransmission_delay(uint8_t times250us){
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_SETUP_RETR,&temp,sizeof(temp));
	temp &= ~(0xF0);
    131e:	99 81       	ldd	r25, Y+1	; 0x01
    1320:	9f 70       	andi	r25, 0x0F	; 15
	temp |= (times250us<<4);
    1322:	89 2b       	or	r24, r25
    1324:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_SETUP_RETR,&temp,sizeof(temp));
    1326:	41 e0       	ldi	r20, 0x01	; 1
    1328:	50 e0       	ldi	r21, 0x00	; 0
    132a:	be 01       	movw	r22, r28
    132c:	6f 5f       	subi	r22, 0xFF	; 255
    132e:	7f 4f       	sbci	r23, 0xFF	; 255
    1330:	84 e0       	ldi	r24, 0x04	; 4
    1332:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
}
    1336:	0f 90       	pop	r0
    1338:	df 91       	pop	r29
    133a:	cf 91       	pop	r28
    133c:	1f 91       	pop	r17
    133e:	08 95       	ret

00001340 <_nrf24l01p_set_DataRate>:
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_RF_CH,&temp,sizeof(temp));
	return temp;
}

void _nrf24l01p_set_DataRate(_nrf24l01p_datarate_t DataRate){
    1340:	1f 93       	push	r17
    1342:	cf 93       	push	r28
    1344:	df 93       	push	r29
    1346:	1f 92       	push	r1
    1348:	cd b7       	in	r28, 0x3d	; 61
    134a:	de b7       	in	r29, 0x3e	; 62
    134c:	18 2f       	mov	r17, r24
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_RF_SETUP,&temp,sizeof(temp));
    134e:	41 e0       	ldi	r20, 0x01	; 1
    1350:	50 e0       	ldi	r21, 0x00	; 0
    1352:	be 01       	movw	r22, r28
    1354:	6f 5f       	subi	r22, 0xFF	; 255
    1356:	7f 4f       	sbci	r23, 0xFF	; 255
    1358:	86 e0       	ldi	r24, 0x06	; 6
    135a:	0e 94 01 08 	call	0x1002	; 0x1002 <_nrf24l01p_read_register>
	temp &= ~_NRF24L01P_RF_SETUP_RF_DR_MASK;
    135e:	99 81       	ldd	r25, Y+1	; 0x01
    1360:	97 7d       	andi	r25, 0xD7	; 215
	temp |= DataRate;
    1362:	81 2f       	mov	r24, r17
    1364:	89 2b       	or	r24, r25
    1366:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_RF_SETUP,&temp,sizeof(temp));
    1368:	41 e0       	ldi	r20, 0x01	; 1
    136a:	50 e0       	ldi	r21, 0x00	; 0
    136c:	be 01       	movw	r22, r28
    136e:	6f 5f       	subi	r22, 0xFF	; 255
    1370:	7f 4f       	sbci	r23, 0xFF	; 255
    1372:	86 e0       	ldi	r24, 0x06	; 6
    1374:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
	
}
    1378:	0f 90       	pop	r0
    137a:	df 91       	pop	r29
    137c:	cf 91       	pop	r28
    137e:	1f 91       	pop	r17
    1380:	08 95       	ret

00001382 <_nrf24l01p_get_max_retry_flag>:
	return flag;
}
bool _nrf24l01p_get_max_retry_flag(){
	bool flag;
	//(_nrf24l01p_get_status()&_NRF24L01P_STATUS_MAX_RT)?flag = 1 : flag = 0;
	if(_nrf24l01p_get_status()&_NRF24L01P_STATUS_MAX_RT) flag = 1;
    1382:	0e 94 8b 08 	call	0x1116	; 0x1116 <_nrf24l01p_get_status>
    1386:	92 95       	swap	r25
    1388:	82 95       	swap	r24
    138a:	8f 70       	andi	r24, 0x0F	; 15
    138c:	89 27       	eor	r24, r25
    138e:	9f 70       	andi	r25, 0x0F	; 15
    1390:	89 27       	eor	r24, r25
	else flag  = 0;
	return flag;
}
    1392:	81 70       	andi	r24, 0x01	; 1
    1394:	08 95       	ret

00001396 <_nrf24l01p_clear_max_retry_flag>:


void _nrf24l01p_clear_max_retry_flag(){
    1396:	cf 93       	push	r28
    1398:	df 93       	push	r29
    139a:	1f 92       	push	r1
    139c:	cd b7       	in	r28, 0x3d	; 61
    139e:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp = _nrf24l01p_get_status();
    13a0:	0e 94 8b 08 	call	0x1116	; 0x1116 <_nrf24l01p_get_status>
	temp |= _NRF24L01P_STATUS_MAX_RT;
    13a4:	80 61       	ori	r24, 0x10	; 16
    13a6:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_STATUS,&temp,sizeof(temp));
    13a8:	41 e0       	ldi	r20, 0x01	; 1
    13aa:	50 e0       	ldi	r21, 0x00	; 0
    13ac:	be 01       	movw	r22, r28
    13ae:	6f 5f       	subi	r22, 0xFF	; 255
    13b0:	7f 4f       	sbci	r23, 0xFF	; 255
    13b2:	87 e0       	ldi	r24, 0x07	; 7
    13b4:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
}
    13b8:	0f 90       	pop	r0
    13ba:	df 91       	pop	r29
    13bc:	cf 91       	pop	r28
    13be:	08 95       	ret

000013c0 <_nrf24l01p_get_data_sent_flag>:

bool _nrf24l01p_get_data_sent_flag(){
	bool flag;
	//(_nrf24l01p_get_status()&_NRF24L01P_STATUS_TX_DS)?flag = 1 : flag = 0;
	if(_nrf24l01p_get_status()&_NRF24L01P_STATUS_TX_DS) flag = 1;
    13c0:	0e 94 8b 08 	call	0x1116	; 0x1116 <_nrf24l01p_get_status>
    13c4:	96 95       	lsr	r25
    13c6:	87 95       	ror	r24
    13c8:	92 95       	swap	r25
    13ca:	82 95       	swap	r24
    13cc:	8f 70       	andi	r24, 0x0F	; 15
    13ce:	89 27       	eor	r24, r25
    13d0:	9f 70       	andi	r25, 0x0F	; 15
    13d2:	89 27       	eor	r24, r25
	else flag  = 0;
	return flag;
}
    13d4:	81 70       	andi	r24, 0x01	; 1
    13d6:	08 95       	ret

000013d8 <_nrf24l01p_clear_data_sent_flag>:

void _nrf24l01p_clear_data_sent_flag(){
    13d8:	cf 93       	push	r28
    13da:	df 93       	push	r29
    13dc:	1f 92       	push	r1
    13de:	cd b7       	in	r28, 0x3d	; 61
    13e0:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp = _nrf24l01p_get_status();
    13e2:	0e 94 8b 08 	call	0x1116	; 0x1116 <_nrf24l01p_get_status>
	temp |= _NRF24L01P_STATUS_TX_DS;
    13e6:	80 62       	ori	r24, 0x20	; 32
    13e8:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_STATUS,&temp,sizeof(temp));
    13ea:	41 e0       	ldi	r20, 0x01	; 1
    13ec:	50 e0       	ldi	r21, 0x00	; 0
    13ee:	be 01       	movw	r22, r28
    13f0:	6f 5f       	subi	r22, 0xFF	; 255
    13f2:	7f 4f       	sbci	r23, 0xFF	; 255
    13f4:	87 e0       	ldi	r24, 0x07	; 7
    13f6:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
}
    13fa:	0f 90       	pop	r0
    13fc:	df 91       	pop	r29
    13fe:	cf 91       	pop	r28
    1400:	08 95       	ret

00001402 <_nrf24l01p_set_RX_pipe_address>:
	if(temp!=0) flag = 1  ;
	else flag = 0;
	return flag;
}

void _nrf24l01p_set_RX_pipe_address(_nrf24l01p_pipe_t pipe,uint64_t address){
    1402:	2f 92       	push	r2
    1404:	3f 92       	push	r3
    1406:	4f 92       	push	r4
    1408:	5f 92       	push	r5
    140a:	6f 92       	push	r6
    140c:	7f 92       	push	r7
    140e:	8f 92       	push	r8
    1410:	9f 92       	push	r9
    1412:	af 92       	push	r10
    1414:	bf 92       	push	r11
    1416:	cf 92       	push	r12
    1418:	df 92       	push	r13
    141a:	ef 92       	push	r14
    141c:	ff 92       	push	r15
    141e:	0f 93       	push	r16
    1420:	1f 93       	push	r17
    1422:	cf 93       	push	r28
    1424:	df 93       	push	r29
    1426:	00 d0       	rcall	.+0      	; 0x1428 <_nrf24l01p_set_RX_pipe_address+0x26>
    1428:	00 d0       	rcall	.+0      	; 0x142a <_nrf24l01p_set_RX_pipe_address+0x28>
    142a:	1f 92       	push	r1
    142c:	cd b7       	in	r28, 0x3d	; 61
    142e:	de b7       	in	r29, 0x3e	; 62
    1430:	48 2e       	mov	r4, r24
    1432:	b0 2e       	mov	r11, r16
    1434:	a2 2e       	mov	r10, r18
    1436:	93 2e       	mov	r9, r19
    1438:	84 2e       	mov	r8, r20
    143a:	75 2e       	mov	r7, r21
    143c:	66 2e       	mov	r6, r22
    143e:	57 2e       	mov	r5, r23
 	int max_pipe_addr_width = 0;

	if((pipe>=0) && (pipe<=1)   )
    1440:	81 e0       	ldi	r24, 0x01	; 1
    1442:	84 15       	cp	r24, r4
    1444:	68 f4       	brcc	.+26     	; 0x1460 <_nrf24l01p_set_RX_pipe_address+0x5e>
	{
		max_pipe_addr_width = 5;
	}
	else if ((pipe>=2) && (pipe<=5)   ){
    1446:	21 e0       	ldi	r18, 0x01	; 1
    1448:	90 e0       	ldi	r25, 0x00	; 0
    144a:	8e ef       	ldi	r24, 0xFE	; 254
    144c:	84 0d       	add	r24, r4
    144e:	84 30       	cpi	r24, 0x04	; 4
    1450:	08 f0       	brcs	.+2      	; 0x1454 <_nrf24l01p_set_RX_pipe_address+0x52>
    1452:	20 e0       	ldi	r18, 0x00	; 0
void _nrf24l01p_set_RX_pipe_address(_nrf24l01p_pipe_t pipe,uint64_t address){
 	int max_pipe_addr_width = 0;

	if((pipe>=0) && (pipe<=1)   )
	{
		max_pipe_addr_width = 5;
    1454:	c2 2e       	mov	r12, r18
    1456:	d9 2e       	mov	r13, r25
	}
	
	
	
	uint8_t temp[5];
	for(int i=0;i<max_pipe_addr_width;i++){
    1458:	1c 14       	cp	r1, r12
    145a:	1d 04       	cpc	r1, r13
    145c:	34 f0       	brlt	.+12     	; 0x146a <_nrf24l01p_set_RX_pipe_address+0x68>
    145e:	21 c0       	rjmp	.+66     	; 0x14a2 <_nrf24l01p_set_RX_pipe_address+0xa0>
void _nrf24l01p_set_RX_pipe_address(_nrf24l01p_pipe_t pipe,uint64_t address){
 	int max_pipe_addr_width = 0;

	if((pipe>=0) && (pipe<=1)   )
	{
		max_pipe_addr_width = 5;
    1460:	0f 2e       	mov	r0, r31
    1462:	f5 e0       	ldi	r31, 0x05	; 5
    1464:	cf 2e       	mov	r12, r31
    1466:	d1 2c       	mov	r13, r1
    1468:	f0 2d       	mov	r31, r0
    146a:	de 01       	movw	r26, r28
    146c:	11 96       	adiw	r26, 0x01	; 1
    146e:	7d 01       	movw	r14, r26
    1470:	21 2c       	mov	r2, r1
    1472:	31 2c       	mov	r3, r1
    1474:	e0 e0       	ldi	r30, 0x00	; 0
    1476:	f0 e0       	ldi	r31, 0x00	; 0
	
	
	
	uint8_t temp[5];
	for(int i=0;i<max_pipe_addr_width;i++){
		temp[i] = (address>>(8*i))&0xFF;
    1478:	2b 2d       	mov	r18, r11
    147a:	31 2f       	mov	r19, r17
    147c:	4a 2d       	mov	r20, r10
    147e:	59 2d       	mov	r21, r9
    1480:	68 2d       	mov	r22, r8
    1482:	77 2d       	mov	r23, r7
    1484:	86 2d       	mov	r24, r6
    1486:	95 2d       	mov	r25, r5
    1488:	02 2d       	mov	r16, r2
    148a:	0e 94 1f 0c 	call	0x183e	; 0x183e <__lshrdi3>
    148e:	d7 01       	movw	r26, r14
    1490:	2d 93       	st	X+, r18
    1492:	7d 01       	movw	r14, r26
	}
	
	
	
	uint8_t temp[5];
	for(int i=0;i<max_pipe_addr_width;i++){
    1494:	31 96       	adiw	r30, 0x01	; 1
    1496:	b8 e0       	ldi	r27, 0x08	; 8
    1498:	2b 0e       	add	r2, r27
    149a:	31 1c       	adc	r3, r1
    149c:	ec 15       	cp	r30, r12
    149e:	fd 05       	cpc	r31, r13
    14a0:	5c f3       	brlt	.-42     	; 0x1478 <_nrf24l01p_set_RX_pipe_address+0x76>
		temp[i] = (address>>(8*i))&0xFF;
	}
	_nrf24l01p_write_register(_NRF24L01P_REG_RX_ADDR_P0 + pipe,temp,max_pipe_addr_width);
    14a2:	a6 01       	movw	r20, r12
    14a4:	be 01       	movw	r22, r28
    14a6:	6f 5f       	subi	r22, 0xFF	; 255
    14a8:	7f 4f       	sbci	r23, 0xFF	; 255
    14aa:	8a e0       	ldi	r24, 0x0A	; 10
    14ac:	84 0d       	add	r24, r4
    14ae:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
	
}
    14b2:	0f 90       	pop	r0
    14b4:	0f 90       	pop	r0
    14b6:	0f 90       	pop	r0
    14b8:	0f 90       	pop	r0
    14ba:	0f 90       	pop	r0
    14bc:	df 91       	pop	r29
    14be:	cf 91       	pop	r28
    14c0:	1f 91       	pop	r17
    14c2:	0f 91       	pop	r16
    14c4:	ff 90       	pop	r15
    14c6:	ef 90       	pop	r14
    14c8:	df 90       	pop	r13
    14ca:	cf 90       	pop	r12
    14cc:	bf 90       	pop	r11
    14ce:	af 90       	pop	r10
    14d0:	9f 90       	pop	r9
    14d2:	8f 90       	pop	r8
    14d4:	7f 90       	pop	r7
    14d6:	6f 90       	pop	r6
    14d8:	5f 90       	pop	r5
    14da:	4f 90       	pop	r4
    14dc:	3f 90       	pop	r3
    14de:	2f 90       	pop	r2
    14e0:	08 95       	ret

000014e2 <_nrf24l01p_set_TX_pipe_address>:
	}
	
	return temp_addr;	
}

void _nrf24l01p_set_TX_pipe_address(uint64_t address){
    14e2:	9f 92       	push	r9
    14e4:	af 92       	push	r10
    14e6:	bf 92       	push	r11
    14e8:	cf 92       	push	r12
    14ea:	df 92       	push	r13
    14ec:	ef 92       	push	r14
    14ee:	ff 92       	push	r15
    14f0:	0f 93       	push	r16
    14f2:	1f 93       	push	r17
    14f4:	cf 93       	push	r28
    14f6:	df 93       	push	r29
    14f8:	00 d0       	rcall	.+0      	; 0x14fa <_nrf24l01p_set_TX_pipe_address+0x18>
    14fa:	00 d0       	rcall	.+0      	; 0x14fc <_nrf24l01p_set_TX_pipe_address+0x1a>
    14fc:	1f 92       	push	r1
    14fe:	cd b7       	in	r28, 0x3d	; 61
    1500:	de b7       	in	r29, 0x3e	; 62
    1502:	92 2e       	mov	r9, r18
    1504:	a3 2e       	mov	r10, r19
    1506:	b4 2e       	mov	r11, r20
    1508:	c5 2e       	mov	r12, r21
    150a:	d6 2e       	mov	r13, r22
    150c:	e7 2e       	mov	r14, r23
    150e:	f8 2e       	mov	r15, r24
    1510:	19 2f       	mov	r17, r25
    1512:	de 01       	movw	r26, r28
    1514:	11 96       	adiw	r26, 0x01	; 1
    1516:	e0 e0       	ldi	r30, 0x00	; 0
    1518:	f0 e0       	ldi	r31, 0x00	; 0
	uint8_t temp[5];
	
	for(int i=0;i<5;i++){
		temp[i] = (address>>(8*i))&0xFF;
    151a:	29 2d       	mov	r18, r9
    151c:	3a 2d       	mov	r19, r10
    151e:	4b 2d       	mov	r20, r11
    1520:	5c 2d       	mov	r21, r12
    1522:	6d 2d       	mov	r22, r13
    1524:	7e 2d       	mov	r23, r14
    1526:	8f 2d       	mov	r24, r15
    1528:	91 2f       	mov	r25, r17
    152a:	0e 2f       	mov	r16, r30
    152c:	0e 94 1f 0c 	call	0x183e	; 0x183e <__lshrdi3>
    1530:	2d 93       	st	X+, r18
    1532:	38 96       	adiw	r30, 0x08	; 8
}

void _nrf24l01p_set_TX_pipe_address(uint64_t address){
	uint8_t temp[5];
	
	for(int i=0;i<5;i++){
    1534:	e8 32       	cpi	r30, 0x28	; 40
    1536:	f1 05       	cpc	r31, r1
    1538:	81 f7       	brne	.-32     	; 0x151a <_nrf24l01p_set_TX_pipe_address+0x38>
		temp[i] = (address>>(8*i))&0xFF;
	}
	_nrf24l01p_write_register(_NRF24L01P_REG_TX_ADDR,temp,5);
    153a:	45 e0       	ldi	r20, 0x05	; 5
    153c:	50 e0       	ldi	r21, 0x00	; 0
    153e:	be 01       	movw	r22, r28
    1540:	6f 5f       	subi	r22, 0xFF	; 255
    1542:	7f 4f       	sbci	r23, 0xFF	; 255
    1544:	80 e1       	ldi	r24, 0x10	; 16
    1546:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
}
    154a:	0f 90       	pop	r0
    154c:	0f 90       	pop	r0
    154e:	0f 90       	pop	r0
    1550:	0f 90       	pop	r0
    1552:	0f 90       	pop	r0
    1554:	df 91       	pop	r29
    1556:	cf 91       	pop	r28
    1558:	1f 91       	pop	r17
    155a:	0f 91       	pop	r16
    155c:	ff 90       	pop	r15
    155e:	ef 90       	pop	r14
    1560:	df 90       	pop	r13
    1562:	cf 90       	pop	r12
    1564:	bf 90       	pop	r11
    1566:	af 90       	pop	r10
    1568:	9f 90       	pop	r9
    156a:	08 95       	ret

0000156c <_nrf24l01p_enable_dynamic_payload_pipe>:
	if(temp&_NRF24L01P_FIFO_STATUS_RX_REUSE) flag = 1 ;
	else flag = 0;
	return flag;
}

void _nrf24l01p_enable_dynamic_payload_pipe(_nrf24l01p_pipe_t pipe){
    156c:	1f 93       	push	r17
    156e:	cf 93       	push	r28
    1570:	df 93       	push	r29
    1572:	1f 92       	push	r1
    1574:	cd b7       	in	r28, 0x3d	; 61
    1576:	de b7       	in	r29, 0x3e	; 62
    1578:	18 2f       	mov	r17, r24
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_DYNPD,&temp,sizeof(temp));
    157a:	41 e0       	ldi	r20, 0x01	; 1
    157c:	50 e0       	ldi	r21, 0x00	; 0
    157e:	be 01       	movw	r22, r28
    1580:	6f 5f       	subi	r22, 0xFF	; 255
    1582:	7f 4f       	sbci	r23, 0xFF	; 255
    1584:	8c e1       	ldi	r24, 0x1C	; 28
    1586:	0e 94 01 08 	call	0x1002	; 0x1002 <_nrf24l01p_read_register>
	temp |= (1<<pipe);
    158a:	21 e0       	ldi	r18, 0x01	; 1
    158c:	30 e0       	ldi	r19, 0x00	; 0
    158e:	c9 01       	movw	r24, r18
    1590:	02 c0       	rjmp	.+4      	; 0x1596 <_nrf24l01p_enable_dynamic_payload_pipe+0x2a>
    1592:	88 0f       	add	r24, r24
    1594:	99 1f       	adc	r25, r25
    1596:	1a 95       	dec	r17
    1598:	e2 f7       	brpl	.-8      	; 0x1592 <_nrf24l01p_enable_dynamic_payload_pipe+0x26>
    159a:	99 81       	ldd	r25, Y+1	; 0x01
    159c:	89 2b       	or	r24, r25
    159e:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_DYNPD,&temp,sizeof(temp));
    15a0:	41 e0       	ldi	r20, 0x01	; 1
    15a2:	50 e0       	ldi	r21, 0x00	; 0
    15a4:	be 01       	movw	r22, r28
    15a6:	6f 5f       	subi	r22, 0xFF	; 255
    15a8:	7f 4f       	sbci	r23, 0xFF	; 255
    15aa:	8c e1       	ldi	r24, 0x1C	; 28
    15ac:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
}
    15b0:	0f 90       	pop	r0
    15b2:	df 91       	pop	r29
    15b4:	cf 91       	pop	r28
    15b6:	1f 91       	pop	r17
    15b8:	08 95       	ret

000015ba <_nrf24l01p_disable_dynamic_payload_all_pipe>:
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_DYNPD,&temp,sizeof(temp));
	temp &= ~(1<<pipe);
	_nrf24l01p_write_register(_NRF24L01P_REG_DYNPD,&temp,sizeof(temp));
}
void _nrf24l01p_disable_dynamic_payload_all_pipe(){
    15ba:	cf 93       	push	r28
    15bc:	df 93       	push	r29
    15be:	1f 92       	push	r1
    15c0:	cd b7       	in	r28, 0x3d	; 61
    15c2:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp = 0x00;
    15c4:	19 82       	std	Y+1, r1	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_DYNPD,&temp,sizeof(temp));	
    15c6:	41 e0       	ldi	r20, 0x01	; 1
    15c8:	50 e0       	ldi	r21, 0x00	; 0
    15ca:	be 01       	movw	r22, r28
    15cc:	6f 5f       	subi	r22, 0xFF	; 255
    15ce:	7f 4f       	sbci	r23, 0xFF	; 255
    15d0:	8c e1       	ldi	r24, 0x1C	; 28
    15d2:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
}
    15d6:	0f 90       	pop	r0
    15d8:	df 91       	pop	r29
    15da:	cf 91       	pop	r28
    15dc:	08 95       	ret

000015de <_nrf24l01p_enable_dynamic_payload>:
void _nrf24l01p_enable_dynamic_payload(){
    15de:	cf 93       	push	r28
    15e0:	df 93       	push	r29
    15e2:	1f 92       	push	r1
    15e4:	cd b7       	in	r28, 0x3d	; 61
    15e6:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_FEATURE,&temp,sizeof(temp));
    15e8:	41 e0       	ldi	r20, 0x01	; 1
    15ea:	50 e0       	ldi	r21, 0x00	; 0
    15ec:	be 01       	movw	r22, r28
    15ee:	6f 5f       	subi	r22, 0xFF	; 255
    15f0:	7f 4f       	sbci	r23, 0xFF	; 255
    15f2:	8d e1       	ldi	r24, 0x1D	; 29
    15f4:	0e 94 01 08 	call	0x1002	; 0x1002 <_nrf24l01p_read_register>
	temp |= _NRF24L01_FEATURE_EN_DPL;
    15f8:	89 81       	ldd	r24, Y+1	; 0x01
    15fa:	84 60       	ori	r24, 0x04	; 4
    15fc:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_FEATURE,&temp,sizeof(temp));
    15fe:	41 e0       	ldi	r20, 0x01	; 1
    1600:	50 e0       	ldi	r21, 0x00	; 0
    1602:	be 01       	movw	r22, r28
    1604:	6f 5f       	subi	r22, 0xFF	; 255
    1606:	7f 4f       	sbci	r23, 0xFF	; 255
    1608:	8d e1       	ldi	r24, 0x1D	; 29
    160a:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
}
    160e:	0f 90       	pop	r0
    1610:	df 91       	pop	r29
    1612:	cf 91       	pop	r28
    1614:	08 95       	ret

00001616 <_nrf24l01p_enable_payload_with_ack>:
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_FEATURE,&temp,sizeof(temp));
	temp &= ~_NRF24L01_FEATURE_EN_DPL;
	_nrf24l01p_write_register(_NRF24L01P_REG_FEATURE,&temp,sizeof(temp));
}
void _nrf24l01p_enable_payload_with_ack(){
    1616:	cf 93       	push	r28
    1618:	df 93       	push	r29
    161a:	1f 92       	push	r1
    161c:	cd b7       	in	r28, 0x3d	; 61
    161e:	de b7       	in	r29, 0x3e	; 62
	uint8_t temp;
	_nrf24l01p_read_register(_NRF24L01P_REG_FEATURE,&temp,sizeof(temp));
    1620:	41 e0       	ldi	r20, 0x01	; 1
    1622:	50 e0       	ldi	r21, 0x00	; 0
    1624:	be 01       	movw	r22, r28
    1626:	6f 5f       	subi	r22, 0xFF	; 255
    1628:	7f 4f       	sbci	r23, 0xFF	; 255
    162a:	8d e1       	ldi	r24, 0x1D	; 29
    162c:	0e 94 01 08 	call	0x1002	; 0x1002 <_nrf24l01p_read_register>
	temp |= _NRF24L01_FEATURE_EN_ACK_PAY;
    1630:	89 81       	ldd	r24, Y+1	; 0x01
    1632:	82 60       	ori	r24, 0x02	; 2
    1634:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_FEATURE,&temp,sizeof(temp));
    1636:	41 e0       	ldi	r20, 0x01	; 1
    1638:	50 e0       	ldi	r21, 0x00	; 0
    163a:	be 01       	movw	r22, r28
    163c:	6f 5f       	subi	r22, 0xFF	; 255
    163e:	7f 4f       	sbci	r23, 0xFF	; 255
    1640:	8d e1       	ldi	r24, 0x1D	; 29
    1642:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
}
    1646:	0f 90       	pop	r0
    1648:	df 91       	pop	r29
    164a:	cf 91       	pop	r28
    164c:	08 95       	ret

0000164e <_nrf24l01p_startup>:


//////////////////////////////////////////////////////////////////////////


void _nrf24l01p_startup(){
    164e:	cf 93       	push	r28
    1650:	df 93       	push	r29
    1652:	1f 92       	push	r1
    1654:	cd b7       	in	r28, 0x3d	; 61
    1656:	de b7       	in	r29, 0x3e	; 62
	#define TRANSFER_SIZE 1
	uint8_t temp = 0b00000111;
    1658:	87 e0       	ldi	r24, 0x07	; 7
    165a:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_RF_SETUP,&temp, sizeof(temp));
    165c:	41 e0       	ldi	r20, 0x01	; 1
    165e:	50 e0       	ldi	r21, 0x00	; 0
    1660:	be 01       	movw	r22, r28
    1662:	6f 5f       	subi	r22, 0xFF	; 255
    1664:	7f 4f       	sbci	r23, 0xFF	; 255
    1666:	86 e0       	ldi	r24, 0x06	; 6
    1668:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>

	temp = 0;
    166c:	19 82       	std	Y+1, r1	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_EN_AA,&temp,sizeof(uint8_t));
    166e:	41 e0       	ldi	r20, 0x01	; 1
    1670:	50 e0       	ldi	r21, 0x00	; 0
    1672:	be 01       	movw	r22, r28
    1674:	6f 5f       	subi	r22, 0xFF	; 255
    1676:	7f 4f       	sbci	r23, 0xFF	; 255
    1678:	81 e0       	ldi	r24, 0x01	; 1
    167a:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
	temp = TRANSFER_SIZE;
    167e:	81 e0       	ldi	r24, 0x01	; 1
    1680:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_RF_SETUP,&temp, sizeof(temp));
    1682:	41 e0       	ldi	r20, 0x01	; 1
    1684:	50 e0       	ldi	r21, 0x00	; 0
    1686:	be 01       	movw	r22, r28
    1688:	6f 5f       	subi	r22, 0xFF	; 255
    168a:	7f 4f       	sbci	r23, 0xFF	; 255
    168c:	86 e0       	ldi	r24, 0x06	; 6
    168e:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
	_nrf24l01p_power_up();
    1692:	0e 94 9a 08 	call	0x1134	; 0x1134 <_nrf24l01p_power_up>
    1696:	8f e4       	ldi	r24, 0x4F	; 79
    1698:	96 e4       	ldi	r25, 0x46	; 70
    169a:	01 97       	sbiw	r24, 0x01	; 1
    169c:	f1 f7       	brne	.-4      	; 0x169a <_nrf24l01p_startup+0x4c>
    169e:	00 c0       	rjmp	.+0      	; 0x16a0 <_nrf24l01p_startup+0x52>
    16a0:	00 00       	nop
	_nrf24l01p_delay_us(_NRF24L01P_TIMING_Tpd2stby_us);

	_nrf24l01p_rx_mode();
    16a2:	0e 94 de 08 	call	0x11bc	; 0x11bc <_nrf24l01p_rx_mode>
	_nrf24l01p_ce_pin(1);
    16a6:	81 e0       	ldi	r24, 0x01	; 1
    16a8:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <_nrf24l01p_ce_pin>

}
    16ac:	0f 90       	pop	r0
    16ae:	df 91       	pop	r29
    16b0:	cf 91       	pop	r28
    16b2:	08 95       	ret

000016b4 <_nrf24l01p_init>:

	arch_nrf24l01p_csn_pin(state);
	csn_value = state;
}

void _nrf24l01p_init(){
    16b4:	cf 93       	push	r28
    16b6:	df 93       	push	r29
    16b8:	00 d0       	rcall	.+0      	; 0x16ba <_nrf24l01p_init+0x6>
    16ba:	cd b7       	in	r28, 0x3d	; 61
    16bc:	de b7       	in	r29, 0x3e	; 62
	else {clr_bit(CSN_PORT,CSN_PIN_BIT);}

}

static void arch_nrf24l01p_initialize(){
		set_bit(CSN_DDR,CSN_PIN_BIT);
    16be:	57 9a       	sbi	0x0a, 7	; 10
		set_bit(CE_DDR,CE_PIN_BIT);
    16c0:	24 9a       	sbi	0x04, 4	; 4

		clr_bit(CE_PORT,CE_PIN_BIT);
    16c2:	2c 98       	cbi	0x05, 4	; 5
		set_bit(CSN_PORT,CSN_PIN_BIT);
    16c4:	5f 9a       	sbi	0x0b, 7	; 11
		SPI_DDR |= (1<<SPI_SS_BIT) | (1<<MOSI_BIT) | (1<<SCK_BIT);
    16c6:	84 b1       	in	r24, 0x04	; 4
    16c8:	87 60       	ori	r24, 0x07	; 7
    16ca:	84 b9       	out	0x04, r24	; 4
		SPI_DDR &= ~(1<<MISO_BIT);
    16cc:	23 98       	cbi	0x04, 3	; 4
		SPCR |= (1<<SPE) | (1<<MSTR);
    16ce:	8c b5       	in	r24, 0x2c	; 44
    16d0:	80 65       	ori	r24, 0x50	; 80
    16d2:	8c bd       	out	0x2c, r24	; 44
	arch_nrf24l01p_initialize();
	
	_nrf24l01p_ce_pin(0);
    16d4:	80 e0       	ldi	r24, 0x00	; 0
    16d6:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <_nrf24l01p_ce_pin>
	_nrf24l01p_csn_pin(1);
    16da:	81 e0       	ldi	r24, 0x01	; 1
    16dc:	0e 94 f9 07 	call	0xff2	; 0xff2 <_nrf24l01p_csn_pin>
	
	
	_nrf24l01p_flush_rx();
    16e0:	0e 94 81 08 	call	0x1102	; 0x1102 <_nrf24l01p_flush_rx>
	_nrf24l01p_power_down();
    16e4:	0e 94 bf 08 	call	0x117e	; 0x117e <_nrf24l01p_power_down>
	uint8_t status_rst_val = 0x0e;//reset status
    16e8:	8e e0       	ldi	r24, 0x0E	; 14
    16ea:	89 83       	std	Y+1, r24	; 0x01
	_nrf24l01p_write_register(_NRF24L01P_REG_STATUS, &status_rst_val,1);
    16ec:	41 e0       	ldi	r20, 0x01	; 1
    16ee:	50 e0       	ldi	r21, 0x00	; 0
    16f0:	be 01       	movw	r22, r28
    16f2:	6f 5f       	subi	r22, 0xFF	; 255
    16f4:	7f 4f       	sbci	r23, 0xFF	; 255
    16f6:	87 e0       	ldi	r24, 0x07	; 7
    16f8:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
	uint8_t config_rst_val = 0x0b;//reset config
    16fc:	8b e0       	ldi	r24, 0x0B	; 11
    16fe:	8a 83       	std	Y+2, r24	; 0x02
	_nrf24l01p_write_register(_NRF24L01P_REG_CONFIG, &config_rst_val,1);
    1700:	41 e0       	ldi	r20, 0x01	; 1
    1702:	50 e0       	ldi	r21, 0x00	; 0
    1704:	be 01       	movw	r22, r28
    1706:	6e 5f       	subi	r22, 0xFE	; 254
    1708:	7f 4f       	sbci	r23, 0xFF	; 255
    170a:	80 e0       	ldi	r24, 0x00	; 0
    170c:	0e 94 2a 08 	call	0x1054	; 0x1054 <_nrf24l01p_write_register>
	_nrf24l01p_disable_auto_ack_all_pipes();
    1710:	0e 94 43 09 	call	0x1286	; 0x1286 <_nrf24l01p_disable_auto_ack_all_pipes>
	_nrf24l01p_disable_dynamic_payload_all_pipe();/////////ALSO CREEATE FOR DISABLE AUTO ACK FOR ALL PIPE
    1714:	0e 94 dd 0a 	call	0x15ba	; 0x15ba <_nrf24l01p_disable_dynamic_payload_all_pipe>
	_nrf24l01p_startup();
    1718:	0e 94 27 0b 	call	0x164e	; 0x164e <_nrf24l01p_startup>
	
}
    171c:	0f 90       	pop	r0
    171e:	0f 90       	pop	r0
    1720:	df 91       	pop	r29
    1722:	cf 91       	pop	r28
    1724:	08 95       	ret

00001726 <_nrf24l01p_write>:
	return flag;
}

volatile int mystat;

int _nrf24l01p_write(uint8_t *data, int datalen){
    1726:	ef 92       	push	r14
    1728:	ff 92       	push	r15
    172a:	0f 93       	push	r16
    172c:	1f 93       	push	r17
    172e:	cf 93       	push	r28
    1730:	df 93       	push	r29
    1732:	7c 01       	movw	r14, r24
    1734:	eb 01       	movw	r28, r22
	int error_status = 0;
	int originalCe = ce_value;//backup original ce_value
    1736:	10 91 d7 04 	lds	r17, 0x04D7
	_nrf24l01p_ce_pin(0);//disable();
    173a:	80 e0       	ldi	r24, 0x00	; 0
    173c:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <_nrf24l01p_ce_pin>
	if ( datalen <= 0 ) return 0;
    1740:	1c 16       	cp	r1, r28
    1742:	1d 06       	cpc	r1, r29
    1744:	d4 f5       	brge	.+116    	; 0x17ba <_nrf24l01p_write+0x94>
	if ( datalen > _NRF24L01P_TX_FIFO_SIZE ) datalen = _NRF24L01P_TX_FIFO_SIZE;
	
	_nrf24l01p_clear_data_sent_flag();
    1746:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <_nrf24l01p_clear_data_sent_flag>
    174a:	be 01       	movw	r22, r28
    174c:	a1 97       	sbiw	r28, 0x21	; 33
    174e:	14 f0       	brlt	.+4      	; 0x1754 <_nrf24l01p_write+0x2e>
    1750:	60 e2       	ldi	r22, 0x20	; 32
    1752:	70 e0       	ldi	r23, 0x00	; 0
	_nrf24l01p_write_tx_payload(data,datalen);
    1754:	c7 01       	movw	r24, r14
    1756:	0e 94 52 08 	call	0x10a4	; 0x10a4 <_nrf24l01p_write_tx_payload>
	
	int originalMode = mode; //backup mode
    175a:	00 91 d8 04 	lds	r16, 0x04D8
	_nrf24l01p_tx_mode();
    175e:	0e 94 fd 08 	call	0x11fa	; 0x11fa <_nrf24l01p_tx_mode>
	
	_nrf24l01p_ce_pin(1);//enable();
    1762:	81 e0       	ldi	r24, 0x01	; 1
    1764:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <_nrf24l01p_ce_pin>
    1768:	85 e3       	ldi	r24, 0x35	; 53
    176a:	8a 95       	dec	r24
    176c:	f1 f7       	brne	.-4      	; 0x176a <_nrf24l01p_write+0x44>
    176e:	00 00       	nop
	_nrf24l01p_delay_us(_NRF24L01P_TIMING_Thce_us);
	_nrf24l01p_ce_pin(0);
    1770:	80 e0       	ldi	r24, 0x00	; 0
    1772:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <_nrf24l01p_ce_pin>
	
	//bool max_retry_flag_reached= 0;
	while ( !(_nrf24l01p_get_data_sent_flag()) ){
    1776:	04 c0       	rjmp	.+8      	; 0x1780 <_nrf24l01p_write+0x5a>
		if(_nrf24l01p_get_max_retry_flag()){
    1778:	0e 94 c1 09 	call	0x1382	; 0x1382 <_nrf24l01p_get_max_retry_flag>
    177c:	81 11       	cpse	r24, r1
    177e:	07 c0       	rjmp	.+14     	; 0x178e <_nrf24l01p_write+0x68>
	_nrf24l01p_ce_pin(1);//enable();
	_nrf24l01p_delay_us(_NRF24L01P_TIMING_Thce_us);
	_nrf24l01p_ce_pin(0);
	
	//bool max_retry_flag_reached= 0;
	while ( !(_nrf24l01p_get_data_sent_flag()) ){
    1780:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <_nrf24l01p_get_data_sent_flag>
    1784:	88 23       	and	r24, r24
    1786:	c1 f3       	breq	.-16     	; 0x1778 <_nrf24l01p_write+0x52>
}

volatile int mystat;

int _nrf24l01p_write(uint8_t *data, int datalen){
	int error_status = 0;
    1788:	d0 e0       	ldi	r29, 0x00	; 0
    178a:	c0 e0       	ldi	r28, 0x00	; 0
    178c:	02 c0       	rjmp	.+4      	; 0x1792 <_nrf24l01p_write+0x6c>
	_nrf24l01p_ce_pin(0);
	
	//bool max_retry_flag_reached= 0;
	while ( !(_nrf24l01p_get_data_sent_flag()) ){
		if(_nrf24l01p_get_max_retry_flag()){
			error_status = -1;
    178e:	df ef       	ldi	r29, 0xFF	; 255
    1790:	cf ef       	ldi	r28, 0xFF	; 255
			break;
		}
	}

	_nrf24l01p_flush_tx();
    1792:	0e 94 77 08 	call	0x10ee	; 0x10ee <_nrf24l01p_flush_tx>
	_nrf24l01p_clear_data_sent_flag();
    1796:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <_nrf24l01p_clear_data_sent_flag>
	_nrf24l01p_clear_max_retry_flag();
    179a:	0e 94 cb 09 	call	0x1396	; 0x1396 <_nrf24l01p_clear_max_retry_flag>
	if ( originalMode == _NRF24L01P_MODE_RX ) _nrf24l01p_rx_mode();//restore original mode
    179e:	03 30       	cpi	r16, 0x03	; 3
    17a0:	11 f4       	brne	.+4      	; 0x17a6 <_nrf24l01p_write+0x80>
    17a2:	0e 94 de 08 	call	0x11bc	; 0x11bc <_nrf24l01p_rx_mode>
	_nrf24l01p_ce_pin(originalCe);//restore original CE pin status
    17a6:	81 2f       	mov	r24, r17
    17a8:	0e 94 f1 07 	call	0xfe2	; 0xfe2 <_nrf24l01p_ce_pin>
    17ac:	85 e1       	ldi	r24, 0x15	; 21
    17ae:	8a 95       	dec	r24
    17b0:	f1 f7       	brne	.-4      	; 0x17ae <_nrf24l01p_write+0x88>
    17b2:	00 00       	nop
	_nrf24l01p_delay_us( _NRF24L01P_TIMING_Tpece2csn_us );
	
	return error_status;
    17b4:	8d 2f       	mov	r24, r29
    17b6:	9c 2f       	mov	r25, r28
    17b8:	02 c0       	rjmp	.+4      	; 0x17be <_nrf24l01p_write+0x98>

int _nrf24l01p_write(uint8_t *data, int datalen){
	int error_status = 0;
	int originalCe = ce_value;//backup original ce_value
	_nrf24l01p_ce_pin(0);//disable();
	if ( datalen <= 0 ) return 0;
    17ba:	80 e0       	ldi	r24, 0x00	; 0
    17bc:	90 e0       	ldi	r25, 0x00	; 0
	if ( originalMode == _NRF24L01P_MODE_RX ) _nrf24l01p_rx_mode();//restore original mode
	_nrf24l01p_ce_pin(originalCe);//restore original CE pin status
	_nrf24l01p_delay_us( _NRF24L01P_TIMING_Tpece2csn_us );
	
	return error_status;
}
    17be:	df 91       	pop	r29
    17c0:	cf 91       	pop	r28
    17c2:	1f 91       	pop	r17
    17c4:	0f 91       	pop	r16
    17c6:	ff 90       	pop	r15
    17c8:	ef 90       	pop	r14
    17ca:	08 95       	ret

000017cc <_nrf24l01p_write_to_address_ack>:
int _nrf24l01p_write_to_address(uint64_t address, uint8_t *data, int datalen){
	_nrf24l01p_set_TX_pipe_address(address);
	int ret = _nrf24l01p_write(data,datalen);
	return ret;
}
int _nrf24l01p_write_to_address_ack(uint64_t address, uint8_t *data, int datalen){
    17cc:	6f 92       	push	r6
    17ce:	7f 92       	push	r7
    17d0:	8f 92       	push	r8
    17d2:	9f 92       	push	r9
    17d4:	af 92       	push	r10
    17d6:	bf 92       	push	r11
    17d8:	cf 92       	push	r12
    17da:	df 92       	push	r13
    17dc:	ef 92       	push	r14
    17de:	ff 92       	push	r15
    17e0:	0f 93       	push	r16
    17e2:	1f 93       	push	r17
    17e4:	cf 93       	push	r28
    17e6:	df 93       	push	r29
    17e8:	62 2e       	mov	r6, r18
    17ea:	73 2e       	mov	r7, r19
    17ec:	a4 2e       	mov	r10, r20
    17ee:	b5 2e       	mov	r11, r21
    17f0:	c6 2e       	mov	r12, r22
    17f2:	d7 2e       	mov	r13, r23
    17f4:	d8 2f       	mov	r29, r24
    17f6:	c9 2f       	mov	r28, r25
    17f8:	48 01       	movw	r8, r16
	_nrf24l01p_set_TX_pipe_address(address);
    17fa:	0e 94 71 0a 	call	0x14e2	; 0x14e2 <_nrf24l01p_set_TX_pipe_address>
	_nrf24l01p_set_RX_pipe_address(_NRF24L01P_PIPE_P0, address);
    17fe:	06 2d       	mov	r16, r6
    1800:	17 2d       	mov	r17, r7
    1802:	2a 2d       	mov	r18, r10
    1804:	3b 2d       	mov	r19, r11
    1806:	4c 2d       	mov	r20, r12
    1808:	5d 2d       	mov	r21, r13
    180a:	6d 2f       	mov	r22, r29
    180c:	7c 2f       	mov	r23, r28
    180e:	80 e0       	ldi	r24, 0x00	; 0
    1810:	0e 94 01 0a 	call	0x1402	; 0x1402 <_nrf24l01p_set_RX_pipe_address>
	int ret = _nrf24l01p_write(data,datalen);
    1814:	b7 01       	movw	r22, r14
    1816:	c4 01       	movw	r24, r8
    1818:	0e 94 93 0b 	call	0x1726	; 0x1726 <_nrf24l01p_write>
	return ret;
	
}
    181c:	df 91       	pop	r29
    181e:	cf 91       	pop	r28
    1820:	1f 91       	pop	r17
    1822:	0f 91       	pop	r16
    1824:	ff 90       	pop	r15
    1826:	ef 90       	pop	r14
    1828:	df 90       	pop	r13
    182a:	cf 90       	pop	r12
    182c:	bf 90       	pop	r11
    182e:	af 90       	pop	r10
    1830:	9f 90       	pop	r9
    1832:	8f 90       	pop	r8
    1834:	7f 90       	pop	r7
    1836:	6f 90       	pop	r6
    1838:	08 95       	ret

0000183a <__ashrdi3>:
    183a:	97 fb       	bst	r25, 7
    183c:	10 f8       	bld	r1, 0

0000183e <__lshrdi3>:
    183e:	16 94       	lsr	r1
    1840:	00 08       	sbc	r0, r0
    1842:	0f 93       	push	r16
    1844:	08 30       	cpi	r16, 0x08	; 8
    1846:	98 f0       	brcs	.+38     	; 0x186e <__lshrdi3+0x30>
    1848:	08 50       	subi	r16, 0x08	; 8
    184a:	23 2f       	mov	r18, r19
    184c:	34 2f       	mov	r19, r20
    184e:	45 2f       	mov	r20, r21
    1850:	56 2f       	mov	r21, r22
    1852:	67 2f       	mov	r22, r23
    1854:	78 2f       	mov	r23, r24
    1856:	89 2f       	mov	r24, r25
    1858:	90 2d       	mov	r25, r0
    185a:	f4 cf       	rjmp	.-24     	; 0x1844 <__lshrdi3+0x6>
    185c:	05 94       	asr	r0
    185e:	97 95       	ror	r25
    1860:	87 95       	ror	r24
    1862:	77 95       	ror	r23
    1864:	67 95       	ror	r22
    1866:	57 95       	ror	r21
    1868:	47 95       	ror	r20
    186a:	37 95       	ror	r19
    186c:	27 95       	ror	r18
    186e:	0a 95       	dec	r16
    1870:	aa f7       	brpl	.-22     	; 0x185c <__lshrdi3+0x1e>
    1872:	0f 91       	pop	r16
    1874:	08 95       	ret

00001876 <sprintf>:
    1876:	ae e0       	ldi	r26, 0x0E	; 14
    1878:	b0 e0       	ldi	r27, 0x00	; 0
    187a:	e1 e4       	ldi	r30, 0x41	; 65
    187c:	fc e0       	ldi	r31, 0x0C	; 12
    187e:	0c 94 ea 0e 	jmp	0x1dd4	; 0x1dd4 <__prologue_saves__+0x1c>
    1882:	0d 89       	ldd	r16, Y+21	; 0x15
    1884:	1e 89       	ldd	r17, Y+22	; 0x16
    1886:	86 e0       	ldi	r24, 0x06	; 6
    1888:	8c 83       	std	Y+4, r24	; 0x04
    188a:	1a 83       	std	Y+2, r17	; 0x02
    188c:	09 83       	std	Y+1, r16	; 0x01
    188e:	8f ef       	ldi	r24, 0xFF	; 255
    1890:	9f e7       	ldi	r25, 0x7F	; 127
    1892:	9e 83       	std	Y+6, r25	; 0x06
    1894:	8d 83       	std	Y+5, r24	; 0x05
    1896:	ae 01       	movw	r20, r28
    1898:	47 5e       	subi	r20, 0xE7	; 231
    189a:	5f 4f       	sbci	r21, 0xFF	; 255
    189c:	6f 89       	ldd	r22, Y+23	; 0x17
    189e:	78 8d       	ldd	r23, Y+24	; 0x18
    18a0:	ce 01       	movw	r24, r28
    18a2:	01 96       	adiw	r24, 0x01	; 1
    18a4:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <vfprintf>
    18a8:	2f 81       	ldd	r18, Y+7	; 0x07
    18aa:	38 85       	ldd	r19, Y+8	; 0x08
    18ac:	f8 01       	movw	r30, r16
    18ae:	e2 0f       	add	r30, r18
    18b0:	f3 1f       	adc	r31, r19
    18b2:	10 82       	st	Z, r1
    18b4:	2e 96       	adiw	r28, 0x0e	; 14
    18b6:	e4 e0       	ldi	r30, 0x04	; 4
    18b8:	0c 94 06 0f 	jmp	0x1e0c	; 0x1e0c <__epilogue_restores__+0x1c>

000018bc <vfprintf>:
    18bc:	ac e0       	ldi	r26, 0x0C	; 12
    18be:	b0 e0       	ldi	r27, 0x00	; 0
    18c0:	e4 e6       	ldi	r30, 0x64	; 100
    18c2:	fc e0       	ldi	r31, 0x0C	; 12
    18c4:	0c 94 dc 0e 	jmp	0x1db8	; 0x1db8 <__prologue_saves__>
    18c8:	7c 01       	movw	r14, r24
    18ca:	6b 01       	movw	r12, r22
    18cc:	8a 01       	movw	r16, r20
    18ce:	fc 01       	movw	r30, r24
    18d0:	17 82       	std	Z+7, r1	; 0x07
    18d2:	16 82       	std	Z+6, r1	; 0x06
    18d4:	83 81       	ldd	r24, Z+3	; 0x03
    18d6:	81 ff       	sbrs	r24, 1
    18d8:	bd c1       	rjmp	.+890    	; 0x1c54 <vfprintf+0x398>
    18da:	ce 01       	movw	r24, r28
    18dc:	01 96       	adiw	r24, 0x01	; 1
    18de:	4c 01       	movw	r8, r24
    18e0:	f7 01       	movw	r30, r14
    18e2:	93 81       	ldd	r25, Z+3	; 0x03
    18e4:	f6 01       	movw	r30, r12
    18e6:	93 fd       	sbrc	r25, 3
    18e8:	85 91       	lpm	r24, Z+
    18ea:	93 ff       	sbrs	r25, 3
    18ec:	81 91       	ld	r24, Z+
    18ee:	6f 01       	movw	r12, r30
    18f0:	88 23       	and	r24, r24
    18f2:	09 f4       	brne	.+2      	; 0x18f6 <vfprintf+0x3a>
    18f4:	ab c1       	rjmp	.+854    	; 0x1c4c <vfprintf+0x390>
    18f6:	85 32       	cpi	r24, 0x25	; 37
    18f8:	39 f4       	brne	.+14     	; 0x1908 <vfprintf+0x4c>
    18fa:	93 fd       	sbrc	r25, 3
    18fc:	85 91       	lpm	r24, Z+
    18fe:	93 ff       	sbrs	r25, 3
    1900:	81 91       	ld	r24, Z+
    1902:	6f 01       	movw	r12, r30
    1904:	85 32       	cpi	r24, 0x25	; 37
    1906:	29 f4       	brne	.+10     	; 0x1912 <vfprintf+0x56>
    1908:	b7 01       	movw	r22, r14
    190a:	90 e0       	ldi	r25, 0x00	; 0
    190c:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <fputc>
    1910:	e7 cf       	rjmp	.-50     	; 0x18e0 <vfprintf+0x24>
    1912:	51 2c       	mov	r5, r1
    1914:	31 2c       	mov	r3, r1
    1916:	20 e0       	ldi	r18, 0x00	; 0
    1918:	20 32       	cpi	r18, 0x20	; 32
    191a:	a0 f4       	brcc	.+40     	; 0x1944 <vfprintf+0x88>
    191c:	8b 32       	cpi	r24, 0x2B	; 43
    191e:	69 f0       	breq	.+26     	; 0x193a <vfprintf+0x7e>
    1920:	30 f4       	brcc	.+12     	; 0x192e <vfprintf+0x72>
    1922:	80 32       	cpi	r24, 0x20	; 32
    1924:	59 f0       	breq	.+22     	; 0x193c <vfprintf+0x80>
    1926:	83 32       	cpi	r24, 0x23	; 35
    1928:	69 f4       	brne	.+26     	; 0x1944 <vfprintf+0x88>
    192a:	20 61       	ori	r18, 0x10	; 16
    192c:	2c c0       	rjmp	.+88     	; 0x1986 <vfprintf+0xca>
    192e:	8d 32       	cpi	r24, 0x2D	; 45
    1930:	39 f0       	breq	.+14     	; 0x1940 <vfprintf+0x84>
    1932:	80 33       	cpi	r24, 0x30	; 48
    1934:	39 f4       	brne	.+14     	; 0x1944 <vfprintf+0x88>
    1936:	21 60       	ori	r18, 0x01	; 1
    1938:	26 c0       	rjmp	.+76     	; 0x1986 <vfprintf+0xca>
    193a:	22 60       	ori	r18, 0x02	; 2
    193c:	24 60       	ori	r18, 0x04	; 4
    193e:	23 c0       	rjmp	.+70     	; 0x1986 <vfprintf+0xca>
    1940:	28 60       	ori	r18, 0x08	; 8
    1942:	21 c0       	rjmp	.+66     	; 0x1986 <vfprintf+0xca>
    1944:	27 fd       	sbrc	r18, 7
    1946:	27 c0       	rjmp	.+78     	; 0x1996 <vfprintf+0xda>
    1948:	30 ed       	ldi	r19, 0xD0	; 208
    194a:	38 0f       	add	r19, r24
    194c:	3a 30       	cpi	r19, 0x0A	; 10
    194e:	78 f4       	brcc	.+30     	; 0x196e <vfprintf+0xb2>
    1950:	26 ff       	sbrs	r18, 6
    1952:	06 c0       	rjmp	.+12     	; 0x1960 <vfprintf+0xa4>
    1954:	fa e0       	ldi	r31, 0x0A	; 10
    1956:	5f 9e       	mul	r5, r31
    1958:	30 0d       	add	r19, r0
    195a:	11 24       	eor	r1, r1
    195c:	53 2e       	mov	r5, r19
    195e:	13 c0       	rjmp	.+38     	; 0x1986 <vfprintf+0xca>
    1960:	8a e0       	ldi	r24, 0x0A	; 10
    1962:	38 9e       	mul	r3, r24
    1964:	30 0d       	add	r19, r0
    1966:	11 24       	eor	r1, r1
    1968:	33 2e       	mov	r3, r19
    196a:	20 62       	ori	r18, 0x20	; 32
    196c:	0c c0       	rjmp	.+24     	; 0x1986 <vfprintf+0xca>
    196e:	8e 32       	cpi	r24, 0x2E	; 46
    1970:	21 f4       	brne	.+8      	; 0x197a <vfprintf+0xbe>
    1972:	26 fd       	sbrc	r18, 6
    1974:	6b c1       	rjmp	.+726    	; 0x1c4c <vfprintf+0x390>
    1976:	20 64       	ori	r18, 0x40	; 64
    1978:	06 c0       	rjmp	.+12     	; 0x1986 <vfprintf+0xca>
    197a:	8c 36       	cpi	r24, 0x6C	; 108
    197c:	11 f4       	brne	.+4      	; 0x1982 <vfprintf+0xc6>
    197e:	20 68       	ori	r18, 0x80	; 128
    1980:	02 c0       	rjmp	.+4      	; 0x1986 <vfprintf+0xca>
    1982:	88 36       	cpi	r24, 0x68	; 104
    1984:	41 f4       	brne	.+16     	; 0x1996 <vfprintf+0xda>
    1986:	f6 01       	movw	r30, r12
    1988:	93 fd       	sbrc	r25, 3
    198a:	85 91       	lpm	r24, Z+
    198c:	93 ff       	sbrs	r25, 3
    198e:	81 91       	ld	r24, Z+
    1990:	6f 01       	movw	r12, r30
    1992:	81 11       	cpse	r24, r1
    1994:	c1 cf       	rjmp	.-126    	; 0x1918 <vfprintf+0x5c>
    1996:	98 2f       	mov	r25, r24
    1998:	9f 7d       	andi	r25, 0xDF	; 223
    199a:	95 54       	subi	r25, 0x45	; 69
    199c:	93 30       	cpi	r25, 0x03	; 3
    199e:	28 f4       	brcc	.+10     	; 0x19aa <vfprintf+0xee>
    19a0:	0c 5f       	subi	r16, 0xFC	; 252
    19a2:	1f 4f       	sbci	r17, 0xFF	; 255
    19a4:	ff e3       	ldi	r31, 0x3F	; 63
    19a6:	f9 83       	std	Y+1, r31	; 0x01
    19a8:	0d c0       	rjmp	.+26     	; 0x19c4 <vfprintf+0x108>
    19aa:	83 36       	cpi	r24, 0x63	; 99
    19ac:	31 f0       	breq	.+12     	; 0x19ba <vfprintf+0xfe>
    19ae:	83 37       	cpi	r24, 0x73	; 115
    19b0:	71 f0       	breq	.+28     	; 0x19ce <vfprintf+0x112>
    19b2:	83 35       	cpi	r24, 0x53	; 83
    19b4:	09 f0       	breq	.+2      	; 0x19b8 <vfprintf+0xfc>
    19b6:	5b c0       	rjmp	.+182    	; 0x1a6e <vfprintf+0x1b2>
    19b8:	22 c0       	rjmp	.+68     	; 0x19fe <vfprintf+0x142>
    19ba:	f8 01       	movw	r30, r16
    19bc:	80 81       	ld	r24, Z
    19be:	89 83       	std	Y+1, r24	; 0x01
    19c0:	0e 5f       	subi	r16, 0xFE	; 254
    19c2:	1f 4f       	sbci	r17, 0xFF	; 255
    19c4:	44 24       	eor	r4, r4
    19c6:	43 94       	inc	r4
    19c8:	51 2c       	mov	r5, r1
    19ca:	54 01       	movw	r10, r8
    19cc:	15 c0       	rjmp	.+42     	; 0x19f8 <vfprintf+0x13c>
    19ce:	38 01       	movw	r6, r16
    19d0:	f2 e0       	ldi	r31, 0x02	; 2
    19d2:	6f 0e       	add	r6, r31
    19d4:	71 1c       	adc	r7, r1
    19d6:	f8 01       	movw	r30, r16
    19d8:	a0 80       	ld	r10, Z
    19da:	b1 80       	ldd	r11, Z+1	; 0x01
    19dc:	26 ff       	sbrs	r18, 6
    19de:	03 c0       	rjmp	.+6      	; 0x19e6 <vfprintf+0x12a>
    19e0:	65 2d       	mov	r22, r5
    19e2:	70 e0       	ldi	r23, 0x00	; 0
    19e4:	02 c0       	rjmp	.+4      	; 0x19ea <vfprintf+0x12e>
    19e6:	6f ef       	ldi	r22, 0xFF	; 255
    19e8:	7f ef       	ldi	r23, 0xFF	; 255
    19ea:	c5 01       	movw	r24, r10
    19ec:	2c 87       	std	Y+12, r18	; 0x0c
    19ee:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <strnlen>
    19f2:	2c 01       	movw	r4, r24
    19f4:	83 01       	movw	r16, r6
    19f6:	2c 85       	ldd	r18, Y+12	; 0x0c
    19f8:	2f 77       	andi	r18, 0x7F	; 127
    19fa:	22 2e       	mov	r2, r18
    19fc:	17 c0       	rjmp	.+46     	; 0x1a2c <vfprintf+0x170>
    19fe:	38 01       	movw	r6, r16
    1a00:	f2 e0       	ldi	r31, 0x02	; 2
    1a02:	6f 0e       	add	r6, r31
    1a04:	71 1c       	adc	r7, r1
    1a06:	f8 01       	movw	r30, r16
    1a08:	a0 80       	ld	r10, Z
    1a0a:	b1 80       	ldd	r11, Z+1	; 0x01
    1a0c:	26 ff       	sbrs	r18, 6
    1a0e:	03 c0       	rjmp	.+6      	; 0x1a16 <vfprintf+0x15a>
    1a10:	65 2d       	mov	r22, r5
    1a12:	70 e0       	ldi	r23, 0x00	; 0
    1a14:	02 c0       	rjmp	.+4      	; 0x1a1a <vfprintf+0x15e>
    1a16:	6f ef       	ldi	r22, 0xFF	; 255
    1a18:	7f ef       	ldi	r23, 0xFF	; 255
    1a1a:	c5 01       	movw	r24, r10
    1a1c:	2c 87       	std	Y+12, r18	; 0x0c
    1a1e:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <strnlen_P>
    1a22:	2c 01       	movw	r4, r24
    1a24:	2c 85       	ldd	r18, Y+12	; 0x0c
    1a26:	20 68       	ori	r18, 0x80	; 128
    1a28:	22 2e       	mov	r2, r18
    1a2a:	83 01       	movw	r16, r6
    1a2c:	23 fc       	sbrc	r2, 3
    1a2e:	1b c0       	rjmp	.+54     	; 0x1a66 <vfprintf+0x1aa>
    1a30:	83 2d       	mov	r24, r3
    1a32:	90 e0       	ldi	r25, 0x00	; 0
    1a34:	48 16       	cp	r4, r24
    1a36:	59 06       	cpc	r5, r25
    1a38:	b0 f4       	brcc	.+44     	; 0x1a66 <vfprintf+0x1aa>
    1a3a:	b7 01       	movw	r22, r14
    1a3c:	80 e2       	ldi	r24, 0x20	; 32
    1a3e:	90 e0       	ldi	r25, 0x00	; 0
    1a40:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <fputc>
    1a44:	3a 94       	dec	r3
    1a46:	f4 cf       	rjmp	.-24     	; 0x1a30 <vfprintf+0x174>
    1a48:	f5 01       	movw	r30, r10
    1a4a:	27 fc       	sbrc	r2, 7
    1a4c:	85 91       	lpm	r24, Z+
    1a4e:	27 fe       	sbrs	r2, 7
    1a50:	81 91       	ld	r24, Z+
    1a52:	5f 01       	movw	r10, r30
    1a54:	b7 01       	movw	r22, r14
    1a56:	90 e0       	ldi	r25, 0x00	; 0
    1a58:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <fputc>
    1a5c:	31 10       	cpse	r3, r1
    1a5e:	3a 94       	dec	r3
    1a60:	f1 e0       	ldi	r31, 0x01	; 1
    1a62:	4f 1a       	sub	r4, r31
    1a64:	51 08       	sbc	r5, r1
    1a66:	41 14       	cp	r4, r1
    1a68:	51 04       	cpc	r5, r1
    1a6a:	71 f7       	brne	.-36     	; 0x1a48 <vfprintf+0x18c>
    1a6c:	e5 c0       	rjmp	.+458    	; 0x1c38 <vfprintf+0x37c>
    1a6e:	84 36       	cpi	r24, 0x64	; 100
    1a70:	11 f0       	breq	.+4      	; 0x1a76 <vfprintf+0x1ba>
    1a72:	89 36       	cpi	r24, 0x69	; 105
    1a74:	39 f5       	brne	.+78     	; 0x1ac4 <vfprintf+0x208>
    1a76:	f8 01       	movw	r30, r16
    1a78:	27 ff       	sbrs	r18, 7
    1a7a:	07 c0       	rjmp	.+14     	; 0x1a8a <vfprintf+0x1ce>
    1a7c:	60 81       	ld	r22, Z
    1a7e:	71 81       	ldd	r23, Z+1	; 0x01
    1a80:	82 81       	ldd	r24, Z+2	; 0x02
    1a82:	93 81       	ldd	r25, Z+3	; 0x03
    1a84:	0c 5f       	subi	r16, 0xFC	; 252
    1a86:	1f 4f       	sbci	r17, 0xFF	; 255
    1a88:	08 c0       	rjmp	.+16     	; 0x1a9a <vfprintf+0x1de>
    1a8a:	60 81       	ld	r22, Z
    1a8c:	71 81       	ldd	r23, Z+1	; 0x01
    1a8e:	07 2e       	mov	r0, r23
    1a90:	00 0c       	add	r0, r0
    1a92:	88 0b       	sbc	r24, r24
    1a94:	99 0b       	sbc	r25, r25
    1a96:	0e 5f       	subi	r16, 0xFE	; 254
    1a98:	1f 4f       	sbci	r17, 0xFF	; 255
    1a9a:	2f 76       	andi	r18, 0x6F	; 111
    1a9c:	72 2e       	mov	r7, r18
    1a9e:	97 ff       	sbrs	r25, 7
    1aa0:	09 c0       	rjmp	.+18     	; 0x1ab4 <vfprintf+0x1f8>
    1aa2:	90 95       	com	r25
    1aa4:	80 95       	com	r24
    1aa6:	70 95       	com	r23
    1aa8:	61 95       	neg	r22
    1aaa:	7f 4f       	sbci	r23, 0xFF	; 255
    1aac:	8f 4f       	sbci	r24, 0xFF	; 255
    1aae:	9f 4f       	sbci	r25, 0xFF	; 255
    1ab0:	20 68       	ori	r18, 0x80	; 128
    1ab2:	72 2e       	mov	r7, r18
    1ab4:	2a e0       	ldi	r18, 0x0A	; 10
    1ab6:	30 e0       	ldi	r19, 0x00	; 0
    1ab8:	a4 01       	movw	r20, r8
    1aba:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <__ultoa_invert>
    1abe:	a8 2e       	mov	r10, r24
    1ac0:	a8 18       	sub	r10, r8
    1ac2:	44 c0       	rjmp	.+136    	; 0x1b4c <vfprintf+0x290>
    1ac4:	85 37       	cpi	r24, 0x75	; 117
    1ac6:	29 f4       	brne	.+10     	; 0x1ad2 <vfprintf+0x216>
    1ac8:	2f 7e       	andi	r18, 0xEF	; 239
    1aca:	b2 2e       	mov	r11, r18
    1acc:	2a e0       	ldi	r18, 0x0A	; 10
    1ace:	30 e0       	ldi	r19, 0x00	; 0
    1ad0:	25 c0       	rjmp	.+74     	; 0x1b1c <vfprintf+0x260>
    1ad2:	f2 2f       	mov	r31, r18
    1ad4:	f9 7f       	andi	r31, 0xF9	; 249
    1ad6:	bf 2e       	mov	r11, r31
    1ad8:	8f 36       	cpi	r24, 0x6F	; 111
    1ada:	c1 f0       	breq	.+48     	; 0x1b0c <vfprintf+0x250>
    1adc:	18 f4       	brcc	.+6      	; 0x1ae4 <vfprintf+0x228>
    1ade:	88 35       	cpi	r24, 0x58	; 88
    1ae0:	79 f0       	breq	.+30     	; 0x1b00 <vfprintf+0x244>
    1ae2:	b4 c0       	rjmp	.+360    	; 0x1c4c <vfprintf+0x390>
    1ae4:	80 37       	cpi	r24, 0x70	; 112
    1ae6:	19 f0       	breq	.+6      	; 0x1aee <vfprintf+0x232>
    1ae8:	88 37       	cpi	r24, 0x78	; 120
    1aea:	21 f0       	breq	.+8      	; 0x1af4 <vfprintf+0x238>
    1aec:	af c0       	rjmp	.+350    	; 0x1c4c <vfprintf+0x390>
    1aee:	2f 2f       	mov	r18, r31
    1af0:	20 61       	ori	r18, 0x10	; 16
    1af2:	b2 2e       	mov	r11, r18
    1af4:	b4 fe       	sbrs	r11, 4
    1af6:	0d c0       	rjmp	.+26     	; 0x1b12 <vfprintf+0x256>
    1af8:	8b 2d       	mov	r24, r11
    1afa:	84 60       	ori	r24, 0x04	; 4
    1afc:	b8 2e       	mov	r11, r24
    1afe:	09 c0       	rjmp	.+18     	; 0x1b12 <vfprintf+0x256>
    1b00:	24 ff       	sbrs	r18, 4
    1b02:	0a c0       	rjmp	.+20     	; 0x1b18 <vfprintf+0x25c>
    1b04:	9f 2f       	mov	r25, r31
    1b06:	96 60       	ori	r25, 0x06	; 6
    1b08:	b9 2e       	mov	r11, r25
    1b0a:	06 c0       	rjmp	.+12     	; 0x1b18 <vfprintf+0x25c>
    1b0c:	28 e0       	ldi	r18, 0x08	; 8
    1b0e:	30 e0       	ldi	r19, 0x00	; 0
    1b10:	05 c0       	rjmp	.+10     	; 0x1b1c <vfprintf+0x260>
    1b12:	20 e1       	ldi	r18, 0x10	; 16
    1b14:	30 e0       	ldi	r19, 0x00	; 0
    1b16:	02 c0       	rjmp	.+4      	; 0x1b1c <vfprintf+0x260>
    1b18:	20 e1       	ldi	r18, 0x10	; 16
    1b1a:	32 e0       	ldi	r19, 0x02	; 2
    1b1c:	f8 01       	movw	r30, r16
    1b1e:	b7 fe       	sbrs	r11, 7
    1b20:	07 c0       	rjmp	.+14     	; 0x1b30 <vfprintf+0x274>
    1b22:	60 81       	ld	r22, Z
    1b24:	71 81       	ldd	r23, Z+1	; 0x01
    1b26:	82 81       	ldd	r24, Z+2	; 0x02
    1b28:	93 81       	ldd	r25, Z+3	; 0x03
    1b2a:	0c 5f       	subi	r16, 0xFC	; 252
    1b2c:	1f 4f       	sbci	r17, 0xFF	; 255
    1b2e:	06 c0       	rjmp	.+12     	; 0x1b3c <vfprintf+0x280>
    1b30:	60 81       	ld	r22, Z
    1b32:	71 81       	ldd	r23, Z+1	; 0x01
    1b34:	80 e0       	ldi	r24, 0x00	; 0
    1b36:	90 e0       	ldi	r25, 0x00	; 0
    1b38:	0e 5f       	subi	r16, 0xFE	; 254
    1b3a:	1f 4f       	sbci	r17, 0xFF	; 255
    1b3c:	a4 01       	movw	r20, r8
    1b3e:	0e 94 7e 0e 	call	0x1cfc	; 0x1cfc <__ultoa_invert>
    1b42:	a8 2e       	mov	r10, r24
    1b44:	a8 18       	sub	r10, r8
    1b46:	fb 2d       	mov	r31, r11
    1b48:	ff 77       	andi	r31, 0x7F	; 127
    1b4a:	7f 2e       	mov	r7, r31
    1b4c:	76 fe       	sbrs	r7, 6
    1b4e:	0b c0       	rjmp	.+22     	; 0x1b66 <vfprintf+0x2aa>
    1b50:	37 2d       	mov	r19, r7
    1b52:	3e 7f       	andi	r19, 0xFE	; 254
    1b54:	a5 14       	cp	r10, r5
    1b56:	50 f4       	brcc	.+20     	; 0x1b6c <vfprintf+0x2b0>
    1b58:	74 fe       	sbrs	r7, 4
    1b5a:	0a c0       	rjmp	.+20     	; 0x1b70 <vfprintf+0x2b4>
    1b5c:	72 fc       	sbrc	r7, 2
    1b5e:	08 c0       	rjmp	.+16     	; 0x1b70 <vfprintf+0x2b4>
    1b60:	37 2d       	mov	r19, r7
    1b62:	3e 7e       	andi	r19, 0xEE	; 238
    1b64:	05 c0       	rjmp	.+10     	; 0x1b70 <vfprintf+0x2b4>
    1b66:	ba 2c       	mov	r11, r10
    1b68:	37 2d       	mov	r19, r7
    1b6a:	03 c0       	rjmp	.+6      	; 0x1b72 <vfprintf+0x2b6>
    1b6c:	ba 2c       	mov	r11, r10
    1b6e:	01 c0       	rjmp	.+2      	; 0x1b72 <vfprintf+0x2b6>
    1b70:	b5 2c       	mov	r11, r5
    1b72:	34 ff       	sbrs	r19, 4
    1b74:	0d c0       	rjmp	.+26     	; 0x1b90 <vfprintf+0x2d4>
    1b76:	fe 01       	movw	r30, r28
    1b78:	ea 0d       	add	r30, r10
    1b7a:	f1 1d       	adc	r31, r1
    1b7c:	80 81       	ld	r24, Z
    1b7e:	80 33       	cpi	r24, 0x30	; 48
    1b80:	11 f4       	brne	.+4      	; 0x1b86 <vfprintf+0x2ca>
    1b82:	39 7e       	andi	r19, 0xE9	; 233
    1b84:	09 c0       	rjmp	.+18     	; 0x1b98 <vfprintf+0x2dc>
    1b86:	32 ff       	sbrs	r19, 2
    1b88:	06 c0       	rjmp	.+12     	; 0x1b96 <vfprintf+0x2da>
    1b8a:	b3 94       	inc	r11
    1b8c:	b3 94       	inc	r11
    1b8e:	04 c0       	rjmp	.+8      	; 0x1b98 <vfprintf+0x2dc>
    1b90:	83 2f       	mov	r24, r19
    1b92:	86 78       	andi	r24, 0x86	; 134
    1b94:	09 f0       	breq	.+2      	; 0x1b98 <vfprintf+0x2dc>
    1b96:	b3 94       	inc	r11
    1b98:	33 fd       	sbrc	r19, 3
    1b9a:	13 c0       	rjmp	.+38     	; 0x1bc2 <vfprintf+0x306>
    1b9c:	30 ff       	sbrs	r19, 0
    1b9e:	06 c0       	rjmp	.+12     	; 0x1bac <vfprintf+0x2f0>
    1ba0:	5a 2c       	mov	r5, r10
    1ba2:	b3 14       	cp	r11, r3
    1ba4:	18 f4       	brcc	.+6      	; 0x1bac <vfprintf+0x2f0>
    1ba6:	53 0c       	add	r5, r3
    1ba8:	5b 18       	sub	r5, r11
    1baa:	b3 2c       	mov	r11, r3
    1bac:	b3 14       	cp	r11, r3
    1bae:	68 f4       	brcc	.+26     	; 0x1bca <vfprintf+0x30e>
    1bb0:	b7 01       	movw	r22, r14
    1bb2:	80 e2       	ldi	r24, 0x20	; 32
    1bb4:	90 e0       	ldi	r25, 0x00	; 0
    1bb6:	3c 87       	std	Y+12, r19	; 0x0c
    1bb8:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <fputc>
    1bbc:	b3 94       	inc	r11
    1bbe:	3c 85       	ldd	r19, Y+12	; 0x0c
    1bc0:	f5 cf       	rjmp	.-22     	; 0x1bac <vfprintf+0x2f0>
    1bc2:	b3 14       	cp	r11, r3
    1bc4:	10 f4       	brcc	.+4      	; 0x1bca <vfprintf+0x30e>
    1bc6:	3b 18       	sub	r3, r11
    1bc8:	01 c0       	rjmp	.+2      	; 0x1bcc <vfprintf+0x310>
    1bca:	31 2c       	mov	r3, r1
    1bcc:	34 ff       	sbrs	r19, 4
    1bce:	12 c0       	rjmp	.+36     	; 0x1bf4 <vfprintf+0x338>
    1bd0:	b7 01       	movw	r22, r14
    1bd2:	80 e3       	ldi	r24, 0x30	; 48
    1bd4:	90 e0       	ldi	r25, 0x00	; 0
    1bd6:	3c 87       	std	Y+12, r19	; 0x0c
    1bd8:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <fputc>
    1bdc:	3c 85       	ldd	r19, Y+12	; 0x0c
    1bde:	32 ff       	sbrs	r19, 2
    1be0:	17 c0       	rjmp	.+46     	; 0x1c10 <vfprintf+0x354>
    1be2:	31 fd       	sbrc	r19, 1
    1be4:	03 c0       	rjmp	.+6      	; 0x1bec <vfprintf+0x330>
    1be6:	88 e7       	ldi	r24, 0x78	; 120
    1be8:	90 e0       	ldi	r25, 0x00	; 0
    1bea:	02 c0       	rjmp	.+4      	; 0x1bf0 <vfprintf+0x334>
    1bec:	88 e5       	ldi	r24, 0x58	; 88
    1bee:	90 e0       	ldi	r25, 0x00	; 0
    1bf0:	b7 01       	movw	r22, r14
    1bf2:	0c c0       	rjmp	.+24     	; 0x1c0c <vfprintf+0x350>
    1bf4:	83 2f       	mov	r24, r19
    1bf6:	86 78       	andi	r24, 0x86	; 134
    1bf8:	59 f0       	breq	.+22     	; 0x1c10 <vfprintf+0x354>
    1bfa:	31 ff       	sbrs	r19, 1
    1bfc:	02 c0       	rjmp	.+4      	; 0x1c02 <vfprintf+0x346>
    1bfe:	8b e2       	ldi	r24, 0x2B	; 43
    1c00:	01 c0       	rjmp	.+2      	; 0x1c04 <vfprintf+0x348>
    1c02:	80 e2       	ldi	r24, 0x20	; 32
    1c04:	37 fd       	sbrc	r19, 7
    1c06:	8d e2       	ldi	r24, 0x2D	; 45
    1c08:	b7 01       	movw	r22, r14
    1c0a:	90 e0       	ldi	r25, 0x00	; 0
    1c0c:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <fputc>
    1c10:	a5 14       	cp	r10, r5
    1c12:	38 f4       	brcc	.+14     	; 0x1c22 <vfprintf+0x366>
    1c14:	b7 01       	movw	r22, r14
    1c16:	80 e3       	ldi	r24, 0x30	; 48
    1c18:	90 e0       	ldi	r25, 0x00	; 0
    1c1a:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <fputc>
    1c1e:	5a 94       	dec	r5
    1c20:	f7 cf       	rjmp	.-18     	; 0x1c10 <vfprintf+0x354>
    1c22:	aa 94       	dec	r10
    1c24:	f4 01       	movw	r30, r8
    1c26:	ea 0d       	add	r30, r10
    1c28:	f1 1d       	adc	r31, r1
    1c2a:	80 81       	ld	r24, Z
    1c2c:	b7 01       	movw	r22, r14
    1c2e:	90 e0       	ldi	r25, 0x00	; 0
    1c30:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <fputc>
    1c34:	a1 10       	cpse	r10, r1
    1c36:	f5 cf       	rjmp	.-22     	; 0x1c22 <vfprintf+0x366>
    1c38:	33 20       	and	r3, r3
    1c3a:	09 f4       	brne	.+2      	; 0x1c3e <vfprintf+0x382>
    1c3c:	51 ce       	rjmp	.-862    	; 0x18e0 <vfprintf+0x24>
    1c3e:	b7 01       	movw	r22, r14
    1c40:	80 e2       	ldi	r24, 0x20	; 32
    1c42:	90 e0       	ldi	r25, 0x00	; 0
    1c44:	0e 94 46 0e 	call	0x1c8c	; 0x1c8c <fputc>
    1c48:	3a 94       	dec	r3
    1c4a:	f6 cf       	rjmp	.-20     	; 0x1c38 <vfprintf+0x37c>
    1c4c:	f7 01       	movw	r30, r14
    1c4e:	86 81       	ldd	r24, Z+6	; 0x06
    1c50:	97 81       	ldd	r25, Z+7	; 0x07
    1c52:	02 c0       	rjmp	.+4      	; 0x1c58 <vfprintf+0x39c>
    1c54:	8f ef       	ldi	r24, 0xFF	; 255
    1c56:	9f ef       	ldi	r25, 0xFF	; 255
    1c58:	2c 96       	adiw	r28, 0x0c	; 12
    1c5a:	e2 e1       	ldi	r30, 0x12	; 18
    1c5c:	0c 94 f8 0e 	jmp	0x1df0	; 0x1df0 <__epilogue_restores__>

00001c60 <strnlen_P>:
    1c60:	fc 01       	movw	r30, r24
    1c62:	05 90       	lpm	r0, Z+
    1c64:	61 50       	subi	r22, 0x01	; 1
    1c66:	70 40       	sbci	r23, 0x00	; 0
    1c68:	01 10       	cpse	r0, r1
    1c6a:	d8 f7       	brcc	.-10     	; 0x1c62 <strnlen_P+0x2>
    1c6c:	80 95       	com	r24
    1c6e:	90 95       	com	r25
    1c70:	8e 0f       	add	r24, r30
    1c72:	9f 1f       	adc	r25, r31
    1c74:	08 95       	ret

00001c76 <strnlen>:
    1c76:	fc 01       	movw	r30, r24
    1c78:	61 50       	subi	r22, 0x01	; 1
    1c7a:	70 40       	sbci	r23, 0x00	; 0
    1c7c:	01 90       	ld	r0, Z+
    1c7e:	01 10       	cpse	r0, r1
    1c80:	d8 f7       	brcc	.-10     	; 0x1c78 <strnlen+0x2>
    1c82:	80 95       	com	r24
    1c84:	90 95       	com	r25
    1c86:	8e 0f       	add	r24, r30
    1c88:	9f 1f       	adc	r25, r31
    1c8a:	08 95       	ret

00001c8c <fputc>:
    1c8c:	0f 93       	push	r16
    1c8e:	1f 93       	push	r17
    1c90:	cf 93       	push	r28
    1c92:	df 93       	push	r29
    1c94:	fb 01       	movw	r30, r22
    1c96:	23 81       	ldd	r18, Z+3	; 0x03
    1c98:	21 fd       	sbrc	r18, 1
    1c9a:	03 c0       	rjmp	.+6      	; 0x1ca2 <fputc+0x16>
    1c9c:	8f ef       	ldi	r24, 0xFF	; 255
    1c9e:	9f ef       	ldi	r25, 0xFF	; 255
    1ca0:	28 c0       	rjmp	.+80     	; 0x1cf2 <fputc+0x66>
    1ca2:	22 ff       	sbrs	r18, 2
    1ca4:	16 c0       	rjmp	.+44     	; 0x1cd2 <fputc+0x46>
    1ca6:	46 81       	ldd	r20, Z+6	; 0x06
    1ca8:	57 81       	ldd	r21, Z+7	; 0x07
    1caa:	24 81       	ldd	r18, Z+4	; 0x04
    1cac:	35 81       	ldd	r19, Z+5	; 0x05
    1cae:	42 17       	cp	r20, r18
    1cb0:	53 07       	cpc	r21, r19
    1cb2:	44 f4       	brge	.+16     	; 0x1cc4 <fputc+0x38>
    1cb4:	a0 81       	ld	r26, Z
    1cb6:	b1 81       	ldd	r27, Z+1	; 0x01
    1cb8:	9d 01       	movw	r18, r26
    1cba:	2f 5f       	subi	r18, 0xFF	; 255
    1cbc:	3f 4f       	sbci	r19, 0xFF	; 255
    1cbe:	31 83       	std	Z+1, r19	; 0x01
    1cc0:	20 83       	st	Z, r18
    1cc2:	8c 93       	st	X, r24
    1cc4:	26 81       	ldd	r18, Z+6	; 0x06
    1cc6:	37 81       	ldd	r19, Z+7	; 0x07
    1cc8:	2f 5f       	subi	r18, 0xFF	; 255
    1cca:	3f 4f       	sbci	r19, 0xFF	; 255
    1ccc:	37 83       	std	Z+7, r19	; 0x07
    1cce:	26 83       	std	Z+6, r18	; 0x06
    1cd0:	10 c0       	rjmp	.+32     	; 0x1cf2 <fputc+0x66>
    1cd2:	eb 01       	movw	r28, r22
    1cd4:	09 2f       	mov	r16, r25
    1cd6:	18 2f       	mov	r17, r24
    1cd8:	00 84       	ldd	r0, Z+8	; 0x08
    1cda:	f1 85       	ldd	r31, Z+9	; 0x09
    1cdc:	e0 2d       	mov	r30, r0
    1cde:	09 95       	icall
    1ce0:	89 2b       	or	r24, r25
    1ce2:	e1 f6       	brne	.-72     	; 0x1c9c <fputc+0x10>
    1ce4:	8e 81       	ldd	r24, Y+6	; 0x06
    1ce6:	9f 81       	ldd	r25, Y+7	; 0x07
    1ce8:	01 96       	adiw	r24, 0x01	; 1
    1cea:	9f 83       	std	Y+7, r25	; 0x07
    1cec:	8e 83       	std	Y+6, r24	; 0x06
    1cee:	81 2f       	mov	r24, r17
    1cf0:	90 2f       	mov	r25, r16
    1cf2:	df 91       	pop	r29
    1cf4:	cf 91       	pop	r28
    1cf6:	1f 91       	pop	r17
    1cf8:	0f 91       	pop	r16
    1cfa:	08 95       	ret

00001cfc <__ultoa_invert>:
    1cfc:	fa 01       	movw	r30, r20
    1cfe:	aa 27       	eor	r26, r26
    1d00:	28 30       	cpi	r18, 0x08	; 8
    1d02:	51 f1       	breq	.+84     	; 0x1d58 <__ultoa_invert+0x5c>
    1d04:	20 31       	cpi	r18, 0x10	; 16
    1d06:	81 f1       	breq	.+96     	; 0x1d68 <__ultoa_invert+0x6c>
    1d08:	e8 94       	clt
    1d0a:	6f 93       	push	r22
    1d0c:	6e 7f       	andi	r22, 0xFE	; 254
    1d0e:	6e 5f       	subi	r22, 0xFE	; 254
    1d10:	7f 4f       	sbci	r23, 0xFF	; 255
    1d12:	8f 4f       	sbci	r24, 0xFF	; 255
    1d14:	9f 4f       	sbci	r25, 0xFF	; 255
    1d16:	af 4f       	sbci	r26, 0xFF	; 255
    1d18:	b1 e0       	ldi	r27, 0x01	; 1
    1d1a:	3e d0       	rcall	.+124    	; 0x1d98 <__ultoa_invert+0x9c>
    1d1c:	b4 e0       	ldi	r27, 0x04	; 4
    1d1e:	3c d0       	rcall	.+120    	; 0x1d98 <__ultoa_invert+0x9c>
    1d20:	67 0f       	add	r22, r23
    1d22:	78 1f       	adc	r23, r24
    1d24:	89 1f       	adc	r24, r25
    1d26:	9a 1f       	adc	r25, r26
    1d28:	a1 1d       	adc	r26, r1
    1d2a:	68 0f       	add	r22, r24
    1d2c:	79 1f       	adc	r23, r25
    1d2e:	8a 1f       	adc	r24, r26
    1d30:	91 1d       	adc	r25, r1
    1d32:	a1 1d       	adc	r26, r1
    1d34:	6a 0f       	add	r22, r26
    1d36:	71 1d       	adc	r23, r1
    1d38:	81 1d       	adc	r24, r1
    1d3a:	91 1d       	adc	r25, r1
    1d3c:	a1 1d       	adc	r26, r1
    1d3e:	20 d0       	rcall	.+64     	; 0x1d80 <__ultoa_invert+0x84>
    1d40:	09 f4       	brne	.+2      	; 0x1d44 <__ultoa_invert+0x48>
    1d42:	68 94       	set
    1d44:	3f 91       	pop	r19
    1d46:	2a e0       	ldi	r18, 0x0A	; 10
    1d48:	26 9f       	mul	r18, r22
    1d4a:	11 24       	eor	r1, r1
    1d4c:	30 19       	sub	r19, r0
    1d4e:	30 5d       	subi	r19, 0xD0	; 208
    1d50:	31 93       	st	Z+, r19
    1d52:	de f6       	brtc	.-74     	; 0x1d0a <__ultoa_invert+0xe>
    1d54:	cf 01       	movw	r24, r30
    1d56:	08 95       	ret
    1d58:	46 2f       	mov	r20, r22
    1d5a:	47 70       	andi	r20, 0x07	; 7
    1d5c:	40 5d       	subi	r20, 0xD0	; 208
    1d5e:	41 93       	st	Z+, r20
    1d60:	b3 e0       	ldi	r27, 0x03	; 3
    1d62:	0f d0       	rcall	.+30     	; 0x1d82 <__ultoa_invert+0x86>
    1d64:	c9 f7       	brne	.-14     	; 0x1d58 <__ultoa_invert+0x5c>
    1d66:	f6 cf       	rjmp	.-20     	; 0x1d54 <__ultoa_invert+0x58>
    1d68:	46 2f       	mov	r20, r22
    1d6a:	4f 70       	andi	r20, 0x0F	; 15
    1d6c:	40 5d       	subi	r20, 0xD0	; 208
    1d6e:	4a 33       	cpi	r20, 0x3A	; 58
    1d70:	18 f0       	brcs	.+6      	; 0x1d78 <__ultoa_invert+0x7c>
    1d72:	49 5d       	subi	r20, 0xD9	; 217
    1d74:	31 fd       	sbrc	r19, 1
    1d76:	40 52       	subi	r20, 0x20	; 32
    1d78:	41 93       	st	Z+, r20
    1d7a:	02 d0       	rcall	.+4      	; 0x1d80 <__ultoa_invert+0x84>
    1d7c:	a9 f7       	brne	.-22     	; 0x1d68 <__ultoa_invert+0x6c>
    1d7e:	ea cf       	rjmp	.-44     	; 0x1d54 <__ultoa_invert+0x58>
    1d80:	b4 e0       	ldi	r27, 0x04	; 4
    1d82:	a6 95       	lsr	r26
    1d84:	97 95       	ror	r25
    1d86:	87 95       	ror	r24
    1d88:	77 95       	ror	r23
    1d8a:	67 95       	ror	r22
    1d8c:	ba 95       	dec	r27
    1d8e:	c9 f7       	brne	.-14     	; 0x1d82 <__ultoa_invert+0x86>
    1d90:	00 97       	sbiw	r24, 0x00	; 0
    1d92:	61 05       	cpc	r22, r1
    1d94:	71 05       	cpc	r23, r1
    1d96:	08 95       	ret
    1d98:	9b 01       	movw	r18, r22
    1d9a:	ac 01       	movw	r20, r24
    1d9c:	0a 2e       	mov	r0, r26
    1d9e:	06 94       	lsr	r0
    1da0:	57 95       	ror	r21
    1da2:	47 95       	ror	r20
    1da4:	37 95       	ror	r19
    1da6:	27 95       	ror	r18
    1da8:	ba 95       	dec	r27
    1daa:	c9 f7       	brne	.-14     	; 0x1d9e <__ultoa_invert+0xa2>
    1dac:	62 0f       	add	r22, r18
    1dae:	73 1f       	adc	r23, r19
    1db0:	84 1f       	adc	r24, r20
    1db2:	95 1f       	adc	r25, r21
    1db4:	a0 1d       	adc	r26, r0
    1db6:	08 95       	ret

00001db8 <__prologue_saves__>:
    1db8:	2f 92       	push	r2
    1dba:	3f 92       	push	r3
    1dbc:	4f 92       	push	r4
    1dbe:	5f 92       	push	r5
    1dc0:	6f 92       	push	r6
    1dc2:	7f 92       	push	r7
    1dc4:	8f 92       	push	r8
    1dc6:	9f 92       	push	r9
    1dc8:	af 92       	push	r10
    1dca:	bf 92       	push	r11
    1dcc:	cf 92       	push	r12
    1dce:	df 92       	push	r13
    1dd0:	ef 92       	push	r14
    1dd2:	ff 92       	push	r15
    1dd4:	0f 93       	push	r16
    1dd6:	1f 93       	push	r17
    1dd8:	cf 93       	push	r28
    1dda:	df 93       	push	r29
    1ddc:	cd b7       	in	r28, 0x3d	; 61
    1dde:	de b7       	in	r29, 0x3e	; 62
    1de0:	ca 1b       	sub	r28, r26
    1de2:	db 0b       	sbc	r29, r27
    1de4:	0f b6       	in	r0, 0x3f	; 63
    1de6:	f8 94       	cli
    1de8:	de bf       	out	0x3e, r29	; 62
    1dea:	0f be       	out	0x3f, r0	; 63
    1dec:	cd bf       	out	0x3d, r28	; 61
    1dee:	09 94       	ijmp

00001df0 <__epilogue_restores__>:
    1df0:	2a 88       	ldd	r2, Y+18	; 0x12
    1df2:	39 88       	ldd	r3, Y+17	; 0x11
    1df4:	48 88       	ldd	r4, Y+16	; 0x10
    1df6:	5f 84       	ldd	r5, Y+15	; 0x0f
    1df8:	6e 84       	ldd	r6, Y+14	; 0x0e
    1dfa:	7d 84       	ldd	r7, Y+13	; 0x0d
    1dfc:	8c 84       	ldd	r8, Y+12	; 0x0c
    1dfe:	9b 84       	ldd	r9, Y+11	; 0x0b
    1e00:	aa 84       	ldd	r10, Y+10	; 0x0a
    1e02:	b9 84       	ldd	r11, Y+9	; 0x09
    1e04:	c8 84       	ldd	r12, Y+8	; 0x08
    1e06:	df 80       	ldd	r13, Y+7	; 0x07
    1e08:	ee 80       	ldd	r14, Y+6	; 0x06
    1e0a:	fd 80       	ldd	r15, Y+5	; 0x05
    1e0c:	0c 81       	ldd	r16, Y+4	; 0x04
    1e0e:	1b 81       	ldd	r17, Y+3	; 0x03
    1e10:	aa 81       	ldd	r26, Y+2	; 0x02
    1e12:	b9 81       	ldd	r27, Y+1	; 0x01
    1e14:	ce 0f       	add	r28, r30
    1e16:	d1 1d       	adc	r29, r1
    1e18:	0f b6       	in	r0, 0x3f	; 63
    1e1a:	f8 94       	cli
    1e1c:	de bf       	out	0x3e, r29	; 62
    1e1e:	0f be       	out	0x3f, r0	; 63
    1e20:	cd bf       	out	0x3d, r28	; 61
    1e22:	ed 01       	movw	r28, r26
    1e24:	08 95       	ret

00001e26 <_exit>:
    1e26:	f8 94       	cli

00001e28 <__stop_program>:
    1e28:	ff cf       	rjmp	.-2      	; 0x1e28 <__stop_program>
